<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT Advanced 1026 Table Tennis （模拟）</title>
    <url>/2020/04/09/2020-04-09-PAT-Advanced-1026/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NzIzMzMyNTA1NjA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560">题目地址<i class="fa fa-external-link"></i></span></p>
<p>给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：</p>
<ul>
<li>当一个VIP球台空的时候，排队中的第一个VIP可以优先使用</li>
<li>如果当前没有VIP用户等待，普通用户也可以使用VIP球台</li>
<li>如果VIP用户没有VIP球台可以使用，就使用普通球台</li>
</ul>
<p>存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。</p>
<a id="more"></a>
<h2 id="基础思路">基础思路</h2>
<p>其实有很多种处理的方式，我采取的策略为：</p>
<ol type="1">
<li>用户按时间排序，将每个球台开放时间保存为数组</li>
<li>分别获取球台的最早的普通球台和VIP球台开放时间</li>
<li>如果是普通先开放，意味着没有VIP球台多余，直接给下一个等待用户即可，另外处理没有任何等待用户的情况</li>
<li>如果是VIP球台先开放（包含和普通同时开放的情况），查找顾客数组是否有VIP在等待，有的话给此VIP用户，否则给等待的第一个普通用户，如果没有人等待，进入处理无人等待的情况</li>
<li>无人等待的情况处理：没人等意味着下一个来的可以马上处理，如果来的是VIP查看是否有VIP球台，有给他，没有则给普通，普通用户则直接给空闲的编号最小的球台（此时没VIP等待）</li>
</ol>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FpeWlzaHVhaS9wLzExMzcyMTUzLmh0bWw=" title="https://www.cnblogs.com/caiyishuai/p/11372153.html">PAT 甲级 1026 Table Tennis (30 分)（坑点很多，逻辑较复杂，做了1天）<i class="fa fa-external-link"></i></span>其中的测试样例</p>
<p><strong>在提交的<code>测试点8</code>错误了，原因为：在排队是否有VIP在排队的时候，忽略了此VIP用户可能在之前以及被处理（VIP有时候可以优先）</strong></p>
<p>代码实现还是有些细节的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrival;</span><br><span class="line">    <span class="keyword">int</span> served;</span><br><span class="line">    <span class="keyword">int</span> isvip;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Player&amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrival &lt; another.arrival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt; players; <span class="comment">// 存储玩家</span></span><br><span class="line">P tables[maxn]; <span class="comment">// 桌子 first：释放时间 second：是否VIP</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>, clock_21 = <span class="number">21</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">int</span> table_count[maxn];  <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">bool</span> is_served[<span class="number">10001</span>];  <span class="comment">// 玩家是否被服务 针对VIP优先处理</span></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = sec/<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (sec%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> s = sec%<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, h, m, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 以及更新对应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_serverd_player</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> table_pos, <span class="keyword">int</span> served_time)</span> </span>&#123;</span><br><span class="line">    print_time(players[index].arrival); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>; print_time(served_time); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">int</span> wait = (served_time - players[index].arrival + <span class="number">30</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, wait);</span><br><span class="line">    is_served[index] = <span class="literal">true</span>;</span><br><span class="line">    table_count[table_pos]++;</span><br><span class="line">    tables[table_pos].first = served_time + players[index].served;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回VIP和非VIP的最小下标</span></span><br><span class="line"><span class="function">P <span class="title">getMinTableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == <span class="number">-1</span> || tables[i].first &lt; tables[index2].first) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == <span class="number">-1</span> || tables[i].first &lt; tables[index1].first) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;index1, index2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有人等待的情况 VIP的话要先看是否有空闲的VIP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_wait</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取空闲VIP和普通的最小下标</span></span><br><span class="line">    <span class="keyword">int</span> index1 = INF, index2 = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">if</span>(players[index].isvip) &#123;</span><br><span class="line">        tar = index2 == INF ? index1 : index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tar = min(index1, index2);</span><br><span class="line">    &#125;</span><br><span class="line">    push_serverd_player(index, tar, players[index].arrival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(table_count, <span class="number">0</span>, <span class="keyword">sizeof</span>(table_count));</span><br><span class="line">    <span class="built_in">memset</span>(is_served, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_served));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> hh, mm, ss, p, tag;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d %d"</span>, &amp;hh, &amp;mm, &amp;ss, &amp;p, &amp;tag);</span><br><span class="line">        <span class="keyword">int</span> sec = hh*<span class="number">3600</span> + mm*<span class="number">60</span> + ss;</span><br><span class="line">        p = p &gt; <span class="number">120</span> ? <span class="number">120</span>*<span class="number">60</span> : p*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(sec &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        players.push_back(&#123;sec, p, tag&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(players.begin(), players.end());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        tables[i] = &#123;clock_8, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止全部都是普通或者VIP 导致获取下标函数返回没有意义的值</span></span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">0</span>&#125;;</span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> vip_pos; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vip_pos);</span><br><span class="line">        tables[vip_pos<span class="number">-1</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = players.size();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_served[index]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Player p = players[index];</span><br><span class="line">        P min_index = getMinTableIndex();</span><br><span class="line">        <span class="comment">// 后面的都不用处理了</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &gt;= clock_21 &amp;&amp; tables[min_index.second].first &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> table_empty_time;</span><br><span class="line">        <span class="comment">// 普通的先空 意味着没有VIP位置 那么直接给等待的下一个</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &lt; tables[min_index.second].first) &#123;</span><br><span class="line">            table_empty_time = tables[min_index.first].first;</span><br><span class="line">            <span class="comment">// 有人在等待</span></span><br><span class="line">            <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                push_serverd_player(index, min_index.first, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没人等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                no_wait(index);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在空的VIP 位置 注意VIP普通同时为空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table_empty_time = tables[min_index.second].first;</span><br><span class="line">            <span class="comment">// 寻找是否有等待的VIP 有则先给他位置 否则给下一个人</span></span><br><span class="line">            <span class="keyword">int</span> vip_pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; len;i++) &#123;</span><br><span class="line">                <span class="comment">// Error 8:最后一个测试点卡。。已经处理的VIP 跳过</span></span><br><span class="line">                <span class="keyword">if</span>(is_served[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(players[i].arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(players[i].isvip) &#123;</span><br><span class="line">                        vip_pos = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有VIP在等</span></span><br><span class="line">            <span class="keyword">if</span>(vip_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// printf("index:%d vip:%d\n", index, vip_pos);</span></span><br><span class="line">                push_serverd_player(vip_pos, min_index.second, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有VIP在等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 但有普通人等</span></span><br><span class="line">                <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="comment">// 普通人也可以选择VIP的位置 看哪个小选哪个</span></span><br><span class="line">                    <span class="keyword">int</span> tar_pos = tables[min_index.first].first == tables[min_index.second].first ? min(min_index.second, min_index.first) : min_index.second;</span><br><span class="line">                    push_serverd_player(index, tar_pos, table_empty_time);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没人等</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    no_wait(index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,table_count[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != k<span class="number">-3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>求解图的连通分量</title>
    <url>/2020/04/06/2020-04-06-connected-components/</url>
    <content><![CDATA[<h2 id="简单定义">简单定义</h2>
<p>有向图中称为，强连通分量。连通图和连通分量都是针对无向图。</p>
<p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p>
<a id="more"></a>
<h2 id="无向图">无向图</h2>
<p>对于无向图而言，只要从一个点开始使用DFS或者BFS遍历所有可以遍历的边，这些遍历到的点集就构成了一个连通分量。然后寻找下一个之前没有遍历的点作为下一个连通分量的根结点，继续进行遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;	<span class="comment">// 连通分量的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num_nodes;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向图">有向图</h2>
<p>下面两个算法都是<span class="math inline">\(O(N+E)\)</span>的复杂度</p>
<h3 id="tarjan算法">Tarjan算法</h3>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnl2b2lkLmNvbS96aHMvYmxvZy9zY2MtdGFyamFu" title="https://www.byvoid.com/zhs/blog/scc-tarjan">有向图强连通分量的Tarjan算法<i class="fa fa-external-link"></i></span></p>
<p>算法的基本思想如下：任选一节点开始进行深度优先搜索（<strong>若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行</strong>）。搜索过程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。</p>
<p>节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。</p>
<p>算法代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      <span class="comment">// 为节点u设定次序编号和Low初值</span></span><br><span class="line">    Stack.push(u)                              <span class="comment">// 将节点u压入栈中 其实就是保存拓扑序</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E                       <span class="comment">// 枚举每一条边</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)                   <span class="comment">// 如果节点v未被访问过</span></span><br><span class="line">            tarjan(v)                          <span class="comment">// 继续向下找</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)                       <span class="comment">// 如果节点v还在栈内</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])                      <span class="comment">// 如果节点u是强连通分量的根</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                          <span class="comment">// 将v退栈，为该强连通分量中一个顶点</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>DFN[u]：为结点u的搜索编号（时间次序）</li>
<li>Low[u]：为结点u和与结点u相连的子树的最小搜索序（最早出现时间）</li>
</ul>
<p>此算法其中判断强连通分量的思路就是，在以u为根节点进行DFS的过程中如果出现一个结点v指向了之前遍历过的点t，即<span class="math inline">\(u \rightarrow t \rightarrow v \rightarrow t\)</span>也就表明出现了一个环，其中<span class="math inline">\(t,v,t\)</span>就构成了环，即连通分量。</p>
<p>其中的DFN就保存每个结点的访问顺序，Low保存相关子树的最早访问时间，在算法回溯的时候更新，可保证一个强连通分量的Low都是一致的，栈保存的是拓扑序，即遍历的次序，不断出栈获取连通分量。</p>
<h3 id="kosaraju算法">Kosaraju算法</h3>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNjQzNzkyNi5odG1s" title="https://www.cnblogs.com/nullzx/p/6437926.html">Kosaraju算法解析: 求解图的强连通分量<i class="fa fa-external-link"></i></span></p>
<p>Kosaraju算法比Tarjan算法看似要简单一些，但效率没有Tarjan算法高，Kosaraju算法依靠DFS遍历获取极大连通子图。但存在一点问题。</p>
<p><img src="\assets\ArticleImg\2020\connected-components-1.png" /></p>
<p>对于上图，从A0开始遍历和B4开始遍历是不一样的结果。如果从B开始遍历，需要2次DFS便可以遍历完整个图，而A0只需要一次。<strong>所以Kosaraju算法的第一个DFS需要获取正确的遍历顺序，</strong>然后第二次DFS的次数便是连通分量的个数了。</p>
<p>上图的反图为：</p>
<p><img src="\assets\ArticleImg\2020\connected-components-2.jpg" /></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) dfs1(v);</span><br><span class="line">  s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      dfs2(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是两点：</p>
<ol type="1">
<li>后序遍历获取拓扑序，保证BA的相对顺序不会改变</li>
<li>反向原图根据上面获取的遍历顺序，重新DFS</li>
</ol>
<h4 id="反图的作用">反图的作用</h4>
<p>其中的反图很有意思，对于强连通子图，反图和原图并无区别。但对于非强连通的则会有很大的影响。例如<span class="math inline">\(A \rightarrow B \rightarrow C\)</span>反图为<span class="math inline">\(A \leftarrow B \leftarrow C\)</span> 从A开始遍历一次便遍历完，但反图后从A开始便需要3次，也就是强连通分量的个数（单个结点也是强连通）。</p>
<p><strong>所以通过后续遍历获取遍历结点的顺序，然后通过反图获取强连通分量的个数。</strong></p>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1021 Deepest Root （连通分量+树的直径）</title>
    <url>/2020/04/03/2020-04-03-PAT-Advanced-1021/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODI5MTk2NzM4NTY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856">题目地址<i class="fa fa-external-link"></i></span></p>
<p>一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>掌握了基础的<a href="/2020/04/06/2020-04-06-connected-components/">连通分量的求法</a>以及<a href="/2020/04/02/2020-04-02-tree-diameter/">树的直径的算法</a>便很简单了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"><span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDeepest</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;height_set, <span class="keyword">int</span> heights = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            getDeepest(G[root][i], height_set, heights+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_height == heights) &#123;</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_height &lt; heights) &#123;</span><br><span class="line">            height_set.clear();</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">            max_height = heights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            components++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(components &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>, components);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st_points, ed_points;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(<span class="number">1</span>, st_points);</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(*st_points.begin(), ed_points);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ed_points) &#123;</span><br><span class="line">            st_points.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : st_points) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/2020/04/02/2020-04-02-tree-diameter/</url>
    <content><![CDATA[<p>树的直径，即<strong>树中距离最远的两个节点的距离</strong>。</p>
<h2 id="求解方法">求解方法</h2>
<p>选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。</p>
<a id="more"></a>
<h2 id="简单证明">简单证明</h2>
<p>其实只要证明：<strong>以任意点为根节点，距离此根节点最远的节点必定是树的直径中的一个端点。</strong></p>
<p>证明了这个，那么上面提到的算法就很容易证明了，获取第一个端点，然后以此端点为根的最远端点就是另外一个端点。</p>
<p>首先规定从<em>r</em>开始的最远距离节点为<em>u</em>，证明<em>u</em>为树的直径的一个端点，可以使用反证法证明，假设存在另外两个节点<em>s,t</em>，构成了树的直径。</p>
<ol type="1">
<li><p><strong><em>st</em>的路径和<em>ru</em>不相交</strong>：</p>
<p>在这种情况下，存在<span class="math inline">\(dis(u,s)+dis(s,t) &gt; dis(s,t)\)</span>，所以<em>st</em>并不是最长的，和假设相矛盾，<em>st</em>这种情况下不存在</p></li>
<li><p><strong><em>st</em>的路径和<em>ru</em>相交于点<em>v</em>：</strong></p>
<p>此时<em>s,u</em>都是以<em>a</em>为根的子树上的节点，因为u为距离a最远的结点所以可得： <span class="math display">\[
 dis(a,y)+dis(y,u) &gt; dis(a,y)+dis(y,s) \\
 即：dis(u,y) &lt; dis(s,y)
 \]</span> 同样表示<em>s,t</em>并不是最长的，而是<em>u,t</em></p></li>
</ol>
<p>综上，<em>u</em>必定为树的直径的一个端点。</p>
<p>关于树的直径的更多性质可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2hhZGEtSmhpbi9wLzEwMTk1Mjg3Lmh0bWw=" title="https://www.cnblogs.com/Khada-Jhin/p/10195287.html">博客园 树的直径及其性质与证明<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1020 Tree Traversals （二叉树）</title>
    <url>/2020/04/01/2020-04-01-PAT-Advanced-1020/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODUwMzM2MDMwNzI=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072">题目地址<i class="fa fa-external-link"></i></span></p>
<p>给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了</p>
<a id="more"></a>
<h2 id="解决思路">解决思路</h2>
<p>这是一个很经典的重构二叉树的问题了，只要清楚每种遍历的规则和规律即可。</p>
<p>后序遍历：左子树，右子树，根节点</p>
<p>中序遍历：左子树，根节点，右子树</p>
<p>所以对后序遍历而言，后面的节点是前面节点构成的树的根节点，前面节点构成左子树和右子树，所以我们可以采取以下方案获取整棵树的结构。</p>
<p>从后序遍历数组<code>postorder</code>的末尾开始，从<code>inorder</code>数组中寻找和<code>postorder</code>相同值的，<strong>这样就可以分为两边，分别是左子树和右子树</strong>。然后将<code>postorder</code>末尾向前移动一步，对应的就是右子树的根节点。然后在<code>inorder</code>刚刚分开的右半边继续寻找即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> postorder[maxn];</span><br><span class="line"><span class="keyword">int</span> inorder[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left = <span class="literal">NULL</span>, *right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一棵树 根据根节点的值（这里提供postorder的下标），以及inorder的左右边界</span></span><br><span class="line"><span class="function">Node* <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> post_i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *t_root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 分开左右子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == postorder[post_i]) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_root-&gt;val = inorder[mid];</span><br><span class="line">    <span class="comment">// 递归左右子数</span></span><br><span class="line">    t_root-&gt;right = getTree(post_i<span class="number">-1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    t_root-&gt;left = getTree(post_i - (r - mid) - <span class="number">1</span>, l, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, postorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, inorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getTree(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">    que.push(root-&gt;left);</span><br><span class="line">    que.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        Node *t = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,t-&gt;val);</span><br><span class="line">        que.push(t-&gt;left);</span><br><span class="line">        que.push(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1018 Public Bike Management（Dijkstra + DFS）</title>
    <url>/2020/03/31/2020-03-31-PAT-Advanced-1018/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODkyODI0MzMwMjQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024">题目地址<i class="fa fa-external-link"></i></span></p>
<p>一眼看去便是最短路问题，和<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003<i class="fa fa-external-link"></i></span>，有点类似，但又不同。</p>
<p>题目就是求最短路，多条最短路取从基地携带数量最少了，如果有一样的携带数量，就取带回数量最少的，确保这样的路径唯一。</p>
<a id="more"></a>
<h2 id="解决思路">解决思路</h2>
<p>开始以为与<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003<i class="fa fa-external-link"></i></span>一样，但是还是不一样的，因为最短路的子路并不是最优子结构，也就是满足当前的最优条件不一定会满足整体的。这里就必须先将所有的最短路找出，然后计算每一条路的携带数量和带回数量，来选取最优的路径。</p>
<p>有一个一不注意就中招的坑：在计算携带数量和带回数量的时候需要考虑先后关系，即后面多余的车不能补充前面的。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;    <span class="comment">// P.first 为 起始点到 P.second 的最短路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, cost;&#125;;<span class="comment">// 边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];       <span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn];           <span class="comment">// 每个站点的权值</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];                <span class="comment">// 对应点的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev_node[maxn];        <span class="comment">// 最短路的树结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; shortest_paths; <span class="comment">// 起始点到问题点的所有最短路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 获取路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    temp.push_back(root);</span><br><span class="line">    <span class="keyword">if</span>(prev_node[root].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        shortest_paths.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prev_node[root].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        dfs(prev_node[root][i], temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">int</span> c_max, n, problem, m; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;c_max, &amp;n, &amp;problem, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        weight[i] = c_max/<span class="number">2</span> - temp; <span class="comment">// 正 表示carry 负 表示 back</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st, ed, cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;st, &amp;ed, &amp;cost);</span><br><span class="line">        G[st].push_back(&#123;ed, cost&#125;);</span><br><span class="line">        G[ed].push_back(&#123;st, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt;&gt; que;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        P t = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(d[t.second] &lt; t.first) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[t.second].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            edge e = G[t.second][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to] = &#123;t.second&#125;;</span><br><span class="line">                d[e.to] = d[t.second] + e.cost;</span><br><span class="line">                que.push(make_pair(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[e.to] == d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to].push_back(t.second);    <span class="comment">// 添加前置节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(problem);</span><br><span class="line">    <span class="keyword">int</span> min_carry = INF, min_back = INF, min_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; shortest_paths.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, back = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = shortest_paths[i].<span class="built_in">size</span>() - <span class="number">2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="comment">// 坑点 必须按照路径的前进 方向改变对于数值，即后面节点的多余不能给前面节点使用</span></span><br><span class="line">            <span class="keyword">int</span> need = weight[shortest_paths[i][j]];</span><br><span class="line">            <span class="keyword">if</span>(need &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                carry += back - need &gt; <span class="number">0</span> ? <span class="number">0</span> : need - back;</span><br><span class="line">                back = back - need &gt; <span class="number">0</span> ? back - need : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                back += -need;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &lt; min_carry) &#123;</span><br><span class="line">            min_carry = carry;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(carry == min_carry &amp;&amp; back &lt; min_back) &#123;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, min_carry);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = shortest_paths[min_index].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, shortest_paths[min_index][i]);</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, min_back);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>画个简陋樱花树（简单递归）</title>
    <url>/2020/03/31/2020-03-31-Draw-CherryTree/</url>
    <content><![CDATA[<blockquote>
<p>看到网上很多代码绘制的樱花树，参见<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0Mzk3Ny9hcnRpY2xlL2RldGFpbHMvMTAyNjkxMzky" title="https://blog.csdn.net/weixin_43943977/article/details/102691392">CSDN<i class="fa fa-external-link"></i></span>，便想自己试试，但是画的有点丑</p>
</blockquote>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>其实就是一个“二叉树的遍历”的思路，使用递归不断的二叉，就可以了，这也算是分形图案了。但是简单的递归二叉，不掌握好长度、角度、粗细以及主干和枝干的变化就会很规整。所以慢慢调参吧。</p>
<p>这里采用的是给出每个参数的最大取值范围，然后设置一个缩小的函数，随着递归层数的提高，对应的参数越来越小，这个小的程度和范围就要自己把握了。</p>
<p>缩小函数可以参考：<span class="math inline">\(\frac{1}{n},\frac{1}{\sqrt{n}}\)</span></p>
<h2 id="依赖">依赖</h2>
<p>这里的樱花树使用的是一个简单的<span class="exturl" data-url="aHR0cHM6Ly9lYXN5eC5jbi8=" title="https://easyx.cn/">C++图形库 easyx<i class="fa fa-external-link"></i></span>，简单容易上手。</p>
<h2 id="演示">演示</h2>
<video src="/assets/ArticleVideo/2020/draw-cherrytree.mp4" preload="metadata" controls playsinline poster="">Sorry, your browser does not support the video tag.</video>
<h2 id="基础代码">基础代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED (RGB(240, 128, 128))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE (RGB(255, 255, 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROWN (RGB(160, 82, 45))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与主干角度的偏移角度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_min = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_max = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_min = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_max = <span class="number">90</span>;</span><br><span class="line"><span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> thick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区大小</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = <span class="number">800</span>, <span class="built_in">height</span> = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一条线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawline</span><span class="params">(Point st, Point ed)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">line</span>(st.first, st.second, ed.first, ed.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生范围内的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_range</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st + rand() % (ed - st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给点原点 相对于水平的角度 长度 返回处理后的节点</span></span><br><span class="line"><span class="function">Point <span class="title">getPointFromAngle</span><span class="params">(Point src, <span class="keyword">float</span> angle, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    angle = <span class="number">3.14</span>/<span class="number">180.0</span> * angle;</span><br><span class="line">    <span class="keyword">return</span> &#123; src.first+length*<span class="built_in">cos</span>(angle), src.second-length*<span class="built_in">sin</span>(angle) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归画叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_bifurcation</span><span class="params">(Point p, <span class="keyword">float</span> angle, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束层</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 偏移角</span></span><br><span class="line">    <span class="keyword">float</span> delta = rand_range(angle_min, angle_max);</span><br><span class="line">    <span class="comment">// 收缩 使用根号</span></span><br><span class="line">    <span class="keyword">float</span> shrink = <span class="built_in">pow</span>(layer, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 便宜的角度越来越小</span></span><br><span class="line">    <span class="keyword">float</span> left_angle = angle + delta/shrink;</span><br><span class="line">    <span class="comment">// 右分支的角度确定</span></span><br><span class="line">    <span class="keyword">float</span> right_angle = left_angle - <span class="number">2.4</span>*delta/shrink;</span><br><span class="line">    <span class="comment">// 随机长度</span></span><br><span class="line">    <span class="keyword">int</span> length_left = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="keyword">int</span> length_right = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="comment">// 获取下一个分支点</span></span><br><span class="line">    Point left = getPointFromAngle(p, left_angle, length_left);</span><br><span class="line">    Point right = getPointFromAngle(p, right_angle, length_right);</span><br><span class="line">    <span class="comment">// 末端绘制红白相间的花瓣</span></span><br><span class="line">    <span class="keyword">int</span> type = rand() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置厚度</span></span><br><span class="line">    setlinestyle(PS_SOLID , thick/layer);</span><br><span class="line">    drawline(p, left);</span><br><span class="line">    <span class="comment">// 递归左分支</span></span><br><span class="line">    draw_bifurcation(left, left_angle, layer + <span class="number">1</span>);</span><br><span class="line">    setlinestyle(PS_SOLID, thick / layer);</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态效果</span></span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    drawline(p, right);</span><br><span class="line">    <span class="comment">// 递归右分支</span></span><br><span class="line">    draw_bifurcation(right, right_angle, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机绘制地面的花瓣</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_ground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">width</span> * <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">width</span> * <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="built_in">height</span> - <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line">    setlinecolor(RED);</span><br><span class="line">    setlinestyle(PS_SOLID, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y, angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        x = rand_range(left, right);</span><br><span class="line">        y = rand_range(up, down);</span><br><span class="line">        angle = rand_range(<span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line">        Point ed = getPointFromAngle(&#123; x, y &#125;, angle, length);</span><br><span class="line">        Sleep(<span class="number">5</span>);</span><br><span class="line">        drawline(&#123; x, y &#125;, ed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initgraph(<span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    <span class="comment">// 设置背景色</span></span><br><span class="line">    setbkcolor(RGB(<span class="number">241</span>, <span class="number">215</span>, <span class="number">118</span>));</span><br><span class="line">    cleardevice();</span><br><span class="line">    <span class="comment">// 绘制主干</span></span><br><span class="line">    setlinecolor(BROWN);</span><br><span class="line">    setlinestyle(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">line</span>(<span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-110</span>, <span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-20</span>);</span><br><span class="line">    <span class="comment">// 递归绘制</span></span><br><span class="line">    draw_bifurcation(&#123; <span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-110</span> &#125;, <span class="number">90.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 绘制掉落花瓣的地面</span></span><br><span class="line">    draw_ground();</span><br><span class="line">    _getch();</span><br><span class="line">    closegraph();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ELSE</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1017 Queueing at Bank（优先队列）</title>
    <url>/2020/03/29/2020-03-29-PAT-Advanced-1017/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTE1MzA1Nzk5Njg=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968">题目地址<i class="fa fa-external-link"></i></span></p>
<p>和 1014 很相似的题目，同样使用优先队列解决，容易的一道题。</p>
<p>题目的意思是真的难懂，17：00之后不能被服务，17：00 是到达时间。。不是服务时间，服务时间不能超过1小时是指大于1小时的按一小时处理，而不是不处理</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrive;</span><br><span class="line">    <span class="keyword">int</span> leave;</span><br><span class="line">    <span class="keyword">int</span> serve_secs;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer &amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrive &lt; another.arrive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_17 = <span class="number">17</span>*<span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> whole_wait_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> legal_nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h, m, s, t; <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d"</span>, &amp;h, &amp;m, &amp;s, &amp;t);</span><br><span class="line">        <span class="keyword">int</span> arrive = h*<span class="number">60</span>*<span class="number">60</span> + m*<span class="number">60</span> + s;</span><br><span class="line">        <span class="keyword">if</span>(arrive &gt; clock_17) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        customers[legal_nums].arrive = arrive;</span><br><span class="line">        customers[legal_nums++].serve_secs = t &gt; <span class="number">60</span> ? <span class="number">3600</span> : t*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(customers, customers + legal_nums);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; leave_que;</span><br><span class="line">    <span class="comment">// 先push M 个 8：00 全在8点离开</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        leave_que.push(clock_8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; legal_nums;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> serve_time = <span class="built_in">max</span>(leave_que.top(), customers[i].arrive); leave_que.pop();</span><br><span class="line">        leave_que.push(serve_time + customers[i].serve_secs);</span><br><span class="line">        whole_wait_sec += serve_time - customers[i].arrive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, legal_nums == <span class="number">0</span> ? <span class="number">0.0</span> : whole_wait_sec/<span class="number">60.0</span>/legal_nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1016 Phone Bills（排序）</title>
    <url>/2020/03/27/2020-03-27-PAT-Advanced-1016/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTM2NDg3MDM0ODg=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488">题目地址<i class="fa fa-external-link"></i></span></p>
<p>提交了整整一个下午。。。</p>
<p>再次吐槽PAT的题目描述，很多时候都是迷迷糊糊的，很多地方没有说清楚。</p>
<p>这道题一个巨大的坑：<strong>没有符合条件的时间对时，不输出该用户信息</strong></p>
<p>太坑了。。</p>
<a id="more"></a>
<h2 id="题目思路">题目思路</h2>
<p>题目还是比较简单的，简单的排序即可，可以全部存为一个数组，然后先按名字排序，在名字相同时按时间排序即可。此处采用 C++ Map 分类。对每一个顾客的时间进行排序。然后仅当 当前时间为 <code>on-line</code>紧跟着的下一个时间为<code>off-line</code> 为有效时间对。</p>
<p>仅当存在有效时间对时才有对应的输出。</p>
<p>对于一段时间的计费，可以分别计算单独时间到<code>00:00:00</code>的费用，然后相减即可，一个很好的思路。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, mon, day, hour, mins;</span><br><span class="line">    <span class="keyword">bool</span> type;  <span class="comment">// 1: on-line 0: off-line</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Record&amp; another) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; another.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;Record&gt;&gt; calls;</span><br><span class="line"><span class="keyword">int</span> price_table[<span class="number">24</span>], price_day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCost</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = tar.day, h = tar.hour, m = tar.mins;</span><br><span class="line">    ll cost = d * price_day;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++) &#123;</span><br><span class="line">        cost += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cost += price_table[h]*m;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, tar.day, tar.hour, tar.mins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">24</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, price_table+i);</span><br><span class="line">        price_day += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> customer, t, <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; customer;</span><br><span class="line">        Record temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d:%d"</span>, &amp;temp.mon, &amp;temp.day, &amp;temp.hour, &amp;temp.mins);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">line</span>;</span><br><span class="line">        temp.type = <span class="built_in">line</span> == <span class="string">"on-line"</span>;</span><br><span class="line">        temp.t = <span class="number">24</span>*<span class="number">60</span>*temp.day + <span class="number">60</span>*temp.hour + temp.mins; <span class="comment">// 获取从00:00:00到此的分钟数</span></span><br><span class="line">        calls[customer].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : calls) &#123;</span><br><span class="line">        sort(i.second.<span class="built_in">begin</span>(), i.second.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = i.second.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">float</span> cost_all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 判断是否存在有效时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">size</span> - <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second[j].type == <span class="literal">true</span> &amp;&amp; i.second[j+<span class="number">1</span>].type == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i.first &lt;&lt; <span class="string">" "</span>; <span class="built_in">printf</span>(<span class="string">"%02d\n"</span>, i.second[<span class="number">0</span>].mon);</span><br><span class="line">                &#125;</span><br><span class="line">                printTime(i.second[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                printTime(i.second[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> temp_cost = (getCost(i.second[j+<span class="number">1</span>]) - getCost(i.second[j]))/<span class="number">100.0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d $%.2f\n"</span>, i.second[j+<span class="number">1</span>].t - i.second[j].t, temp_cost);</span><br><span class="line">                cost_all += temp_cost;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Total amount: $%.2f\n"</span>, cost_all);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>埃氏筛 &amp; 欧拉筛</title>
    <url>/2020/03/24/2020-03-24-prime-sieve/</url>
    <content><![CDATA[<blockquote>
<p>素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。</p>
</blockquote>
<a id="more"></a>
<h2 id="试除法">试除法</h2>
<p>直接使用定义解决的方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从2遍历到<span class="math inline">\(\sqrt n\)</span> 因为之后的就没有必要了，一个和数拆分成两个因子必定是在<span class="math inline">\(\sqrt n\)</span>的两侧，是对称的，所以只需要遍历一边就可以了。</p>
<h2 id="埃氏筛">埃氏筛</h2>
<p>上面的算法是判断一个数是否是素数，但是对获取某个范围的素数开销非常大。埃氏筛（素数筛）就是求某个范围素数的算法。</p>
<p>原理很简单，合数必定可以拆分为一系列素数的积，即<strong>某个素数的任意倍数都是合数</strong>。</p>
<p>代码也很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// maxn 为范围的上届</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; maxn;j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为：<span class="math inline">\(n\log \log n\)</span></p>
<h2 id="欧拉筛">欧拉筛</h2>
<p>埃氏筛很明显的一个缺点就是一个合数会被重复筛掉（被每一个素数因子筛一次），增加复杂度。欧拉筛就是在其上的改进，使每一个合数只被它的最小因子筛掉。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;i*prime_numbers[j] &lt; maxn;j++) &#123;</span><br><span class="line">        is_prime[i*prime_numbers[j]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime_numbers[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉筛复杂度为n（将空循环不视作开销），每个合数仅被筛一次。</p>
<p>核心就在于<code>i % prime_numbers[j] == 0</code>，当这个条件成立的时候跳出循环，不继续往下筛，下面的都是已经或者未来要被筛掉的。</p>
<p>条件成立时意味着 <span class="math inline">\(i = prime\_numbers[j] \times K\)</span>，而继续循环下去回得到<span class="math inline">\(i*prime\_numbers[j+1]\)</span>也就是,<span class="math inline">\(prime\_numbers[j]\times prime\_numbers[j+1] \times K = prime\_numbers[j] \times Q\)</span>，也就是说它会被<span class="math inline">\(prime\_numbers[j]\)</span>乘以另外一个数给筛掉，之后的循环也就没必要进行了。也保证了，每个合数都只被它的最小因子筛掉。</p>
<p>令<span class="math inline">\(N = K \times Q \times ...\)</span> K Q为两个素数且<span class="math inline">\(Q \gt K\)</span>，假设N可以被Q筛掉，也就是$N = Q M， M= K... $这里的M就是上面循环中的i，它是不可能使用QM筛掉的，因为<code>M%K == 0</code>，就跳出循环之外了。</p>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1012 The Best Rank（排序）</title>
    <url>/2020/03/21/2020-03-21-PAT-Advanced-1012/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDI2NTgwNjg0ODA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480">题目地址<i class="fa fa-external-link"></i></span></p>
<a id="more"></a>
<p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks -- that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p>
<p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure>
<p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a line containing 2 numbers <em>N</em> and <em>M</em> (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then <em>N</em> lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are <em>M</em> lines, each containing a student ID.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each of the <em>M</em> students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p>
<p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p>
<p>If a student is not on the grading list, simply output <code>N/A</code>.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N&#x2F;A</span><br></pre></td></tr></table></figure>
<h2 id="基本思路">基本思路</h2>
<p>题目本身没什么，就是PAT题目条件给的<strong>太隐晦</strong>了。。。很多条件都不明说</p>
<p>对于平均分是否四舍五入，并列的处理都不明说，全部藏在例子里面</p>
<p>是需要<strong>四舍五入</strong>的对于<strong>并列是 1 1 3 4 5</strong>这种（没有第二名了就）</p>
<p>所以只要把握这两点，这题目就很水了</p>
<p>首先按<em>ACME</em>的顺序对学生成绩排序，然后更新每个学生最好成绩就可以了，按<em>ACME</em>的顺序也是根据优先级安排的，在相同名次下，后排序更新的不做处理</p>
<p>这题目还可以使用<strong>空间换时间的思路</strong>，稍微加快一点处理，比如判断是否存在学生，因为学生的学号是个整数，所以直接开辟那么大的数组记录即可，对每个学生的分数排名都可以这么处理</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>]; <span class="comment">// A C M E 对应的分数</span></span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn_ = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_exist[maxn_];   <span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">int</span> best_rank[maxn_];   <span class="comment">// 记录对应的最好成绩</span></span><br><span class="line"><span class="keyword">int</span> best_rank_type[maxn_];  <span class="comment">// 记录最好成绩对应的学科</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(is_exist, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_exist));</span><br><span class="line">    <span class="built_in">memset</span>(best_rank, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(best_rank));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;stu[i].id, &amp;stu[i].score[<span class="number">1</span>], &amp;stu[i].score[<span class="number">2</span>], &amp;stu[i].score[<span class="number">3</span>]);</span><br><span class="line">        stu[i].score[<span class="number">0</span>] = (stu[i].score[<span class="number">1</span>]+stu[i].score[<span class="number">2</span>]+stu[i].score[<span class="number">3</span>])/<span class="number">3</span> + <span class="number">0.5</span>; <span class="comment">// 四舍五入</span></span><br><span class="line">        is_exist[stu[i].id] = <span class="literal">true</span>; <span class="comment">// 标记为存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四个分数排序 按 A C M E 的顺序</span></span><br><span class="line">    <span class="comment">// 相同的情况后不能覆盖前（优先级）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        sort(stu, stu+n, [i](Stu &amp;a, Stu &amp;b)&#123; <span class="keyword">return</span> a.score[i] &gt; b.score[i]; &#125;);</span><br><span class="line">        <span class="keyword">if</span>(best_rank[stu[<span class="number">0</span>].id] != <span class="number">0</span>) &#123;</span><br><span class="line">            best_rank[stu[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">            best_rank_type[stu[<span class="number">0</span>].id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last_rank = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意处理并列。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j<span class="number">-1</span>].score[i] != stu[j].score[i]) &#123;</span><br><span class="line">                last_rank = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(best_rank[stu[j].id] &gt; last_rank) &#123;</span><br><span class="line">                best_rank[stu[j].id] = last_rank;</span><br><span class="line">                best_rank_type[stu[j].id] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> type[] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span>(is_exist[id]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %c\n"</span>, best_rank[id] + <span class="number">1</span>, type[best_rank_type[id]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N/A\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1014 Waiting in Line（优先队列）</title>
    <url>/2020/03/21/2020-03-24-PAT-Advanced-1014/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTgyMDc5MTE5MzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936">题目地址<i class="fa fa-external-link"></i></span></p>
<p>之前一直错还是题目看错，英文题目还是要注意啊。</p>
<p>17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。</p>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>题目本身不难，理清楚过程即可。（他题目有些也迷）</p>
<p>给出了N个窗口以及最大等待区M，K个顾客。相当于本来就有K个人在排队，然后每个人依次选窗口当等待区有空位的适合。等待区总共可以容纳NM个人，所以最前面的NM个人依次排满等待区即可（按照题目定的规则），当等待区满的时候，只要有一个人结束服务，那在等待区外排队的人就马上可以塞进去一个。</p>
<p>所以我们需要知道的就是最早结束服务的人，这就可以用到优先队列了，维护结束服务的时间。时间越早优先级越高。每当他进入等待区，就push到优先队列中。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> win_index;</span><br><span class="line">    <span class="keyword">int</span> end_time;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer&amp; other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 同时离开 选择编号小的</span></span><br><span class="line">        <span class="keyword">return</span> end_time != other.end_time ? end_time &gt; other.end_time : win_index &gt; other.win_index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost_time[maxn];    <span class="comment">// 用户的花费时间</span></span><br><span class="line"><span class="keyword">int</span> end_time[maxn];     <span class="comment">// 每个用户的结束时间</span></span><br><span class="line"><span class="keyword">int</span> win_cur_time[<span class="number">21</span>];   <span class="comment">// 当前窗口等待区清空的最晚时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(win_cur_time, <span class="number">0</span>, <span class="keyword">sizeof</span>(win_cur_time));</span><br><span class="line">    <span class="built_in">memset</span>(end_time, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(end_time));</span><br><span class="line">    <span class="keyword">int</span> n, m, k, q; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, cost_time+i);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;Customer&gt; que;</span><br><span class="line">    <span class="comment">// 前NM个直接加入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k &amp;&amp; i &lt; n*m;i++) &#123;</span><br><span class="line">        win_cur_time[i%n] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[i%n];</span><br><span class="line">        que.push(&#123;i%n, end_time[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n*m;i &lt; k;i++) &#123;</span><br><span class="line">        Customer temp = que.top(); que.pop();   <span class="comment">// 获取最早离开的</span></span><br><span class="line">        win_cur_time[temp.win_index] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[temp.win_index];</span><br><span class="line">        temp.end_time = end_time[i];</span><br><span class="line">        que.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tar);</span><br><span class="line">        <span class="keyword">int</span> mins = end_time[tar<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// 开始服务的时间不能晚于17:00</span></span><br><span class="line">        <span class="keyword">if</span>(mins - cost_time[tar<span class="number">-1</span>] &gt;= <span class="number">540</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorry\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:%02d\n"</span>, <span class="number">8</span>+mins/<span class="number">60</span>, mins%<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1010 Radix（二分法）</title>
    <url>/2020/03/19/2020-03-19-PAT-Advanced-1010/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDcyMjU2NjU1MzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536">题目地址<i class="fa fa-external-link"></i></span></p>
<a id="more"></a>
<p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p>
<p>Now for any pair of positive integers <em>N</em>1 and <em>N</em>2, your task is to find the radix of one number while that of the other is given.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N1 N2 tag radix</span><br></pre></td></tr></table></figure>
<p>Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>
<h2 id="基本思路">基本思路</h2>
<p>PAT题目都很迷，很多地方都不说清楚输入范围。。。</p>
<p>这道题输入数据不会超过<code>long long</code>，所以可以放心的使用基本思路计算不同进制下的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果每次都从进制2开始递增进制，直到一种不可能的情况出现，但这种方法对大小差距极大的两个数特别耗时，对于这种<strong>在一个序列中寻找一个正确解</strong>的过程，显然是用二分法解决。</p>
<p>但是二分法需要一个范围，那么这道题的进制范围是在哪一个范围。首先对于R进制的串，对于数串内的数必须小于R，所以获取此串的最小进制（下界）就显而易见了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">'0'</span> &amp;&amp; tar &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以使用C++的max_element函数</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">max</span>(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上界即为<code>max(minRadix,  num)</code> num为已知进制的数的值，因为题目中只涉及到0-35的值，所以num作为上届已经足够，因为个位是不可能达到num值的最高就是35，那么在2位数字的情况下最小也是10，此时10在num进制下就是num，所以num进制的最小值就是num，在往上就会大于num就没有必要了</p>
<p>所有在上下界进行二分法查找即可</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">'0'</span> &amp;&amp; tar &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">max</span>(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">if</span>(tag == <span class="number">2</span>) &#123;</span><br><span class="line">        swap(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// B 是 要计算的</span></span><br><span class="line">    ll tar = getRes(A, radix);</span><br><span class="line">    <span class="comment">//  二分</span></span><br><span class="line">    ll left = getMinRadix(B);</span><br><span class="line">    ll right = <span class="built_in">max</span>(left, tar);</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        ll mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll temp = getRes(B, mid);</span><br><span class="line">        <span class="keyword">if</span>(temp == tar) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, mid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; <span class="number">0</span> || temp &gt; tar) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib 图像直接导出为 ndarray</title>
    <url>/2020/03/12/2020-03-12-Matplotlib-DirectlyOutput-Img/</url>
    <content><![CDATA[<h2 id="导出为ndarray格式图片">导出为ndarray格式图片</h2>
<p><em>matplotlib</em> 绘制的图线有自己的显示窗口，有时候希望在其他的<em>UI</em>设计中使用其绘制的图，比如<em>PyQt</em>，官方有一个支持QT的显示窗口类，但配置很麻烦，在这里记录一种简便的导出方式</p>
<p>主要思路为使用<em>matplotlib</em>的<code>print_png</code>函数将其图片数据导出到二进制流中，然后<em>numpy</em>从此二进制流中取出数据即可</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># matplotlib 绘制区</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">1.2</span>, <span class="number">2.5</span>, <span class="number">4.5</span>, <span class="number">7.3</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure(<span class="string">"Image"</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">canvas = fig.canvas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取二进制流</span></span><br><span class="line">buffer = io.BytesIO()</span><br><span class="line">canvas.print_png(buffer)</span><br><span class="line">data = buffer.getvalue()</span><br><span class="line">buffer.write(data)</span><br><span class="line">buffer.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 获取数据</span></span><br><span class="line">file_bytes = np.asarray(bytearray(buffer.read()), dtype=np.uint8)</span><br><span class="line"><span class="comment"># opencv 读取</span></span><br><span class="line">img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">buffer.close()</span><br></pre></td></tr></table></figure>
<h2 id="设置matplotlib-borders便于鼠标信息处理坐标">设置matplotlib borders便于鼠标信息处理（坐标）</h2>
<p>有时候仅导出为图片还不够，还需要实现用户的交互操作，在原生<em>matplotlib</em>中可以绑定事件以实现用户交互，但导出为图片时，就不得行了，但只需要获取坐标和图片宽高之间的关系，就可以简单的坐标转换一下就可以实现了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置显示的图像（不包括坐标轴，仅绘图区）显示在figure的位置</span></span><br><span class="line">left, bottom, right, top = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0</span>,<span class="number">9</span></span><br><span class="line">plt.subplots_adjust(left=left, bottom=bottom, right=right, top=top)</span><br></pre></td></tr></table></figure>
<h3 id="坐标转换">坐标转换</h3>
<p>因为知道绘图区在整个图的相对位置，所以可以很好的处理</p>
<p>下面例子为<em>PyQt5</em>使用<em>widget</em>显示图片，<em>widget</em>到曲线坐标系的转换（曲线坐标系x,y均在[0,1]之间）</p>
<p><strong>即左上角为原点的屏幕坐标系到[0,1]坐标范围的图表坐标系的转换</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w, h = width(), height() <span class="comment"># 即为显示图片的容器大小</span></span><br><span class="line">plot_w, plot_h = (right - left)*w, (top - bottom)*h <span class="comment"># 绘图区大小</span></span><br><span class="line"><span class="comment"># 图标坐标到全图的像素坐标转换</span></span><br><span class="line">coord2bk = <span class="keyword">lambda</span> coord: [coord[<span class="number">0</span>]*plot_w + w*left, h*(<span class="number">1</span>-bottom) - coord[<span class="number">1</span>]*plot_h]</span><br><span class="line"><span class="comment"># 全图坐标到像素坐标的转换</span></span><br><span class="line">bk2coord = <span class="keyword">lambda</span> coord: [(coord[<span class="number">0</span>] - w*left) / plot_w ,<span class="number">1</span> - (coord[<span class="number">1</span>] - h*(<span class="number">1</span>-top)) / plot_h]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ELSE</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
        <tag>PyQT</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下 第6版 阅读笔记</title>
    <url>/2020/03/02/2020-03-02-Compute-Networking-A-Top-Down-Approach-6th/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Ryb3k5MjIvQ29tcHV0ZXItTmV0d29yay9ibG9iL21hc3Rlci/orqHnrpfmnLrnvZHnu5zoh6rpobblkJHkuIvmlrnms5XnrZTmoYgo6Iux5paH56ys5YWt54mIKS5wZGY=" title="https://github.com/Troy922/Computer-Network/blob/master/计算机网络自顶向下方法答案(英文第六版).pdf">书本配套答案<i class="fa fa-external-link"></i></span></p>
<blockquote>
<p>2020-01-07 Joke-Lin</p>
</blockquote>
<a id="more"></a>
<h2 id="chapter-1-计算机网络和因特网">Chapter 1 计算机网络和因特网</h2>
<h3 id="网络边缘">1. 网络边缘</h3>
<h4 id="物理媒介">物理媒介</h4>
<p>分为两类：导引型（guided media），非导引型（unguided media）</p>
<ul>
<li>双绞铜线（Twisted-Pair Copper Wire）</li>
<li>同轴电缆（Coaxial Cable）</li>
<li>光纤（Fiber Optics）</li>
<li>陆地无线电信道（Terrestrial Radio Channels）</li>
<li>卫星无线电信道（Satellite Radio Channel）</li>
</ul>
<h3 id="网络核心">*2. 网络核心</h3>
<blockquote>
<p>the mesh of packet switches and links that interconnects the Internet’s end systems</p>
</blockquote>
<h4 id="i.-packet-switching-分组交换">i. Packet Switching 分组交换</h4>
<blockquote>
<p>breaks <strong>long messages</strong> into smaller chunks of data known as <strong>packets</strong>. Between source and destination, each packet travels through <strong>communication links</strong> and <strong>packet switches</strong> (for which there are two predominant types, routers and linklayer switches)</p>
<p>Packets are transmitted over each communication link at a rate equal to the <strong>full transmission rate of the link.</strong></p>
</blockquote>
<h5 id="a.-store-and-forward-transmission-存储转发传输">a. Store-and-Forward Transmission 存储转发传输</h5>
<p>Store-and-forward transmission means that the packet switch <strong>must receive the entire packet before it can begin to transmit the first bit of the packet</strong> onto the outbound link.</p>
<p>P个分组经过N条链路，每一个分组大小是L，速率为R</p>
<p>端到端的时延是：<span class="math inline">\((N+P-1)\frac{L}{R}\)</span></p>
<h5 id="b.-queuing-delays-and-packet-loss">b. Queuing Delays and Packet Loss</h5>
<p>Packet Swith have a <strong>output buffer(output queue),</strong> which stores packets that the router is about to send into that link. In addition to the <strong>store-and-forward delays</strong>, packets suffer output buffer <strong>queuing delays</strong>. When the output buffer is full, <strong>packet loss</strong> will occur.</p>
<h5 id="c.-forwarding-tables-and-routing-protocols">c. Forwarding Tables and Routing Protocols</h5>
<p>each router has a <strong>forwarding table</strong> （转发表）that maps destination addresses (or portions of the destination addresses) to that router’s outbound links.</p>
<h4 id="ii.-circuit-switching-电路交换">ii. Circuit Switching 电路交换</h4>
<blockquote>
<p>the resources needed along <strong>a path (buffers, link transmission rate) to provide for communication between the end systems are reserved</strong> for the duration of the communication session between the end systems</p>
<p><strong>end-to-end</strong> connection</p>
</blockquote>
<h5 id="multiplexing-in-circuit-switched-networks">Multiplexing in Circuit-Switched Networks</h5>
<ul>
<li>frequency-division multiplexing (FDM) 频分复用 ：</li>
</ul>
<p>The width of the range of frequency is called, not surprisingly, the <strong>bandwidth</strong>.</p>
<ul>
<li><p>time-division multiplexing (TDM) 时分复用:</p>
<p>circuit switching is <strong>wasteful</strong> because the dedicated circuits are idle during <strong>silent periods</strong>(静默期)</p></li>
</ul>
<h4 id="iii.-packet-switching-versus-circuit-switching">iii. Packet Switching Versus Circuit Switching</h4>
<h5 id="packet-switching">Packet Switching</h5>
<ul>
<li>it offers better sharing of transmission capacity</li>
<li>it is simpler, more efficient, and less costly to implement</li>
<li>great for bursty data</li>
<li>but excessive congestion possible</li>
</ul>
<h5 id="circuit-switching">Circuit Switching</h5>
<ul>
<li>good for real-time serives</li>
<li>silent periods would cause time waste</li>
</ul>
<h4 id="iv.-a-network-of-networks">IV. A Network of Networks</h4>
<ul>
<li>ISP: 互联网服务提供商</li>
<li>IXP： Internet Exchange Point 因特网交换点 保证同级ISP对等（peering）</li>
<li>content provider networks：内容提供商网络</li>
</ul>
<h3 id="delay-loss-and-throughput">3. *Delay, Loss, and Throughput</h3>
<blockquote>
<p>in Packet-Switched Networks</p>
</blockquote>
<h4 id="types-of-delay">Types Of Delay</h4>
<ul>
<li><strong>nodal processing delay</strong>（节点处理时延）:</li>
</ul>
<p>The time required to <strong>examine the packet’s header</strong> and <strong>determine where to direct the packet</strong> is part of the processing delay.</p>
<ul>
<li><p><strong>Queuing Delay</strong>（排队时延）：</p>
<p>At the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link.</p></li>
<li><p><strong>Transmission Delay</strong>（传输时延）：</p>
<p>Denote the length of the packet by L bits, and denote the transmission rate of the link from router A to router B by R bits/sec. The transmission delay is L/R</p></li>
<li><p><strong>Propagation Delay</strong>（传播时延）：</p>
<p>Once a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from the beginning of the link to router B is the propagation delay</p></li>
</ul>
<h4 id="queuing-delay-and-packet-loss">Queuing Delay and Packet Loss</h4>
<ul>
<li><strong>traffic intensity</strong>（流量强度）： let <em>a</em> denote the <strong>average rate at which packets</strong> arrive at the queue (<em>a</em> is in units of packets/sec)（包到达平均速度）Recall that R is the transmission rate（传输速度）; Also suppose, for simplicity, that all packets consist of L bits. Then the average rate at which bits arrive at the queue is <em>La</em> bits/sec（包到达路由平均速度） The ratio <em>La/R</em>, called the traffic intensity. 保证流量强度&lt;=1才能正常工作</li>
<li><strong>Packet Loss</strong>（丢包）：With no place to store such a packet, a router will drop that packet; that is, the packet will be lost.</li>
</ul>
<h4 id="end-to-end-delay">End-to-End Delay</h4>
<p>suppose there are <strong>N - 1</strong> routers between the source host and the destination host</p>
<p>$ d_{end-end} = N(d_{proc}+d_{trans}+d_{prop})$</p>
<h4 id="throughput-in-computer-networks">Throughput in Computer Networks</h4>
<ul>
<li><strong>instantaneous throughput</strong>:at any instant of time is the rate (in bits/sec) at which Host B is receiving the file</li>
<li><strong>average throughput</strong>: For all file</li>
<li>the <strong>throughput</strong> depends not only on the transmission rates of the links along the path, but also on the intervening traffic</li>
</ul>
<h3 id="protocol-layers-and-their-service-models">4. Protocol Layers and Their Service Models</h3>
<h4 id="layered-architecture">Layered Architecture</h4>
<blockquote>
<p>Protocol layering has conceptual and structural advantages</p>
<p>the protocols of the various layers are called the <strong>protocol stack</strong></p>
</blockquote>
<p>Five-layer Internet protocol stack:</p>
<ol type="1">
<li><p><strong>Application Layer</strong>: HTTP</p>
<p>The application layer is where <strong>network applications and their application-layer protocols</strong> reside. this packet of information at the application layer as a <strong>message</strong>（报文）.</p></li>
<li><p><strong>Transport Layer</strong>：TCP UDP</p>
<p>The Internet’s transport layer transports application-layer messages between application endpoints. Transport-layer packet as a <strong>segment</strong>(报文段).</p>
<p>TCP guaranteed delivery of application-layer messages to the destination and flow control (that is, sender/receiver speed matching) But UDP not.</p></li>
<li><p><strong>Network Layer</strong>：IP</p>
<p>The Internet’s network layer is responsible for moving network-layer packets known as <strong>datagrams</strong> (数据报)from one host to another.</p></li>
<li><p><strong>Link Layer</strong>:</p>
<p>To move a packet from one node (host or router) to the next node in the route, the network layer relies on the services of the link layer. The services provided by the link layer depend on the <strong>specific link-layer protocol</strong>(特定链路层协议) that is employed over the link. refer to the linklayer packets as <strong>frames.</strong>（帧）</p></li>
<li><p><strong>Physical Layer</strong>：</p>
<p>the job of the physical layer is to <strong>move the individual bits</strong> within the frame from one node to the next.</p></li>
</ol>
<p><strong>OSI Model</strong>：</p>
<blockquote>
<p>There are application layer, presentation layer, session layer, transport layer, network layer, data link layer, and physical layer from up to down.</p>
</blockquote>
<ul>
<li><strong>presentation layer</strong> is to provide services that allow communicating applications to interpret the meaning of data exchanged. These services include <strong>data compression</strong> and <strong>data encryption</strong> as well as <strong>data description</strong>.</li>
<li><strong>The session layer</strong> provides for <strong>delimiting and synchronization of data exchange</strong>(数据交换和定界), including the means to build a checkpointing and recovery scheme.</li>
</ul>
<h4 id="encapsulation">Encapsulation</h4>
<p>we see that at each layer, a packet has two types of fields: <strong>header fields</strong>（首部字段） and a <strong>payload field</strong>（有效载荷字段）. The payload is typically a packet from the layer above.</p>
<p>In every layer, the layer encapsulates the data from last layer as payload field, then add its own header information, to build whole information.</p>
<h2 id="chapter-2-application-layer">Chapter 2 Application Layer</h2>
<blockquote>
<p>2.2 2.5 2.6 are important</p>
<p>DNS protocol not important</p>
<p>2.3 2.4-</p>
</blockquote>
<h3 id="principles-of-network-applications">1. Principles of Network Applications</h3>
<h4 id="i.-network-application-architectures">i. Network Application Architectures</h4>
<blockquote>
<p>two predominant（主要的） architectural paradigms used in modern network applications: the client-server architecture or the peer-to-peer (P2P) architecture</p>
</blockquote>
<ul>
<li><p><strong>the client-server architecture：</strong></p>
<p>client and server are separate and fixed, and they perform they own functions</p></li>
<li><p><strong>P2P architecture:</strong></p>
<p>Because the peers（对等方） communicate without passing through a dedicated（专用的） server, the architecture is called peer-to-peer. These peers can be server also can be clientz.</p>
<p>P2P is <strong>self-scalability and cost effective</strong>. And have three <strong>challenges</strong>: ISP Friendly, Security, Incentives（激励）.</p></li>
</ul>
<h4 id="ii.-processes-communicating">ii. Processes Communicating</h4>
<blockquote>
<p>In truth, server and client are just two process</p>
</blockquote>
<p>A process sends messages into, and receives messages from, the network through a software interface called a socket（套接字）. It is also referred to as the Application Programming Interface (API) between the application and the network</p>
<p>We use <strong>IP address and port number</strong> to do addressing process.</p>
<h4 id="iii.-transport-services-available-to-applications">iii. Transport Services Available to Applications</h4>
<ul>
<li>Reliable Data Transfer</li>
<li>Throughput</li>
<li>Timing</li>
<li>Security</li>
</ul>
<h4 id="iv.-transport-services-provided-by-the-internet">IV. Transport Services Provided by the Internet</h4>
<ul>
<li><p>TCP Servies</p>
<p>Connection-oriented service and Reliable data transfer service</p></li>
<li><p>UDP</p>
<p>UDP is a no-frills, lightweight transport protocol, providing minimal services. UDP is <strong>connectionless, unreliable</strong>. UDP provides <strong>no guarantee</strong> that the message will ever reach the receiving process. Furthermore, messages that do arrive at the receiving process may arrive <strong>out of order</strong>. And no congestion-control mechanism（拥塞机制）.</p></li>
</ul>
<h4 id="v.-services-not-provided-by-internet-transport-protocols">V. Services Not Provided by Internet Transport Protocols</h4>
<p>But in our brief description of TCP and UDP, conspicuously（明显的） missing was any mention of throughput or timing guarantees—services not provided by today’s Internet transport protocols.</p>
<h3 id="the-web-and-http">*2. The Web and HTTP</h3>
<h4 id="i.-overview-of-http">i. Overview of HTTP</h4>
<p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web’s application-layer protocol, is at the heart of the Web. . Because an HTTP server maintains no information about the clients, HTTP is said to be a <strong>stateless protocol</strong>（无状态协议）. We also remark that the <strong>Web uses the client-server application architecture,</strong></p>
<h4 id="ii.-non-persistent-and-persistent-connections">ii. Non-Persistent and Persistent Connections</h4>
<blockquote>
<p>Attention: 对多并发的例子中，线程之间对其他线程的连接一般是不可见的</p>
<p>流水线式不一定是绝对好的，本质是提高链路的利用率（充分利用带宽时延积）</p>
<p>先获取HTML然后在获取其它对象</p>
<ol type="1">
<li>可能会因为头包过大造成链路阻塞</li>
<li>返回必须按照接收顺序，已处理好的必须等前一个发送后才可以发送</li>
</ol>
</blockquote>
<ul>
<li><strong>non-persistent connections</strong>: each request/response pair be sent over a separate TCP connection</li>
<li><strong>persistent connections</strong>: all of the requests and their corresponding responses be sent over the same TCP connection，注意持久化一般是流水线</li>
</ul>
<p><strong>round-trip time (RTT 往返时延)</strong>：the time it takes for a small packet to travel from client to server and then back to the client</p>
<p><strong>the total response time:(总响应时间)</strong> two RTTs plus the transmission time at the server of the HTML file.</p>
<p>Non-persistent connections have some <strong>shortcomings</strong>.</p>
<ul>
<li>a brand-new connection must be established and maintained for each requested object.</li>
<li>each object suffers a delivery delay of two RTTs</li>
</ul>
<h4 id="iii.-http-message-format">iii. HTTP Message Format</h4>
<ol type="1">
<li>HTTP Request Message</li>
</ol>
<ul>
<li>request line（请求行）: first line
<ul>
<li>method field: <strong>GET, POST</strong>, HEAD, PUT, and DELETE</li>
<li>URL field</li>
<li>HTTP Version field</li>
</ul></li>
<li>header line（首部行）: subsequent line
<ul>
<li>Host : specifies the host on which the object resides</li>
<li>Connection : whether use persistent connections</li>
<li>User-agent : specifies the user agent , that is, the browser type. This header line is useful because the server can actually send different versions of the same object to different types of user agents.</li>
<li>Accept-language: indicates that the user prefers language version</li>
<li>POST method: has an entity body for post data, but get also can do use work with saving data in URLs.</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>HTTP Request Message</li>
</ol>
<ul>
<li>status line : first line</li>
</ul>
<pre><code> version + status code + phrase

 - 200 OK :  succeeded 
 - 301 Moved Permanently : Requested object has been permanently moved and new URL will be returned
 - 400 Bad Request :   the request could not be understood by the server. 
 - 404 Not Found : The requested document does not exist on this server 
 -  505 HTTP Version Not Supported : ~~~</code></pre>
<ul>
<li><p>header line: subsequent line :</p>
<ul>
<li>Connection : tell the client that whether close the TCP connection after sending the message</li>
<li>Date : <strong>indicates the time and date when the HTTP response was created and sent by the server</strong>. Note that this is not the time when the object was created or last modified; it is the time when the server retrieves the object from its file system, inserts the object into the response message, and sends the response message.</li>
<li>Server : analogous to the User-agent</li>
<li>Last-Modified : the time and date when the object was created or last modified</li>
<li>Content-Length : data size</li>
<li>Content-Type : data type such as HTML</li>
</ul></li>
<li><p>entity body : save data</p></li>
</ul>
<h4 id="iv.-user-server-interaction-cookies">iv. User-Server Interaction: Cookies</h4>
<blockquote>
<p>cookies allow sites to keep track of users</p>
</blockquote>
<p>Cookie has four components:</p>
<ol type="1">
<li>a cookie header line in the HTTP <strong>response</strong> message</li>
<li>a cookie header line in the HTTP <strong>request</strong> message</li>
<li>a cookie file kept on the user’s end system and managed by the user’s <strong>browser</strong></li>
<li>a back-end database at <strong>the Web site</strong></li>
</ol>
<p>Although cookies often simplify the Internet shopping experience for the user, they are controversial because they can also be considered as an invasion of privacy</p>
<h4 id="v.-web-caching">V. Web Caching</h4>
<blockquote>
<p>A Web cache—also called a proxy server（代理服务器）—is a network entity that satisfies HTTP requests on the behalf of an origin Web server</p>
</blockquote>
<p>It works like this:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/web_cache_1.png" /></p>
<p>Note that a cache is <strong><em>both a server and a client</em></strong> at the same time.</p>
<p>Advantages:</p>
<ul>
<li><strong><em>A Web cache can substantially reduce the response time for a client request</em></strong>, particularly if the bottleneck bandwidth between the client and the origin server is much less than the bottleneck bandwidth between the client and the cache （加速）</li>
<li>Web caches can substantially reduce traffic on an institution’s access link to the Internet. So they does not have to upgrade bandwidth as quickly, thereby reducing costs. （减少通信量降低带宽不耗钱）</li>
<li>Web caches can substantially reduce Web traffic in the Internet as a whole, thereby improving performance for all applications. （降低网络流量，提高性能）</li>
</ul>
<p><strong>Content Distribution Networks (CDNs)</strong> （内容分发网络）: A CDN company installs many geographically distributed caches throughout the Internet, thereby localizing much of the traffic.</p>
<h4 id="vi.-the-conditional-get">VI. The Conditional GET</h4>
<blockquote>
<ul>
<li>the request message uses the GET method</li>
<li>the request message includes an <strong>If-ModifiedSince</strong>: header line</li>
</ul>
</blockquote>
<p>Use the conditional get to guarantee the file in proxy server is up to date.</p>
<h3 id="dnsthe-internets-directory-service">5. DNS—The Internet’s Directory Service</h3>
<blockquote>
<p>domain name system: a directory service that translates hostnames to IP addresses 53端口</p>
</blockquote>
<p>Definition:</p>
<ol type="1">
<li>a distributed database implemented in a hierarchy of DNS servers</li>
<li>an application-layer protocol that allows hosts to query the distributed database</li>
</ol>
<h4 id="i.-services-provided-by-dns">i. Services Provided by DNS</h4>
<ul>
<li>Host aliasing</li>
<li>Mail server aliasing</li>
<li>Load distribution（负载分配）（一个域名对应多个服务器IP）</li>
</ul>
<h4 id="ii.-overview-of-how-dns-works">ii. Overview of How DNS Works</h4>
<ul>
<li>centralized design: A simple design for DNS would have one DNS server that contains all the mappings
<ul>
<li>A single point of failure</li>
<li>Traffic volume</li>
<li>Distant centralized database</li>
<li>Maintenance</li>
</ul></li>
<li>distributed hierarchical design: uses a large number of servers, organized in a hierarchical fashion and distributed around the world
<ul>
<li>root DNS servers : In the Internet there are 13 root DNS servers</li>
<li>top-level domain (TLD) servers</li>
<li>authoritative DNS servers（权威域名服务器）: Every organization with publicly accessible hosts (such as Web servers and mail servers) on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses</li>
<li>local DNS server : A local DNS server does not strictly belong to the hierarchy of servers but is nevertheless central to the DNS architecture; When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy.
<ul>
<li>recursive：如果全部采用这种方式会给更服务器极大的压力</li>
<li>iterative</li>
</ul></li>
</ul></li>
</ul>
<h4 id="iv.-dns-records-and-messages">iv. DNS Records and Messages</h4>
<p>resource records (RRs): provide hostname-to-IP address mappings</p>
<p><strong>format : (Name, Value, Type, TTL)</strong></p>
<ul>
<li>Type = A : Name is a hostname and Value is the IP address for the hostname.</li>
<li>Type = NS : Name is a domain (such as foo.com) and Value is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain</li>
<li>Type = CNAME : Value is a canonical hostname for the alias hostname Name</li>
<li>Type = MX : Value is the canonical name of a mail server that has an alias hostname Name</li>
</ul>
<h3 id="电子邮件">电子邮件</h3>
<p>3个组成部分：用户代理，邮件服务器，SMTP</p>
<h4 id="smtp保存状态">SMTP(保存状态)</h4>
<p>25 号端口，简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。</p>
<h4 id="pop3">POP3</h4>
<p>Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议</p>
<h4 id="imap保存状态">IMAP（保存状态）</h4>
<p>Internet Mail Access Protocol，即交互式邮件存取协议</p>
<p>开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上</p>
<h3 id="ftp保存状态">FTP（保存状态）</h3>
<p>两个TCP连接，一个控制连接，一个控制数据连接（20，21端口）</p>
<h2 id="chapter-3-transport-layer">Chapter 3 Transport Layer</h2>
<blockquote>
<p>A transport-layer protocol provides for <strong>logical communication</strong> between application <strong><em>processes</em></strong> running on different hosts.</p>
<p>3.6 不做要求</p>
</blockquote>
<p>###　3.1 Introduction and Transport-Layer Services</p>
<h4 id="relationship-between-transport-and-network-layers">Relationship Between Transport and Network Layers</h4>
<p>transport layer lies just above the network layer in the protocol stack. Whereas a transport-layer protocol provides logical communication between <strong><em>processes</em></strong> running on different hosts, a network-layer protocol provides logical communication between <em>hosts</em>.</p>
<h4 id="overview-of-the-transport-layer-in-the-internet">Overview of the Transport Layer in the Internet</h4>
<ul>
<li><p>IP service model —— <strong>best-effort delivery service</strong></p>
<p>IP makes its “best effort” to deliver segments between communicating hosts, but it makes no guarantees. So IP is unreliable service.</p></li>
<li><p>multiplexing &amp; demultiplexing</p>
<p>Extending <strong>host-to-host</strong> delivery to <strong>process-to-process</strong> delivery</p></li>
<li><p>TCP</p>
<p><strong>reliable data transfer and provides congestion control</strong>. TCP congestion control prevents any one TCP connection from swamping the links and routers between communicating hosts with an excessive amount of traffic.</p></li>
</ul>
<h3 id="multiplexing-and-demultiplexing">3.2 Multiplexing and Demultiplexing</h3>
<p>a process can have one or more <strong><em>sockets</em></strong>, doors through which data passes from <strong>the network to the process</strong> and through which data passes from the process to the network.</p>
<ul>
<li><p>demultiplexing: delivering the data in a transport-layer segment to the correct socket</p></li>
<li><p>multiplexing:</p>
<p>gathering data chunks at the source host from <strong>different sockets</strong>, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer</p></li>
</ul>
<p>Socket:</p>
<ol type="1">
<li>unique identifiers to identify UDP, TCP sockets</li>
<li>the <strong>source port number field</strong> and the <strong>destination port number field</strong></li>
</ol>
<p>the port number ranges from 0 to 65535 (16 bits to express), [0, 1024) is well-known port numbers</p>
<h4 id="connectionless-multiplexing-and-demultiplexing">Connectionless Multiplexing and Demultiplexing</h4>
<p>可能是因为UDP是无连接，而TCP是有连接的协议的区分</p>
<p>UDP socket is fully identified by a <strong>two-tuple</strong> consisting of a <strong>destination IP address and a destination port number</strong>.</p>
<h4 id="connection-oriented-multiplexing-and-demultiplexing">Connection-Oriented Multiplexing and Demultiplexing</h4>
<p>identified by four values:</p>
<ol type="1">
<li>the source port number in the segment</li>
<li>the IP address of the source host</li>
<li>the destination port number in the segment</li>
<li>its own IP address</li>
</ol>
<p>当一个UDP服务器接收到一个UDP报文段时，它会根据收到的UDP报文段的源IP和源端口号，把数据发送回客户端，它并不需要创建一个新的套接字来处理该报文段；</p>
<p>而对于一个TCP服务器，当它接受一个连接时，它会产生一个新的套接字，然后通过新的套接字来与客户端通信，也就是通过新的套接字来把数据发送回给客户端。由于每一个连接都会产生一个新的套接字，所以具有不同的源IP或源端口号的连接就是一个不同的连接，对应着产生的新的不同的套接字 原文链接：https://blog.csdn.net/ljianhui/article/details/21660629</p>
<h3 id="connectionless-transport-udp">3.3 Connectionless Transport: UDP</h3>
<ul>
<li><p><em>No connection state.</em> TCP maintains connection state in the end systems.</p></li>
<li><em>Small packet header overhead.</em> The TCP segment has 20 bytes of header over head in every segment, whereas UDP has only 8 bytes of overhead.</li>
<li><p>we mention that it is possible for an application to have reliable data transfer when using UDP. This can be done if reliability is built into the application itself</p></li>
</ul>
<h4 id="udp-segment-structure">UDP Segment Structure</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_7.png" style="zoom:50%;" /></p>
<h4 id="udp-checksum">UDP Checksum</h4>
<p>UDP at the sender side performs the 1s complement of the sum of all the 16-bit words in the segment, with any overflow encountered during the sum being wrapped around(<strong>add the overflow bits with the sum</strong>)</p>
<h3 id="principles-of-reliable-data-transfer">3.4 Principles of Reliable Data Transfer</h3>
<h4 id="building-a-reliable-data-transfer-protocol">Building a Reliable Data Transfer Protocol</h4>
<ol type="1">
<li><p><strong>rdt1.0</strong></p>
<p>the underlying channel is completely reliable</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_9.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt2.0</strong>: Reliable Data Transfer over a Channel with Bit Errors</p></li>
</ol>
<p>an ARQ (Automatic Repeat reQuest) protocols</p>
<p>include RDT2.0-3, gbn, sr, tcp</p>
<ul>
<li><p>checksum</p></li>
<li><p>feedback (ACK,NAK)</p></li>
<li><p>resend</p></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_10.png" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li><p><strong>rdt2.1</strong>: can detect ACK or NAK errors based on 2.0</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_11.png" style="zoom:50%;" /> <img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_12.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt2.2</strong>: implement without NAK based on 2.1</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_13.png" style="zoom:50%;" /> <img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_14.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt3.0</strong>: Reliable Data Transfer over a Lossy Channel with Bit Errors</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_15.png" style="zoom:50%;" /></p></li>
</ol>
<h4 id="pipelined-reliable-data-transfer-protocols">Pipelined Reliable Data Transfer Protocols</h4>
<ol type="1">
<li><p>Stop&amp;Wait: rdt</p></li>
<li><p>PipeLine: gbn, sr, tcp in order.</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_19.png" style="zoom:50%;" /></p>
<p>Example:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_22.png" style="zoom:50%;" /></p>
<p>The window size will move as long as getting the ACK.</p>
<p><strong>only a single timer</strong>, which can be thought of as a timer for the oldest transmitted but not yet acknowledged packet. If an ACK is received but there are still additional transmitted but not yet acknowledged packets, the timer is restarted. If there are no outstanding, unacknowledged packets, the timer is stopped.</p>
<ul>
<li><p><strong>Selective Repeat (SR)</strong></p>
<p>sequence-number space format:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_23.png" style="zoom:50%;" /></p>
<p>Actions in sender:</p>
<ol type="1">
<li>Data received from above</li>
<li>Timeout: <strong>each packet must now have its own logical timer</strong>, since only a single packet will be transmitted on timeout</li>
<li>ACK received: <strong>the windows will move right to the unacknowledged packet with the smallest sequence number</strong> when received the most left ACK</li>
</ol>
<p>The SR receiver will acknowledge a correctly received packet whether or not it is in order. Out-of-order packets are buffered until any missing packets (that is, packets with lower sequence numbers) are received, at which point a batch of packets can be delivered in order to the upper layer.</p>
<p>Actions in receiver:</p>
<ol type="1">
<li>Packet with sequence number in [rcv_base, rcv_base+N-1] is correctly received. In this case, the received packet falls within the receiver’s window and a selective ACK packet is returned to the sender. If the packet was not previously received, it is buffered. If this packet has a sequence number <strong>equal to the base of the receive window (rcv_base in Figure 3.22), then this packet, and any previously buffered and consecutively numbered (beginning with rcv_base)</strong> packets are delivered to the upper layer. The receive window is then moved forward by the number of packets delivered to the upper layer.</li>
<li>Packet with sequence number in [rcv_base-N, rcv_base-1] is correctly received. return an ACK</li>
</ol>
<p><strong>SR’s problem</strong>: can’t know <strong><em>a new packet or a retransmission?</em></strong></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_27.png" style="zoom:70%;" /></p>
<p>The solution of this problem: <strong><em>the window size must be less than or equal to half the</em></strong> <strong><em>size of the sequence number space for SR protocols.</em></strong></p></li>
</ul>
<p><strong>Summary:</strong></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/T3_1.png" style="zoom:70%;" /></p>
<h3 id="connection-oriented-transport-tcp">3.5 Connection-Oriented Transport: TCP</h3>
<p>GBN-SR 窗口不变, TCP 窗口可以变</p>
<h4 id="the-tcp-connection">The TCP Connection</h4>
<ul>
<li>connection-oriented</li>
<li>full-duplex service（全双工）</li>
<li>point-to-point</li>
<li>three-way handshake</li>
<li><strong>maximum segment size (MSS):</strong> The maximum amount of data that can be grabbed and placed in a segment</li>
<li><strong>maximum transmission unit (MTU):</strong> the length of the largest link-layer frame that can be sent by the local sending host</li>
</ul>
<h4 id="tcp-segment-structure">TCP Segment Structure</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_29.png" style="zoom:50%;" /></p>
<ul>
<li><strong>Sequence Numbers(SEQ)</strong>: the byte-stream number of the first byte in the segment</li>
<li><strong>Acknowledgment Numbers(ACK)</strong>: Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B（想要的下一个序号）TCP is said to provide <strong>cumulative acknowledgments</strong></li>
</ul>
<p>Example：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_31.png" style="zoom:50%;" /></p>
<h4 id="round-trip-time-estimation-and-timeout">Round-Trip Time Estimation and Timeout</h4>
<p>The sample RTT, denoted SampleRTT, for a segment is the amount of time between when the segment is sent (that is, passed to IP) and when an acknowledgment for the segment is received.</p>
<p>TCP never computes a SampleRTT for a segment that has been retransmitted; it only measures SampleRTT for segments that have been transmitted once.</p>
<ul>
<li>use <strong>exponential weighted moving average (EWMA)</strong> to estimate RTT</li>
</ul>
<p><span class="math inline">\(EstimatedRTT = (1 – \alpha) • EstimatedRTT + \alpha • SampleRTT\)</span></p>
<ul>
<li>In addition to having an estimate of the RTT, it is also valuable to have a measure of the variability of the RTT.</li>
</ul>
<p>$ DevRTT = (1 – ) • DevRTT + •┃ SampleRTT – EstimatedRTT ┃$</p>
<ul>
<li>use this formula the get RTT time</li>
</ul>
<p>$ TimeoutInterval = EstimatedRTT + 4 • DevRTT$</p>
<h4 id="reliable-data-transfer">Reliable Data Transfer</h4>
<ul>
<li><strong>Doubling the Timeout Interval</strong></li>
<li><strong>Fast Retransmit</strong>:In the case that three duplicate ACKs are received (except the first ACK)</li>
</ul>
<h4 id="flow-control">Flow Control</h4>
<p>TCP流控是因为应用层处理速度太慢了, 发送者和接收者的协调,拥塞是路由器和发送者</p>
<p>eliminate the possibility of the sender overflowing the receiver’s buffer. Flow control is thus a speed-matching service—matching the rate at which the sender is sending against the rate at which the receiving application is reading</p>
<p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制</p>
<p>A通过TCP连接向B发送一个大文件</p>
<ul>
<li>LastByteRead: 主机B上的应用程序进程从缓存独出的数据流的最后一个字节的编号</li>
<li>LastByteRevd: 网络到达已放入接收缓存的最后一个字节编号</li>
</ul>
<p>保持下式成立</p>
<p>$ LastByteRcvd-LastByteRead RevBuffer $</p>
<p>接收窗口用rwnd表示，可得 <span class="math inline">\(rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]\)</span></p>
<p>在发送方有 <span class="math inline">\(LastByteSent-LastByteAcked \le rwnd\)</span></p>
<p><strong>当主机B接收窗口为空时，主机A继续发送只有一个字节数据的报文段，避免A被阻塞的情况</strong></p>
<h4 id="tcp-connection-management">TCP Connection Management</h4>
<p>MSS在传输SYN时传输确定, TCP可以将包合并发就合并发, SYN 包要独占一个序列号 SYN：1.同步网络参数 2.同步序列号 FIN：表示不发了，但可以接收</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_39.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_40.png" style="zoom:50%;" /></p>
<h3 id="tcp-congestion-control">3.7 TCP Congestion Control</h3>
<p><strong>each side of a TCP connection</strong> consists of a <strong>receive buffer, a send buffer, and several variables</strong> (LastByteRead, rwnd, and so on). The TCP congestion-control mechanism operating at the sender keeps track of an additional variable, the congestion window. <strong>The congestion window</strong>, denoted cwnd, imposes a constraint on the rate at which a TCP sender can send traffic into the network.</p>
<p>TCP uses acknowledgments to trigger (or clock) its increase in congestion window size, TCP is said to be <strong>self-clocking</strong>.</p>
<p><strong>书本中的TCP标准遵循单一重传定时器的推荐</strong></p>
<p><strong>FSM</strong>：</p>
<p>对快速重传的快速恢复的cwnd有减半加三（考虑重传时没有拥塞）和不加三两种操作，这里采用不加三</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_52.png" style="zoom:70%;" /></p>
<p><strong>TCP congestion-control algorithm</strong>:</p>
<ol type="1">
<li><p>Slow Start</p>
<p><strong>begin with 1 MSS</strong> then <strong>doubling</strong> of the last sending rate every RTT until meets ssthresh or a loss, then enter congestion avoidance</p></li>
<li><p>congestion avoidance</p>
<p><strong>linear increase</strong> (of 1 MSS per RTT) until meet a loss, then <strong>set the ssthresh to half</strong> and enter fast recovery</p></li>
<li><p>fast recovery</p>
<p>两个版本在超时后都置为1, 丢包（快速重传）处理不一样</p>
<ul>
<li>Tahoe: set cwnd to 1 MSS</li>
<li>Reno: set the rate to the half of the last rate (real fast recovery)</li>
</ul></li>
</ol>
<p>Example:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_53.png" /></p>
<p>TCP is <strong>fair</strong></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_56.png" style="zoom:50%;" /></p>
<p>these two connection will infinitely approach <em>the equal bandwidth share line</em>.</p>
<h2 id="chapter-4-the-network-layer">Chapter 4 The Network Layer</h2>
<h3 id="introduction">4.1 Introduction</h3>
<ul>
<li><strong>Forwarding（转发）</strong>: When a packet arrives at a router’s input link, the router must move the packet to the appropriate output link</li>
<li><strong>Routing</strong>: The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as routing algorithms</li>
</ul>
<p>Every router has a <strong>forwarding table</strong>.</p>
<p>ATM services models:</p>
<ul>
<li>CBR: <strong>Constant bit rate (CBR) ATM network service.</strong></li>
<li>ABR: <strong>Available bit rate (ABR) ATM network service</strong></li>
</ul>
<h3 id="virtual-circuit-and-datagram-networks">4.2 Virtual Circuit and Datagram Networks</h3>
<h4 id="virtual-circuit-networks">Virtual-Circuit Networks</h4>
<p>consists of:</p>
<ul>
<li>a <strong>path</strong> (that is, a series of links and routers) between the source and destination hosts</li>
<li><strong>VC numbers</strong>, one number for each link along the path</li>
<li>entries in the <strong>forwarding table</strong> in each router along the path</li>
</ul>
<p>Whenever a new VC is established across a router, an entry is added to the forwarding table. Similarly, whenever a VC terminates, the appropriate entries in each table along its path are removed.</p>
<p><strong>three identifiable phases in a virtual circuit</strong>:</p>
<ol type="1">
<li>VC setup</li>
<li>Data transfer</li>
<li>VC teardown</li>
</ol>
<h4 id="datagram-networks">Datagram Networks</h4>
<p>the router uses <strong><em>the longest prefix matching rule</em></strong> in datagram networks.</p>
<p>Because forwarding tables in datagram networks <strong>can be modified at any time</strong>, a series of packets sent from one end system to another may follow different paths through the network and may arrive <strong>out of order</strong>.</p>
<h3 id="whats-inside-a-router">4.3 What’s Inside a Router?</h3>
<h4 id="architecture">Architecture</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_6.png" style="zoom:50%;" /></p>
<h4 id="switching">Switching</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_8.png" style="zoom:50%;" /></p>
<h4 id="where-does-queueing-occur">Where Does Queueing Occur?</h4>
<p>the router’s memory can eventually be exhausted and packet loss will occur when no memory is available to store arriving packets.</p>
<p><strong>packet scheduler（分组调度）</strong>:</p>
<p><strong>active queue management（AQM 主动队列管理）</strong></p>
<ul>
<li>drop-tail（弃尾）</li>
<li>Random Early Detection (RED随机早期检测)</li>
</ul>
<p><strong>head-of-the-line (HOL) blocking（线路前部阻塞）</strong>: 前一个分组和其他的输入端口竞争，阻塞了后面没有冲突的分组的发送</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_11.png" style="zoom:50%;" /></p>
<h4 id="the-routing-control-plane">The Routing Control Plane</h4>
<p>software pass....</p>
<h3 id="ip">4.4 IP</h3>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_12.png" style="zoom:60%;" /></p>
<h4 id="datagram-format">Datagram Format</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_13.png" style="zoom:50%;" /></p>
<p>此处校验和计算方法和UDP处出现的校验和计算方法一致</p>
<p><strong>IP Datagram Fragmentation</strong></p>
<p>datagram: 4000 bytes</p>
<p>MTU: 1500 bytes</p>
<p>IP header: 20 bytes</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/T4_2.png" style="zoom:50%;" /></p>
<h4 id="ipv4-addressing">IPv4 Addressing</h4>
<p>The boundary between the host and the physical link is called an <strong>interface</strong>.</p>
<p>To determine the subnets, detach each interface from its host or router, creating islands of isolated networks, with interfaces terminating the end points of the isolated networks. Each of these isolated networks is called a subnet. 没有穿越路由器属于一个子网</p>
<p>子网可用IP地址需要减2，一个是主机位全0的子网地址和主机位全1的子网广播地址</p>
<p>子网本身IP地址：前缀+全零</p>
<p>子网本身IP地址：前缀+全1(直接广播地址)（对目标子网广播）</p>
<p>255.255.255.255 子网广播地址（受限广播地址）（广播本子网）</p>
<p>0.0.0.0 网卡本身地址</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_17.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>Classless Interdomain Routing (CIDR 无类别区域间路由选择)</strong></p>
<p>a.b.c.d/x ; use prefix can reduce the size of the forwarding table</p></li>
<li><p><strong>classful addressing 分类编址</strong></p>
<p>A：8 bits ；B：16 bits；C：24bits</p></li>
</ul>
<h4 id="dhcp-the-dynamic-host-configuration-protocol">DHCP: the Dynamic Host Configuration Protocol</h4>
<p>a <strong>plug-and-play protocol</strong>(即插即用协议)</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_21.png" style="zoom:50%;" /></p>
<p>因为可能存在多个DHCP服务器所以需要二次确认，客户端选择一个IP并告知（一般都是第一个）</p>
<h4 id="network-address-translation-nat">Network Address Translation (NAT)</h4>
<p>use a <strong>NAT translation table</strong> at the NAT router, and to include port numbers as well as IP addresses in the table entries</p>
<p>NAT interferes with P2P applications.</p>
<p>可以采用第三方来通信 （Skype）</p>
<p><strong>NAT traversal</strong>（NAT穿越）克服两台主机同属于不同NAT之后的通信，使用UPnP(Universal Plug and Play)协议</p>
<h4 id="internet-control-message-protocol-icmp">Internet Control Message Protocol (ICMP)</h4>
<p>The most typical use of ICMP is for error reporting</p>
<p>使用IP协议的网络层协议</p>
<h4 id="ipv6">IPv6</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_24.png" style="zoom:50%;" /></p>
<ul>
<li>Next hdr:交付到哪一个协议（TCP/UDP）和v4的协议字段相同</li>
<li>IPv6不允许在路由器上分片和组装</li>
<li>IPv6没有选项字段，使得其为定长40字节</li>
<li>首部校验和消失，完全交付给上层协议处理</li>
<li>payload length: 数据长度</li>
</ul>
<p><strong>Transitioning from IPv4 to IPv6</strong></p>
<ul>
<li><p><strong>dual-stack</strong>：使用既可以处理v4也可以处理v6的路由器，但可能丢失流标签（或者其他v6特有标签）</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_25.png" style="zoom:50%;" /></p></li>
<li><p><strong>tunneling</strong>（建隧道）：将v6整体作为v4的数据段传递</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_26.png" style="zoom:50%;" /></p></li>
</ul>
<h3 id="routing-algorithms">4.5 Routing Algorithms</h3>
<p>classification</p>
<ol type="1">
<li><strong>global routing algorithm(LS)</strong> &amp; <strong>decentralized routing algorithm(DV)</strong></li>
<li><strong>static routing algorithms</strong> &amp; <strong>Dynamic routing algorithms</strong></li>
<li><strong>load-sensitive algorithm</strong> &amp; <strong>load-insensitive(RIP, OSPF, BGP)</strong></li>
</ol>
<h4 id="link-state-algorithm-ls">Link-State Algorithm (LS)</h4>
<ul>
<li>D(v): cost of the least-cost path from the source node to destination v as of this iteration of the algorithm.</li>
<li>p(v): previous node (neighbor of v) along the current least-cost path from the source to v.</li>
<li>N' : subset of nodes; v is in N’ if the least-cost path from the source to v is definitively known.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/LS.png" style="zoom:50%;" /></p>
<p>Example:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/T4_3.png" style="zoom:50%;" /></p>
<p>Then we can get the forward table of u:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_28.png" style="zoom:50%;" /></p>
<p>oscillations occur in any algorithm, not just an LS algorithm, that uses a congestion or delay-based link metric</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_29.png" style="zoom:60%;" /></p>
<p>One way to avoid such self synchronization is for each router to randomize the time it sends out a link advertisement.</p>
<h4 id="the-distance-vector-dv-routing-algorithm">The Distance-Vector (DV) Routing Algorithm</h4>
<ul>
<li>For each neighbor v, the cost <strong><em>c(x,v)</em></strong> from x to directly attached neighbor,</li>
<li>Node x’s distance vector, that is, <strong>Dx</strong> = [Dx (y): y in N], containing x’s estimate of its cost to all destinations, y, in N</li>
<li>The distance vectors of each of its neighbors, that is, <strong>Dv</strong> = [Dv (y): y in N] for each neighbor v of x</li>
</ul>
<p>use this formula to update forwarding table:</p>
<p>$D_x(y)=min_v{c(x,v)+D_v(y) } $</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/DV.png" style="zoom:50%;" /></p>
<p>Examlpe:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_30.png" style="zoom:65%;" /></p>
<h4 id="distance-vector-algorithm-adding-poisoned-reverse">Distance-Vector Algorithm: Adding Poisoned Reverse</h4>
<p>好消息: 链路开销减小, 迭代次数少便收敛</p>
<p>坏消息 链路开销增加, 可能陷入无穷迭代（原因在于消息的虚假，增加的这条链路被其他节点引用但无法更新）</p>
<p>https://blog.csdn.net/tianlongtc/article/details/80261581</p>
<p>毒性逆转：The idea is simple—if z routes through y to get to destination x, then z will advertise to y that its distance to x is infinity</p>
<h4 id="a-comparison-of-ls-and-dv-routing-algorithms">A Comparison of LS and DV Routing Algorithms</h4>
<ul>
<li>Message complexity：</li>
<li>Speed of convergence（收敛速度）：DV收敛慢，可能遇到环路和无穷计数，LS较快</li>
<li>Robustness（健壮性）：LS更健壮，路由器故障时，DV会无穷欺骗</li>
</ul>
<h4 id="hierarchical-routing">Hierarchical Routing</h4>
<ul>
<li><p><strong>autonomous systems (ASs)</strong>: consisting of a group of routers that are typically under the same administrative control</p></li>
<li><p><strong>intra autonomous system routing protocol</strong>: The routing algorithm running within an autonomous system</p></li>
<li><strong>gateway routers</strong>: forwarding packets to destinations outside the AS</li>
<li><strong>inter-AS routing protocol</strong>: obtaining reachability information from neighboring ASs and propagating the reachability information to all routers internal to the AS</li>
<li><p><strong>hot-potato routing</strong>: 如果有两个网关都可以通向到另外一个AS那么简单的选择最近的那一个就可以</p></li>
</ul>
<h3 id="routing-in-the-internet">4.6 Routing in the Internet</h3>
<p><strong>intra autonomous system routing protocol</strong> also named <strong>interior gateway protocols</strong></p>
<ol type="1">
<li>Routing Information Protocol (RIP) DV(下层ISP或企业)</li>
<li>Open Shortest Path First (OSPF) LS (上层ISP)</li>
</ol>
<h4 id="intra-as-routing-in-the-internet-rip">Intra-AS Routing in the Internet: RIP</h4>
<p><strong>hop</strong>: the number of subnets traversed along the shortest path from source router to destination subnet, including the destination subnet</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_34.png" style="zoom:50%;" /></p>
<p>The maximum cost of a path is limited to 15 in RIP.</p>
<p>In RIP, routing updates are exchanged between neighbors approximately every 30 seconds using a <strong>RIP response message</strong>(RIP advertisements)</p>
<p>Example:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_35.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_36.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_37.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_38.png" style="zoom:50%;" /></p>
<h4 id="intra-as-routing-in-the-internet-ospf">Intra-AS Routing in the Internet: OSPF</h4>
<p>OSPF broadcasts routing information to <strong>all</strong> other routers in the autonomous system</p>
<p>Some of the advances embodied in OSPF：</p>
<ol type="1">
<li><em>Security</em></li>
<li><em>Multiple same-cost paths</em>（允许使用多条路径发送）</li>
<li><em>Integrated support for unicast and multicast routing</em></li>
<li><em>Support for hierarchy within a single routing domain</em></li>
</ol>
<p>OSPF可以配置为多个区域，每个区域都有区域边界路由器（<strong>area border routers</strong>）负责向流域以外的分组提供路由选择。AS内只有一个主干区域（backbone），主干的主要作用是为AS内其他区域之间的流量提供路由选择，包括了所有区域边界路由器和一些非边界路由器。在AS内区域间的路由选择要求分组首先路由到一个区域边界路由去，然后听过主干路由到位于母的区域的边界路由器</p>
<h4 id="inter-as-routing-bgpborder-gateway-protocol">Inter-AS Routing: BGP（Border Gateway Protocol）</h4>
<p>*<strong>BGP转发的对象是前缀（子网）</strong></p>
<p>BGP provides each AS a means to</p>
<ol type="1">
<li>Obtain subnet reachability information from neighboring ASs.</li>
<li>Propagate the reachability information to all routers internal to the AS</li>
<li>Determine “good” routes to subnets based on the reachability information and on AS policy</li>
</ol>
<p>Most importantly, BGP allows each subnet to advertise its existence to the rest of the Internet.</p>
<ul>
<li><strong>BGP peers</strong>：TCP连接的两个端点</li>
<li><strong>BGP session</strong>：发送BGP报文的TCP连接</li>
<li><strong>external BGP</strong> (<strong>eBGP</strong>) <strong>session</strong>：跨越AS</li>
<li><strong>internal BGP</strong> (<strong>iBGP</strong>) <strong>session</strong>：内部</li>
</ul>
<p>每一个AS都有一个ASN（autonomous system number），但是桩（stub）AS没有，这种AS只承担目的地址为本AS的流量。AS号是ICANN 分配的</p>
<p>When a router advertises a prefix across a BGP session, it includes with the prefix a number of BGP attributes. In BGP jargon, a prefix along with its attributes is called a route</p>
<ul>
<li><em>AS-PATH</em>:包含了前缀的通告已经听过的那些AS</li>
<li>Providing the critical link between the inter-AS and intra-AS routing protocols, the NEXT-HOP attribute has a subtle but important use. <strong>The NEXT-HOP is the router interface that begins the AS-PATH.</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/BGP_routing.png" style="zoom:50%;" /></p>
<h2 id="chapter-5-the-link-layer-links-access-networks-and-lans">Chapter 5 The Link Layer: Links, Access Networks, and LANs</h2>
<h3 id="introduction-to-the-link-layer">5.1 Introduction to the Link Layer</h3>
<ul>
<li><strong>node</strong>: any device that runs a link-layer protocol</li>
<li><strong>links:</strong>the communication channels that connect adjacent nodes along the communication path</li>
<li><strong>link-layer frame</strong>: link-layer data transmission format</li>
</ul>
<p>####　The Services Provided by the Link Layer</p>
<ol type="1">
<li><em>Framing</em>(成帧)</li>
<li><em>Link access</em>(链路接入)</li>
<li><em>Reliable delivery.</em></li>
<li><em>Error detection and correction</em></li>
</ol>
<h4 id="where-is-the-link-layer-implemented">Where Is the Link Layer Implemented?</h4>
<p><strong>network adapter</strong> also named <strong>network interface card (NIC)</strong></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_2.png" style="zoom:50%;" /></p>
<h3 id="error-detection-and--correction-techniques">5.2 Error-Detection and -Correction Techniques</h3>
<p>use <strong>error-detection and -correction bits(EDC)</strong> to detect and correct error bits</p>
<p>Even with the use of error-detection bits there still may be <strong>undetected bit errors</strong></p>
<h4 id="parity-checks">Parity Checks</h4>
<p>奇偶校验只需要查看加上检验比特(奇偶校验位)的1 是奇数还是偶数</p>
<p>二维奇偶校验:</p>
<p>对每一行每一列都进行奇偶校验,然后对列行奇偶校验位进行奇偶校验, 就校验可以检测和纠正单个比特错误,可以检测但是不能纠正两个比特的任意错误组合</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_5.png" style="zoom:50%;" /></p>
<p>The ability of the receiver to both detect and correct errors is known as <strong>forward error correction (FEC前向纠错)</strong>.</p>
<h4 id="checksumming-methods">Checksumming Methods</h4>
<p>和UDP/TCP中的类似</p>
<h4 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h4>
<p>also named <strong>polynomial codes</strong>(多项式编码)</p>
<ol type="1">
<li><p>确定多项式 例如 x3+x2+1 = 1101</p></li>
<li><p>在目标码后加上多项式码长度-1 的0</p></li>
<li><p>做模2除法(除的过程不是减是异或)</p></li>
</ol>
<p>把最后的余数添加到原码的末尾,在接收端使用相同多项式除看余数是否是0</p>
<h3 id="multiple-access-links-and-protocols">5.3 Multiple Access Links and Protocols</h3>
<ul>
<li><strong>point-to-point link</strong>: consists of a single sender at one end of the link and a single receiver at the other end of the link</li>
<li><strong>broadcast link</strong>: enables a single source node to send a copy of a packet to a subset of the other network nodes</li>
</ul>
<ol type="1">
<li>channel partitioning protocols 信道划分协议</li>
<li>random access protocols 随机访问协议</li>
<li>taking-turns protocols 轮流协议</li>
</ol>
<p>a multiple access protocol for a broadcast channel of rate R bits per second should have the following desirable characteristics:</p>
<ol type="1">
<li><p>当仅有一个节点发送数据时,具有R bps的吞吐量</p></li>
<li><p>当M给节点发送时,每个结点吞吐量为 R/M bps的平均传输速率</p></li>
<li><p>协议是分散的,不会因为某个主节点故障而使整个系统崩溃</p>
<p>no special node to coordinate transmissions</p>
<p>no synchronization of clocks, slots</p></li>
<li><p>协议是简单的,使实现不昂贵</p></li>
</ol>
<h4 id="channel-partitioning-protocols">Channel Partitioning Protocols</h4>
<ul>
<li><p>time-division multiplexing (TDM): divides time into time frames and further divides each time frame into N time slots(时隙) 仅有一个节点他的速度任然是R/N的速度</p></li>
<li><p>frequency-division multiplexing (FDM): 将R bps 信道划分为不同的频段, 具有TDM的缺点</p></li>
</ul>
<h4 id="random-access-protocols">Random Access Protocols</h4>
<ul>
<li><p><strong>Slotted ALOHA (时隙 ALOHA)</strong>:</p>
<p>有如下假设:</p>
<ul>
<li>All frames consist of exactly L bits.</li>
<li>Time is divided into slots of size L/R seconds (that is, a slot equals the time to transmit one frame).</li>
<li>Nodes start to transmit frames only at the beginnings of slots.</li>
<li>The nodes are synchronized so that each node knows when the slots begin.</li>
<li>If two or more frames collide in a slot, then all the nodes detect the collision event before the slot ends.</li>
</ul>
<p>p 是一个0-1的概率, 有如下操作:</p>
<ul>
<li>当节点要发送一个新帧时,需要在下一个时隙开始并在该时隙传输整个帧</li>
<li>如果没有碰撞则成功传输,不需要考虑重传</li>
<li>如果有碰撞,该结点在时隙结束之前检测到碰撞,之后以p在之后的每一杠时隙重传,直到成功</li>
</ul>
<p>此协议需要时钟同步,但是当只有一个结点时,效率是R</p>
<p>此协议效率定义为:有大量活跃结点发送大量帧时,长期运行中成功时隙的份额</p>
<p>在p的概率下 N个结点的效率为<span class="math inline">\(Np(1-p)^{N-1}\)</span> N趋于无穷时有极限1/e = 0.37</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_10.png" style="zoom:50%;" /></p></li>
<li><p>ALOHA</p>
<p>时隙ALOHA的无时钟同步版本, 效率降低一半</p></li>
<li><p>Carrier Sense Multiple Access (CSMA 载波监听多路访问)</p>
<p>规则:</p>
<ol type="1">
<li><em>Listen before speaking</em>, this is called <strong>carrier sensing</strong></li>
<li><em>If someone else begins talking at the same time, stop talking</em>, this is called <strong>collision detection</strong></li>
</ol>
<p>These two rules are embodied in the family of <strong>carrier sense multiple access(CSMA)</strong> and <strong>CSMA with collision detection (CSMA/CD)</strong> protocols</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_12.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_13.png" style="zoom:50%;" /></p>
<p>CSMA/CD 的运行</p>
<ol type="1">
<li>The adapter obtains a datagram from the network layer, prepares a link-layer frame, and puts the frame adapter buffer.</li>
<li>If the adapter senses that the channel is idle (that is, there is no signal energy entering the adapter from the channel 即在96比特时间内没有检测到信道上有信号), it starts to transmit the frame. If, on the other hand, the adapter senses that the channel is busy, it waits until it senses no signal energy and then starts to transmit the frame.</li>
<li>While transmitting, the adapter monitors for the presence of signal energy coming from other adapters using the broadcast channel.</li>
<li>If the adapter transmits the entire frame without detecting signal energy from other adapters, the adapter is finished with the frame. If, on the other hand, the adapter detects signal energy from other adapters while transmitting, it aborts the transmission (that is, it stops transmitting its frame).</li>
<li>After aborting, the adapter waits a random amount of time and then returns to step 2.</li>
</ol>
<p>选择随机回退时间算法:</p>
<p><strong>binary exponential backoff(二进制指数后退)</strong>algorithm</p>
<p>经历n次碰撞之后,结点随机的从<span class="math inline">\(\{0,1,2,...,2^n-1\}\)</span>选择一个值作为回退时间</p></li>
</ul>
<h4 id="taking-turns-protocols">Taking-Turns Protocols</h4>
<p>Recall that two desirable properties of a multiple access protocol are (1) when only one node is active, the active node has a throughput of R bps, and (2) when M nodes are active, then each active node has a throughput of nearly R/M bps. The ALOHA and CSMA protocols have this first property but not the second.</p>
<ul>
<li><strong>polling protocol(轮询协议)</strong>: 在一个主结点的控制下轮询各个结点</li>
<li><strong>token-passing protocol(令牌传递协议)</strong>:结点构成一个环,将令牌传递,有令牌的发送,结束后传递给下一个</li>
</ul>
<p>具有单点失效性</p>
<h3 id="switched-local-area-networks">5.4 Switched Local Area Networks</h3>
<h4 id="link-layer-addressing-and-arp">Link-Layer Addressing and ARP</h4>
<ul>
<li><p><strong>MAC(LAN address, a physical address)</strong>: 48 bits, FF-FF-FF-FF-FF-FF <strong>broadcast address</strong></p></li>
<li><p><strong>Address Resolution Protocol (ARP)</strong>:</p>
<p>ARP 维护一个ARP表</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_18.png" style="zoom:50%;" /></p>
<p>表中没有所需要的项时,就会发送一个ARP分组并向子网广播获取对方的MAC地址,当需要发送到子网以外时,需要先获取网关路由器的MAC地址,然后一步步转发出去</p></li>
</ul>
<h4 id="ethernet">Ethernet</h4>
<ul>
<li>hub(集线器): 比特级复制数据,可以达到广播的目的</li>
<li>switch(交换机):存储转发功能,且无碰撞(因为有缓存)</li>
</ul>
<p>结构:</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_20.png" style="zoom:50%;" /></p>
<p>以太网技术提供不可靠服务,接收方会执行CRC校验,失败则丢弃,但不对发送方产生任何的反馈信息</p>
<h4 id="link-layer-switches">Link-Layer Switches</h4>
<ul>
<li><strong>Filtering</strong>: determines whether a frame should be forwarded to some interface or should just be dropped.</li>
<li><strong>Forwarding</strong>: determines the interfaces to which a frame should be directed, and then moves the frame to those interfaces.</li>
</ul>
<p>一个目的MAC通过一个接口x到达交换机有3种情况:</p>
<ol type="1">
<li>没有此目的MAC的表项则广播</li>
<li>此表项和x已经关联,丢弃</li>
<li>不等于x的y接口是此目的MAC 则转发</li>
</ol>
<p>交换机是自学习的,即插即用,双工设备</p>
<ol type="1">
<li>初始交换机为空</li>
<li>对每个接口接收到的帧,存储 MAC, 接口, 时间信息</li>
<li>在老化期(aging time)之后没有收到该地址作为源的帧删除</li>
</ol>
<p>交换机的优点:</p>
<ol type="1">
<li><em>Elimination of collisions</em></li>
<li><em>Heterogeneous links</em>(异质的链路)</li>
<li><em>Management</em></li>
</ol>
<p>交换机和路由器比较:</p>
<ul>
<li><p>交换机: 即插即用、高转发过滤速率、没有提供广播风暴保护措施</p></li>
<li><p>路由器：一般不会死循环（TTL）、广播风暴有有防火墙保护，非即插即用，处理时间长</p></li>
</ul>
]]></content>
      <categories>
        <category>Tutorial &amp; Note</category>
        <category>Computer Network</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode84 柱状图中最大的矩形</title>
    <url>/2020/03/01/2020-02-29-Leetcode84/</url>
    <content><![CDATA[<h2 id="题目描述"><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtLw==" title="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">题目描述<i class="fa fa-external-link"></i></span></h2>
<blockquote>
<p>题目图片会403。。</p>
</blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解决方案">解决方案</h2>
<p>官方已经给出很多中方法了：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uL3podS16aHVhbmctdHUtemhvbmctenVpLWRhLWRlLWp1LXhpbmctYnktbGVldGNvZGUv" title="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/">leetcode官方解答<i class="fa fa-external-link"></i></span></p>
<p>但是有些感觉没说清楚的地方，主要是两种思路，<strong>分治法</strong>和<strong>栈</strong></p>
<h3 id="分治法">分治法</h3>
<p>对一个区间我们可以认为最大矩形只有三种情况，假设最短下标为<em>i</em></p>
<ul>
<li>下标<em>i</em>为最大矩形的高，此时宽就是整个区间</li>
<li>最大矩形出现在下标<em>i</em>的左边</li>
<li>最大矩形出现在下标<em>i</em>的右边</li>
</ul>
<p>这样子就可以将大问题分而治之，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divide(heights, <span class="number">0</span>, heights.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_index = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i] &lt; heights[min_index]) &#123;</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> area = heights[min_index]*(r-l+<span class="number">1</span>);</span><br><span class="line">        area = <span class="built_in">max</span>(area, divide(heights, l, min_index<span class="number">-1</span>));</span><br><span class="line">        area = <span class="built_in">max</span>(area, divide(heights, min_index+<span class="number">1</span>, r));</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的复杂度是<span class="math inline">\(n\log n\)</span>，但是在有序数列的情况下，会达到 <span class="math inline">\(n^2\)</span>，有时候leetcode会超时（多提交几次没准就过哈哈）</p>
<h3 id="栈">栈</h3>
<p>这个方法就十分巧妙了，看了好久的官方代码才明白</p>
<p>其中的主要思想是：<strong>如何求一根高为<em>h</em>的柱子的最大矩形</strong>。这个思路就很清楚了，分别从此柱子下标开始向两边寻找第一个高度小于它的（在往两边拓展则会高度变小），就可以了</p>
<p>这个栈的思路也是如此：<strong>维护一个非递减栈</strong>，通过一遍遍历，即可完成所有以此柱子为高的最大矩形面积的确定</p>
<p>当我们从左往右将柱子<strong>下标</strong>加入栈，直到遇到一个<strong>破坏非递减关系</strong>的柱子（即<span class="math inline">\(heights[i]&lt;heights[i-1]\)</span>），记此时的下标为<em>i</em>。我们假设此时栈中满足高度<strong>小于</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> <em>i</em>柱子的最大下标为<em>j</em>，那么在区间 <span class="math inline">\((i,j)\)</span>之间的柱子的最大面积都可以确定</p>
<p>令<span class="math inline">\(z \in (i,j)\)</span>，下标为<em>z</em>的柱子它们的右边界就是<em>i</em>，它们的左边界就是在栈中位于它们之下的那个下标，假设为<em>k</em>，有了这些<em>z</em>的最大面积也可以得出来了</p>
<p>利用栈的后进先出特性，此时我们可以一个个的从栈中弹出下标，直到遇到上面的“<em>j</em>”，可以得出计算面积的表达式： <span class="math display">\[
(i-stack[top-1]\times heights[stack[top]])
\]</span> 在多次入栈出栈后，栈内的坐标会变得的不再连续，而且上面的规则隐藏了一些深的特性</p>
<p>假设 <em>stack[top-1]</em> 的值为 <em>k</em>，每个区间的特别意义如下：</p>
<ul>
<li>从左到右排列：<span class="math inline">\(j,k,z,i\)</span> 注意此时<em>i</em>并未入栈</li>
<li><span class="math inline">\((j,k)\)</span>：此区间的高度均大于或等于<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a><span class="math inline">\(heights[i]\)</span></li>
<li><span class="math inline">\((k,z)\)</span>：此区间高度均大于或等于 <span class="math inline">\(heights[z]\)</span>（当<em>k,z</em>不连续时，此时比<em>z</em>小的都在之前被弹出了栈）</li>
<li><span class="math inline">\((z,i)\)</span>：此区间最大矩形均已确定，按以上表达式</li>
</ul>
<p>在最后如果栈不为空，则说明栈内的下标对应高度<strong>呈非递减趋势</strong>。此时依次出栈计算面积，计算表达式为： <span class="math display">\[
heights[stack[top]]*(heights.size - stack[top-1] - 1) \\
因为stack[top-1]之后高度均大于等于stack[top]
\]</span></p>
<h3 id="代码如下">代码如下</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st; st.push(<span class="number">-1</span>); <span class="comment">// 方便处理栈底的处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heights.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="comment">// 此时找到了一个非递增的</span></span><br><span class="line">            <span class="comment">// 注意大于等于都可以</span></span><br><span class="line">            <span class="keyword">while</span>(st.top() != <span class="number">-1</span> &amp;&amp; heights[st.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height_index = st.top(); st.pop();</span><br><span class="line">                res = <span class="built_in">max</span>(res, heights[height_index]*(i - <span class="number">1</span> - st.top()));</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.top() != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> height_index = st.top(); st.pop();</span><br><span class="line">            res = <span class="built_in">max</span>(res, (<span class="keyword">int</span>)(heights[height_index]*(heights.<span class="built_in">size</span>() - st.top() - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uL3poYW8tbGlhbmctYmlhbi1kaS15aS1nZS14aWFvLXl1LXRhLWRlLXpoaS1ieS1wb3djLw==" title="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/">社区题解<i class="fa fa-external-link"></i></span>有个更巧妙的，在heights数组前和后加入高度0，可以避免最后以此的清空栈操作和对栈底弹出时的特别处理（此处使用加入-1作为特别处理）</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(heights)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            left_i = i</span><br><span class="line">            right_i = i</span><br><span class="line">            <span class="keyword">while</span> left_i &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[left_i] &gt;= heights[i]:</span><br><span class="line">                left_i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right_i &lt; n <span class="keyword">and</span> heights[right_i] &gt;= heights[i]:</span><br><span class="line">                right_i += <span class="number">1</span></span><br><span class="line">            res = max(res, (right_i - left_i - <span class="number">1</span>) * heights[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr />
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>其实在此处小于等于也是可以的<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>根据注解1处的不同而不同（1处若为小于等于，此处则仅大于）<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统精髓与设计原理 第8版 阅读笔记</title>
    <url>/2020/02/28/2020-02-28-Operating-System-Internals-and-Design-Principles-8th-Note/</url>
    <content><![CDATA[<p>操作系统是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。—— 维基百科</p>
<blockquote>
<p>前几章为引言部分 略</p>
</blockquote>
<a id="more"></a>
<h2 id="第二部分-进程">第二部分 进程</h2>
<h3 id="第三章-进程描述和控制">第三章 进程描述和控制</h3>
<hr />
<h4 id="进程的几个定义">1. 进程的几个定义</h4>
<ul>
<li>一个正在执行的<strong>程序</strong></li>
<li>一个正在<strong>计算机</strong>上执行的程序实例</li>
<li>能分配给<strong>处理器</strong>并由处理器执行的实体</li>
<li>由一组执行的<strong>指令</strong>，一个<strong>当前状态</strong>和一组相关的<strong>系统资源</strong>表征的活动单元</li>
</ul>
<h4 id="基本元素">2. 基本元素</h4>
<p>程序代码 + 数据集</p>
<h4 id="进程控制块-pcb">3. 进程控制块 （PCB）</h4>
<ul>
<li>标识符</li>
<li>状态：新建，运行，就绪，挂起，阻塞，退出</li>
<li>优先级</li>
<li>程序计数器： 保存下一条指令的地址</li>
<li>内存指针：代码 / 数据 / 其它进程的指针</li>
<li>上下文数据：处理器执行时寄存器里的值</li>
<li>I/O 状态信息：I/O 请求； I/O 设备； 文件列表</li>
<li>记账信息：处理器时间，记账号</li>
</ul>
<h4 id="进程状态">4. 进程状态</h4>
<p><strong>轨迹</strong>：进程执行的指令序列</p>
<h5 id="两状态模型">两状态模型</h5>
<p>非运行态 <span class="math inline">\(\Leftrightarrow\)</span> 运行态</p>
<h5 id="五状态模型">五状态模型</h5>
<ul>
<li>运行态：进程正在执行，假设为一个计算机，那么一次最多只有一个进程处于此状态</li>
<li>就绪态：进程做好了准备，随时可以处于运行态</li>
<li>阻塞态：在发生某些事件前不能执行，如I/O</li>
<li>新建态：已创建PCB但还未加载到内存中的进程</li>
<li>退出态：操作系统从可执行进程组释放出的进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/5_states_module.jpg" /></p>
<h4 id="进程的挂起">5. 进程的挂起</h4>
<p><strong>原因</strong>：当所有进程都处于阻塞态时，处理器处于休闲状态。此时将某个进程的一部分或者全部移入磁盘，然后从挂起队列加载一个新进程，放入内存中运行</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/suspended_state.jpg" /></p>
<h5 id="进程挂起的原因">进程挂起的原因</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/suspended_reason.jpg" /></p>
<h4 id="进程创建和终止">6. 进程创建和终止</h4>
<ul>
<li><p>进程创建的原因：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/creat_process_reason.jpg" /></p></li>
<li><p>进程终止的原因：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/end_process_reason.jpg" /></p></li>
</ul>
<h4 id="操作系统控制结构">7. 操作系统控制结构</h4>
<ul>
<li>内存表：跟踪内存和外（虚）存（交换机制）
<ul>
<li>分配给进程的内存</li>
<li>分配给进程的外存</li>
<li>内存块或虚存块的任何保护属性</li>
<li>管理虚存所需要的任何信息</li>
</ul></li>
<li>I/O 表：管理I/O 设备和通道</li>
<li>文件表：文件管理：是否存在，位置等信息</li>
<li>进程表：内存，I/O， 文件是代表进程而被管理的</li>
</ul>
<h4 id="进程控制结构">8. 进程控制结构</h4>
<p>进程映像：程序 + 数据 + 栈 + 属性</p>
<h5 id="pcb-进程控制块">PCB 进程控制块</h5>
<ul>
<li><p>进程标识信息：存储在PCB中的数字标识符,包括: 进程ID，父进程ID，用户ID</p></li>
<li>进程状态信息（处理器状态信息）：存储所有的程序状态字（PSW）</li>
<li><p>进程控制信息：操作系统协调各种活动进程的额外信息</p></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/PCB.jpg" /></p>
<h5 id="pcb-的作用">PCB 的作用</h5>
<blockquote>
<p>PCB 是操作系统中最重要的数据结构，包含操作系统所需进程的全部信息</p>
<p>PCB 集合定义了OS的状态</p>
</blockquote>
<p>如何在发生错误和变化时，保护PCB，具体表现为两个问题：</p>
<ul>
<li>一个例程（如中断处理程序）中的错误可能会破坏进程控制块，进而破坏系统对受影响进程的管理能力</li>
<li>进程控制块结构或语义中的设计变化可能会影响到操作系统中的许多模块</li>
</ul>
<h4 id="进程控制">9. 进程控制</h4>
<h5 id="执行模式">执行模式</h5>
<p>特权模式称为系统模式，控制模式或者<strong>内核模式</strong>，非特权模式又称为用户模式</p>
<p><strong>原因</strong>：保护操作系统和重要的操作系统表 不受用户程序的干扰</p>
<p><strong>ELSE</strong>：PCB 中有指示执行模式的位，因事件变化而变化，当用户调用OS服务或中断触发系统例程时，执行模式变为内核模式，返回到用户进程时变为用户模式</p>
<h5 id="内核的典型功能">内核的典型功能</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/OS_kernel_function.jpg" /></p>
<h4 id="进程创建-具体过程">10. 进程创建 具体过程</h4>
<ol type="1">
<li>为新进程分配一个唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化PCB</li>
<li>设置正确的链接：放入新建/就绪挂起 链表中</li>
<li>创建或扩充其他数据结构：记账文件</li>
</ol>
<h4 id="进程切换">11. 进程切换</h4>
<h5 id="何时切换进程">何时切换进程</h5>
<blockquote>
<p>可在OS从当前正在运行的进程获得控制器的任何时刻发生</p>
</blockquote>
<ul>
<li>系统中断： 时钟中断（超过运行时间片）；I/O 中断；内存失效</li>
<li>陷阱：处理一个错误和一个异常条件</li>
<li>系统调用：显示请求，调用操作系统函数</li>
</ul>
<h5 id="模式切换">模式切换</h5>
<p>出现中断时，处理器将：</p>
<ul>
<li>将从程序计数器置为中断处理程序的开始地址</li>
<li>从用户模式切换到内核模式，以便中断处理代码包含特权指令</li>
<li>保存已中断例程的上下文</li>
</ul>
<h5 id="进程切换-1">进程切换</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/process_change.jpg" /></p>
<h4 id="操作系统的执行">12. 操作系统的执行</h4>
<blockquote>
<p>第二章指出操作系统的两个特殊事实：</p>
<ul>
<li>OS 和普通软件以相同的方式运行，也是一个程序</li>
<li>OS 会频繁的释放控制权，并依赖于处理器来恢复控制权</li>
</ul>
</blockquote>
<h5 id="无进程内核">无进程内核</h5>
<p>在所有进程外部执行操作系统内核，进程概念只适用于用户程序，操作系统则是则是在特权模式下单独运行的实体</p>
<h5 id="在用户进程内运行">在用户进程内运行</h5>
<p>操作系统是用户调用的一组例程，在用户进程的环境中执行并实现各种功能。进程映像不仅包括自己的程序，数据，栈还包括<strong>内核程序</strong>的程序，数据，和栈区域。操作系统代码和数据位于共享地址空间中，并被所有用户进程所共享。只需要在同一进程中切换模式，而不需要切换进程</p>
<h5 id="基于进程的操作系统">基于进程的操作系统</h5>
<p>把操作系统作为一组系统进程来实现</p>
<p>优点：</p>
<ol type="1">
<li>鼓励模块化操作系统设计原理，使模块间接口最小且最简单</li>
<li>有些非关键系统功能可简单的用独立的进程来实现（例如监视各种资源和状态的程序）</li>
<li>在多处理器和多机环境中很有用</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_3/OS_and_userprocess.jpg" /></p>
<h3 id="第四章-线程">第四章 线程</h3>
<hr />
<h4 id="进程和线程">1. 进程和线程</h4>
<h5 id="进程特点">进程特点</h5>
<ul>
<li>资源所有权：进程包括存放进程映像的虚拟地址空间</li>
<li>调度/执行：进程具有执行态和优先级，是可被OS调度和执行的实体</li>
</ul>
<blockquote>
<p>这两个特点是独立的，为了区分这两个特点，通常将分派的单位称为线程（轻量级进程LWP）</p>
<p>而将资源所有权的单位称为进程（任务）</p>
</blockquote>
<h5 id="多线程">多线程</h5>
<blockquote>
<p>指OS在单个进程内支持多个并发执行路径的能力</p>
</blockquote>
<p>在多线程环境中，进程定义为资源分配单元和一个保护单元，与进程相关联的有：</p>
<ul>
<li>容纳进程映像的虚拟地址空间</li>
<li>对处理器，其他进程，文件，I/O 的受保护访问</li>
</ul>
<p>每个线程都有：</p>
<ul>
<li>一个线程的执行状态</li>
<li>线程上下文，线程可视为进程内运行的一个独立程序计数器</li>
<li>一个执行栈</li>
<li>局部变量的静态存储空间</li>
<li>与其他线程共享的内存和资源的访问</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_4/thread_module.jpg" /></p>
<p>使用线程的几个例子：</p>
<ul>
<li>前台和后台工作</li>
<li>异步处理</li>
<li>执行速度</li>
<li>模块化程序结构</li>
</ul>
<p><strong>线程的优点</strong></p>
<blockquote>
<p><strong>Why</strong>: 因为线程共享一个地址，内存，文件空间，ULT中不用切换到内核</p>
</blockquote>
<ul>
<li>创建线程的时间少于创建进程的时间</li>
<li>终止线程的时间少于终止进程的时间</li>
<li>同一个内线程切换时间少于进程间切换的时间</li>
<li>线程提高了不同执行程序间通信的效率</li>
</ul>
<h5 id="线程的功能">线程的功能</h5>
<p>线程状态：就绪态，运行态，阻塞态</p>
<p>基本操作：派生，阻塞，解除阻塞，结束</p>
<p>线程同步：同步线程的活动是它们互不干扰且不破坏数据结构，如两个线程向一个链表加入元素，则可能会丢失</p>
<h4 id="线程分类">2. 线程分类</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_4/thread_type.jpg" /></p>
<h5 id="用户级ult">用户级（ULT）</h5>
<p>管理线程的所有工作都由应用程序完成，内核意识不到线程的存在。任何应用程序都可以设计成多线程程序。线程库提供了所有关于线程的操作</p>
<p><strong>ULT相较于KLT的优点</strong>：</p>
<ul>
<li>所有线程都在一个进程的用户地址空间中，线程切换不需要内核模式特权，因此不需要切换到内核状态，节省了两次状态转换</li>
<li>调度因程序的不同而不同</li>
<li>ULT 可以在任何操作系统中运行</li>
</ul>
<p><strong>ULT相较于KLT的缺点</strong>：</p>
<ul>
<li>ULT 执行一个系统调用的话，不仅阻塞当前线程，也会阻塞进程内的所有线程</li>
<li>多线程应用程序不能利用多处理技术，这里线程对操作系统是不可见的，内核一次把一个进程分配给处理器，这样一个进程内只能运行一次一个线程，相当于在一个进程内实现了多道程序设计</li>
</ul>
<h5 id="内核级线程klt">内核级线程（KLT）</h5>
<p>管理线程的所有操作由内核完成，应用级只有一个到内核线程实施的应用编程接口（API）</p>
<p><strong>KLT 的优点：</strong></p>
<ul>
<li>内核可以把进程中的多个线程调度到多个处理器中</li>
<li>进程的一个线程阻塞时，不影响其他线程的调度</li>
<li>内核例程也可以是多线程的</li>
</ul>
<p><strong>KLT 的缺点：</strong></p>
<ul>
<li>线程转换时 需要切换到内核状态</li>
</ul>
<h5 id="混合">混合</h5>
<blockquote>
<p>结合两者优点</p>
</blockquote>
<h4 id="多核和多线程">3、多核和多线程</h4>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_4/Amdahl.jpg" /></p>
<blockquote>
<p>并不是核越多越好，管理起来越麻烦，会有更多多余的开销</p>
</blockquote>
<p><strong>影响多核系统上软件性能的因素</strong></p>
<ul>
<li>核的数量</li>
<li>串行代码比例</li>
<li>多处理器任务调度和通信以及高速缓存一致性带来的额外开销</li>
</ul>
<h3 id="第五章-并发性互斥和同步">第五章 并发性：互斥和同步</h3>
<hr />
<p>操作系统的核心问题是进程和线程的管理：</p>
<ul>
<li>多道程序设计技术：管理单处理器中的多个进程</li>
<li>多处理器技术：管理多处理器中的多个进程</li>
<li>分布式处理器技术：管理多台分布式计算机中多个进程的执行（集群）</li>
</ul>
<p><strong><em>并发是所有问题的基础，也是操作系统设计的基础（设计问题：进程通信，资源共享和竞争）</em></strong></p>
<p>出现的环境：</p>
<ul>
<li>多应用程序：程序间动态共享处理器时间</li>
<li>结构化应用程序：。。。</li>
<li>操作系统结构：。。。</li>
</ul>
<h4 id="并发的原理">1、并发的原理</h4>
<h5 id="并发处理的问题难点">并发处理的问题（难点)</h5>
<ul>
<li>全局资源的共享充满了危险</li>
<li>OS很难对资源进行最优化分配</li>
<li>定位程序设计错误非常困难</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">zvoid <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chin = getchar();</span><br><span class="line">    chout = chin;</span><br><span class="line">    <span class="built_in">putchar</span>(chout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个打印字符的程序很容易发生数据的丢失，出现这种问题的原因是中断可能在进程的任何地方发生，解决方案是控制对共享资源的访问</p>
<h5 id="竞争条件">竞争条件</h5>
<p>竞争条件发生在多个进程或线程读写数据时，其最终结果取决于进程的指令执行顺序</p>
<h5 id="进程的交互">进程的交互</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/interfaceOfProcess.jpg" /></p>
<p>有几个基本概念：</p>
<p><strong><em>临界资源</em></strong> ：就是上面谈到的一个不可分享的资源</p>
<p><strong><em>临界区</em></strong>：使用这一部分资源的程序称为程序的临界区</p>
<p><strong><em>死锁</em></strong>：两个进程互相控制两个资源，但又还需要对方持有的资源才可以继续工作，这样就产生了死锁（两个进程都不能继续工作）</p>
<p><strong><em>饥饿</em></strong>：有三个进程ABC，每个进程都需要访问资源R，资源被AC交替访问，却始终没有分配给B这样B就处于饥饿状态</p>
<h5 id="互斥的要求">互斥的要求</h5>
<blockquote>
<p>互斥：简单来说，就是两个或多个进程需要访问一个不可分享的资源的保护机制</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/demandOfMutex.jpg" /></p>
<h4 id="互斥硬件的支持">2、互斥：硬件的支持</h4>
<h5 id="中断禁用">中断禁用</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* 禁用中断 */</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    <span class="comment">/* 启用中断 */</span></span><br><span class="line">    <span class="comment">/* 其余部分 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>临界区不能被中断，所以可以保证互斥，为了保证互斥只需要保证一个进程在访问资源的时候不被中断。</p>
<p>但是，这种方法的代价非常高。由于处理器被限制得只能交替执行程序，因此执行的效率会明显降低。而且它不能用于多处理器体系结构。当一个计算机系统含有多个处理器时，通常可能有多个进程同时执行。这种情况下，中断不能保证互斥。因为在多处理器配置中，<strong><em>几个处理器对内存的访问不存在主从关系，处理器之间的行为是无关的，表现出一种对等的关系，处理器之间没有支持互斥的中断机制。</em></strong></p>
<h5 id="专用机器指令">专用机器指令</h5>
<p>在硬件级别上，对存储单元的访问排斥对相同单元的其他访问，因此处理器的设计人员提出了一些机器指令，用与保证两个动作的原子性（不能被中断的指令），<strong>在这个指令执行的过程中，任何其他指令访问内存都将被总之，而且这些动作在一个指令周期中完成</strong></p>
<ul>
<li><strong>比较和交换指令：</strong></li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">word</span>, <span class="keyword">int</span> testval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldval;</span><br><span class="line">    oldval = *<span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">if</span>(oldval == testval) *<span class="keyword">word</span> = newval;</span><br><span class="line">    <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一个测试值检查一个内存单元，如果内存单元的当前值是<code>testval</code>，就使用<code>newval</code>取代该值，否则保持不变，并返回旧内存值。因此如果返回值和测试值相同，表示内存单元已经被更新，整个过程按原子操作执行，不接受中断。这个过程的另一个版本为返回<code>bool</code>值，判断是否完成交换</p>
<ul>
<li><strong>exchange指令</strong></li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/mutexInHardware.jpg" /></p>
<p><strong>忙等待（自旋等待）</strong>：进程在得到临界区访问权之前，它只能继续执行测试变量的指令来得到访问权，除此之外不能做任何事情</p>
<p>对于上图 <strong>a</strong> ,唯一可以进入临界区的进程是发现bolt为0的那个进程，并把bolt置为1在它访问临界区的时候，此时其他的进程都处于忙等待中，访问结束后继续讲bolt置为0，此时下一个可以进入临界区的进程就是在这之后最早执行<code>compare&amp;swap</code>指令的进程</p>
<p>对于上图<strong>b</strong> ,工作原理和 <strong>a</strong> 几乎一致。由于变量初始化的方式和交换算法的本质，下面的表达式恒成立：</p>
<p><span class="math display">\[ bolt + \sum_ikey_i = n \]</span></p>
<p>若<code>bolt = 0</code>，则没有任何一个进程在他的临界区中，若<code>bolt = 1</code>，则只有一个进程在临界区中，且为 <strong><em>key为 0</em></strong> 的那个进程</p>
<h5 id="机器指令方法的特点">机器指令方法的特点</h5>
<p>有如下的优点：</p>
<ul>
<li>适用于单处理器或共享内存的多处理器上的任意数量的进程</li>
<li>简单且易于证明</li>
<li>可以用支持多个临界区，每个临界区可以用它自己的变量定义</li>
</ul>
<p>但也有一些严重的缺点：</p>
<ul>
<li>使用了忙等待：在一个进程在等待进入临界区时，它依然在消耗处理器时间</li>
<li>可能饥饿：选择哪个等待进程时任意的，因此有些进程会被无限拒绝进入</li>
<li>可能死锁：考虑单处理器下的情况：进程P1执行专用指令（上面的两个）并进入临界区，然后P1被中断并交给更高优先级的P2执行，P2由于互斥机制讲被拒绝访问，但是由于P1优先级低，它也永远不会被调度执行</li>
</ul>
<h4 id="信号量">3、信号量</h4>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamhjZWx1ZS9wLzcwODAxNDYuaHRtbA==" title="https://www.cnblogs.com/jhcelue/p/7080146.html">https://www.cnblogs.com/jhcelue/p/7080146.html<i class="fa fa-external-link"></i></span></p>
</blockquote>
<p>讨论的是提供并发性的操作系统和设计语言的机制</p>
<p>常用的并发机制：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/concurrencyWays.jpg" /></p>
<p>基本原理如下：</p>
<p>两个或多个进程可以通过简单的信号进行合作。强迫一个进程在某个位置停止，知道它接受到一个特定的信号，其中使用了一个称为<strong>信号量</strong>的特殊变量。通过信号量 s 传送信号，进程须执行原语<code>semSignal(s)</code>;要通过信号量 s接受信号需要执行原语<code>semWait(s)</code>;若相应信号未发送则阻塞进程，知道发送完为止</p>
<p>为达到预期效果，可把信号量视为一个值为整数的变量，定义了三个操作：</p>
<ul>
<li>一个信号量可以初始化为非负数</li>
<li><code>semWait</code> 使信号量减1，若值变成负数，则阻塞执行<code>semWait</code>的进程，否则继续执行</li>
<li><code>semSignal</code>操作使信号量加1，若值小于等于0，则被<code>semWait</code>操作阻塞的进程解除阻塞</li>
</ul>
<p>信号量为正数时代表发出<code>semWait</code>后可以继续执行的进程数量，信号量为负数时，每个<code>semSignal</code>操作都会将等待进程中的一个进程接触阻塞</p>
<p>对于信号量有三个重要结论：</p>
<ul>
<li>通常，在进程对信号量-1之前，无法提前知道该信号量是否会被阻塞</li>
<li>当进程对信号量+1后，会唤醒另一个进程，两个进程继续并发运行。而在一个单处理器系统中，无法知道哪一个进程会继续运行</li>
<li>向信号量发出信号后，不需要知道是否有另外一个进程在等待，被接触的进程数要么没有，要么为1</li>
</ul>
<p>信号量原语的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span> (s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把当前进程插入队列</span></span><br><span class="line">        <span class="comment">// 阻塞当前进程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span> (s.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把进程P从队列移除</span></span><br><span class="line">        <span class="comment">// 把进程P插入就绪队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二元信号量的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, one&#125; value;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one) s.value = zero;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入阻塞队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) s.value = one;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将进程P解除阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理论上二元信号量更易于实现，且可以证明与普通信号具有同样的表达能力，非二元信号量也称作<strong>计数信号量</strong>或<strong>一般信号量</strong></p>
</blockquote>
<p>与二元信号量有关的还有<strong><em>互斥锁（Mutex）</em></strong>。互斥是一个编程标志位，用来获取和释放一个对象。可以对一个资源进行<strong>加锁</strong>和<strong>解锁</strong>操作，即为置0和置1，可以由互斥量和二元信号量实现，二者区别在于，<strong>互斥量解锁和加锁的进程必须是同一个进程，二元信号量进行加锁操作，而由另一个进程解锁</strong></p>
<ul>
<li>强信号量：进程按照FIFO策略将进程从队列溢移除的信号量</li>
<li>弱信号量：没有规定队列移除顺序的信号量</li>
</ul>
<p>可以理解强信号量不会导致饥饿，而弱信号量可能导致饥饿</p>
<p><strong>信号量机制示例</strong></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/semaphoreExample.jpg" /></p>
<h5 id="互斥">互斥</h5>
<p>使用信号量的互斥：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程数*/</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(s);</span><br><span class="line">        <span class="comment">//临界区</span></span><br><span class="line">        semSignal(s);</span><br><span class="line">        <span class="comment">//Else</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    parbegin(P(<span class="number">1</span>), P(<span class="number">2</span>), ..., P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/explainAboutMutexInSemaphore.jpg" /></p>
<h5 id="生产者消费者问题">生产者消费者问题</h5>
<p><strong><em>问题描述</em></strong>：有一个或多个生产者生产某种类型的数据，并防止在缓冲区中；有一个消费者从缓冲区中取数据，每次取一项，任何时候只有一个主体访问缓冲区。问题是要确保：当缓存已满时，生产者不会继续向其中添加数据，当缓存为空时，消费者不会从中移走数据</p>
<p>首先假设缓冲区是无限的，且是一个线性数组，可以使用二元信号量和计数信号量实现</p>
<p><strong>二元信号量错误的方法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 缓冲区剩余生产量</span></span><br><span class="line"><span class="comment">// delay：用于解决空的时候消费者不移走数据</span></span><br><span class="line"><span class="comment">// s：用于互斥,控制资源访问</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, <span class="built_in">delay</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(S);</span><br><span class="line">        append(); <span class="comment">// 正式将数据加入缓冲区</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 告诉消费者缓冲区已经有数据了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) semSignal(<span class="built_in">delay</span>);</span><br><span class="line">        semSignal(S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    semWait(<span class="built_in">delay</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(s);</span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="comment">// 消费完之后阻塞当前进程 因为在此循环中delay不会为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) semWait(<span class="built_in">delay</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer,consumer);	<span class="comment">//创建线程/进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么是错误的，可能造成消费完之后继续取</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/wrongInProducer_Consumer.jpg" /></p>
<p>也就是在消费者消费之后已经不属于互斥资源保护区，发生中断之后不能保护原有变量的值，正如上图第10行，本来应该阻塞消费者进程，但是由于中断使n++，并且有重新将delay置1，而后恢复消费者进程消费完缓冲区之后delay信号仍然为1所以，此时缓冲区为空但是并不会阻塞进程，所以还会继续从已经为空的缓冲区拿东西（也就是delay信号并不能匹配了）</p>
<p><strong>二元信号量正确的方法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 缓冲区剩余生产量</span></span><br><span class="line"><span class="comment">// delay：用于解决空的时候消费者不移走数据</span></span><br><span class="line"><span class="comment">// s：用于互斥,控制资源访问</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, <span class="built_in">delay</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(S);</span><br><span class="line">        append(); <span class="comment">// 正式将数据加入缓冲区</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 告诉消费者缓冲区已经有数据了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) semSignal(<span class="built_in">delay</span>);</span><br><span class="line">        semSignal(S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    semWait(<span class="built_in">delay</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(s);</span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        <span class="comment">// 保护变量m这样就不怕之前的n被修改</span></span><br><span class="line">        m = n;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="comment">// 消费完之后阻塞当前进程 因为在此循环中delay不会为1</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) semWait(<span class="built_in">delay</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer,consumer);	<span class="comment">//创建线程/进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一般信号量（计数信号量），可得到一种更好的解决方法，如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">semephore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWiat(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()....</span><br></pre></td></tr></table></figure>
<p>如果是有限缓冲区的话，只需要对缓冲区大小也设置信号量保护即可</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sizeofBuffer = <span class="comment">//缓冲区大小</span></span><br><span class="line">semephore n = <span class="number">0</span>, s = <span class="number">1</span>, e = <span class="built_in">size</span></span><br><span class="line"><span class="keyword">void</span> producer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semwait(e);	<span class="comment">// e表示缓冲区中空的个数</span></span><br><span class="line">        semWiat(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);	<span class="comment">// 已经消耗一个 有空位了</span></span><br><span class="line">        consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()....</span><br></pre></td></tr></table></figure>
<h5 id="信号量的实现">信号量的实现</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/implementOfSemaphore.jpg" /></p>
<h4 id="管程">4、管程</h4>
<blockquote>
<p>管程是一种程序设计语言结构（C/C++语言没有JAVA支持）</p>
<p>它提供的功能与信号量相同但是更易于控制</p>
</blockquote>
<h5 id="管程的特点">管程的特点</h5>
<ol type="1">
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞以等待管程可用</li>
</ol>
<h5 id="函数">函数</h5>
<p>管程通过使用<strong>条件变量</strong>来支持同步，这些条件变量包含在管程中，并且只有在管程中才能被访问</p>
<p>有两个函数可以操作条件变量：</p>
<ul>
<li>cwait(c): 使当前进程阻塞在条件c上</li>
<li>csignal(c): 使阻塞在c条件上的一个进程就绪</li>
</ul>
<h5 id="管程的结构">管程的结构</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/tubePassStruct.jpg" /></p>
<h5 id="例子重写消费者生产者问题">例子：重写消费者生产者问题</h5>
<blockquote>
<p>暂略</p>
</blockquote>
<p>这个例子表明，与信号量相比，管程担负的责任不同。对于管程，它有自己的互斥机制：两个进程不能同时访问缓冲区，但是<strong><em>cwait csignal</em></strong> 原语的位置需要注意。管程优于信号量之处在于，所有的同步机制都被限制在管程内部，因此不但易于验证同步的正确性，而且易于检测出错误。此外若一个管程被正确的编写，则所有进程对受保护资源的访问都是正确的，而对于信号量，只有当所有资源的进程都被正确编写时，资源访问才是正确的。</p>
<h5 id="管程的通知和广播">管程的通知和广播</h5>
<p>上述方法有两个缺陷</p>
<ul>
<li>产生 <code>csignal</code> 的进程在管程内还未结束，则需要两次额外的进程切换：阻塞进程需要一次切换，管程可用时又需要一次切换</li>
<li>与信号有关的进程调度必须非常可靠</li>
</ul>
<p>在新的管程规则（Mesa）中，<code>csignal</code>原语被<code>cnotify</code>代替，</p>
<p><code>cnotify</code>可以解释如下：当一个正在管程中的进程执行<code>cnotify(x)</code>中，会使得x 条件队列得到通知，但发信号的进程还在继续执行。但是由于不能保证在他之前没有其他进程进入管程，因而这个等待进程必须重新检查条件。</p>
<p><code>cbroadcast</code>原语：广播可以使所有在该条件上等待的进程置于就绪态，当一个进程不知道有多少进程被激活时，这种方法非常方便</p>
<h4 id="消息传递">5、消息传递</h4>
<blockquote>
<p>进程交互式必须满足两个基本要求：<strong>同步和通信</strong>，为实施互斥，进程间需要同步；为实现合作，进程需要交换信息，提供这一方法之一就是消息传递</p>
</blockquote>
<p><strong><em>注</em></strong>：互斥和同步的联系：——摘自<span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzQxNDU5MzU2MC5odG1s" title="https://zhidao.baidu.com/question/414593560.html">百度知道<i class="fa fa-external-link"></i></span>：</p>
<p>​ 相交进程之间的关系主要有两种，同步与互斥。所谓互斥，是指散步在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它 们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。 　　显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。 　　也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！ 　　<strong>总结</strong>：互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 　　<strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<p><strong>特点（优点）</strong>：可以在分布式系统、共享内存的多处理器系统和单处理器系统中实现</p>
<p><strong><em>消息传递原语</em></strong>：</p>
<ul>
<li><code>send(destination, message)</code></li>
<li><code>receive(source, message)</code></li>
</ul>
<h5 id="同步">同步</h5>
<blockquote>
<p>两个进程之间的消息通信隐含着某种同步的信息：只有当一个进程发送消息后，接受者才能接受消息</p>
</blockquote>
<p>一个进程发出<code>send</code>或者<code>receive原语</code>后，我们需要确定会发生什么：有三种组合：</p>
<ul>
<li><p>阻塞<code>send</code>，阻塞<code>receive</code>：</p>
<p>发送者和接收者都被阻塞，直到完成信息的投递，也叫做会合，考虑进程间 的紧密同步</p></li>
<li><p>无阻塞<code>send</code>，阻塞<code>receive：</code></p>
<p>发送者可以继续，但接收者会被阻塞直到请求的消息到达，适用于服务器给其他的进程提供服务和资源</p></li>
<li><p>无阻塞<code>send</code>，无阻塞<code>receive：</code></p>
<p>不要求任何一方等待</p></li>
</ul>
<h5 id="寻址">寻址</h5>
<blockquote>
<p>两个原语的中确定源进程或目标的方案有两类：<strong>直接和间接寻址</strong></p>
</blockquote>
<p><strong>直接寻址：</strong></p>
<p><code>send</code>原语包含目标进程的标识号，而<code>receive</code>有两种处理方式，一种是显示的指定源进程，该进程需要事先直到希望接受来自哪一个进程的消息。另一种是不指定所期望的源进程，例如打印机接受其他进程的打印请求。</p>
<p><strong>间接寻址：</strong></p>
<p>消息不直接从发送者发送到接收者，而是发送到一个共享数据结构，由临时保存消息的队列组成，称为<strong>信箱</strong>，具有一对一，多对一，一对多，多对多三种形式。其中<strong>多对一</strong>的信箱又叫做<strong>端口</strong>。</p>
<p>进程和信箱的关联可以是静态的，也可以是动态的。</p>
<p>还有就是所有权问题。对于端口来说，信箱的所有几乎都是接受进程（多对一），由接受进程创建，对于通用信箱，可以视信箱为创建它的进程所有和该进程一起终止，或是为操作系统所有，这时销毁信箱需要一个显示命令</p>
<h5 id="消息格式">消息格式</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/messageForm.jpg" /></p>
<h5 id="排队原则">排队原则</h5>
<p>最简单的排队原则是先进先出，还有优先级原则，以及允许接收者检查消息队列并选择下一次接受哪个消息</p>
<h5 id="互斥-1">互斥</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* 进程数 */</span></span><br><span class="line"><span class="keyword">void</span> P(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        receive(box, msg);</span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        send(box, msg);</span><br><span class="line">        <span class="comment">/* Else */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">create <span class="title">mailbox</span><span class="params">(box)</span></span>;</span><br><span class="line">    send(box, null)</span><br><span class="line">    parbegin(P(<span class="number">1</span>), P(<span class="number">2</span>)...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无阻塞<code>send</code>和阻塞<code>receive</code>实现互斥</p>
<p><strong>生产者消费者问题：</strong></p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_5/pcMessage.jpg" /></p>
<h4 id="读者写者问题">6、<strong>读者写者问题</strong></h4>
<p>暂略</p>
<h3 id="第六章-并发死锁和饥饿">第六章 并发：死锁和饥饿</h3>
<hr />
<h4 id="死锁原理">6.1 死锁原理</h4>
<p>死锁定义为一组相互竞争系统资源或进行通信的进程间的<strong>“永久”</strong>阻塞，所有死锁都涉及两个或者多个进程之间对资源需求的冲突。</p>
<p>简单来说两个进程都希望获得已经掌握的资源才能继续执行，就产生了死锁。</p>
<h5 id="资源的分类">资源的分类：</h5>
<ul>
<li>可重用资源：一次仅供一个进程安全使用且不因使用而耗尽的资源。包括处理器、I/O通道，内存和外存等</li>
<li>可消耗资源：可被创建和销毁的资源。包括中断、信号、消息和I/O缓冲取中的消息</li>
</ul>
<p>操作系统中死锁检测、预防和避免方法小结：</p>
<figure>
<img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_6/01.jpg" alt="操作系统中死锁检测、预防和避免方法小结" /><figcaption>操作系统中死锁检测、预防和避免方法小结</figcaption>
</figure>
<h5 id="资源分配图">资源分配图</h5>
<p>表征进程资源分配的有效工具是Holt引入的<strong>资源分配图</strong>，如下：</p>
<p>其中原点表示资源的一个实例，边表示请求资源和占有资源</p>
<figure>
<img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_6/02.jpg" alt="操作系统中死锁检测、预防和避免方法小结" /><figcaption>操作系统中死锁检测、预防和避免方法小结</figcaption>
</figure>
<p>如果资源分配图中出现环，并且环中存在资源实例个数小于环中进程的个数，则可能导致死锁</p>
<h5 id="死锁的条件">死锁的条件</h5>
<p>死锁有三个必要条件：</p>
<ul>
<li>互斥：一次只有一个进程可以使用资源</li>
<li>占有且等待：当一个进程等待其他进程时，继续占有已分配的资源</li>
<li>不可抢占：不能强行抢占已占有的资源</li>
</ul>
<p><strong>这三个为必要条件并非充分条件</strong>，要产生死锁还需要第四个条件：</p>
<p><strong>循环等待</strong>：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</p>
<p>第四个条件是前三个条件的潜在结果，满足前三个条件，然后在特定顺序的进程调度下就有可能产生死锁。</p>
<h4 id="死锁预防">6.2 死锁预防</h4>
<p>死锁预防策略是设计一种系统来排除发生死锁的可能性，死锁预防分为两类</p>
<ul>
<li>间接死锁预防方法，即阻止前面必要条件中的一个即可</li>
<li>直接死锁预防方法：防止循环等待的发生</li>
</ul>
<h5 id="互斥-2">互斥</h5>
<p>此条件不可能禁止，对于多进程的并发执行调度中，互斥是必须满足的条件</p>
<h5 id="占有且等待">占有且等待</h5>
<p>预防此条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足，显然，这个方法是低效的</p>
<ol type="1">
<li>一个进程可能被阻塞很长时间来等待所有的请求被满足，而实际上只要有一部分资源它就可以继续执行</li>
<li>一个进程可能实现并不知道它所需要的所有资源</li>
</ol>
<h5 id="不可抢占">不可抢占</h5>
<ol type="1">
<li>占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放最初占有的资源，必要时可再次申请这些资源和其他资源</li>
<li>一个进程请求被其他进程占有的资源时，可以抢占另一个进程，要求它释放资源</li>
</ol>
<h5 id="循环等待">循环等待</h5>
<p>循环等待条件可通过定义资源类型的线行顺序来预防，若一个进程分配了R类型的资源，则接下来请求的资源只能是排在R类型之后的资源</p>
<p>类似占有且等待的预防方法，循环等待的预防方法是低效的，会使进程执行速度变慢，且在没必要的情况下拒绝资源访问</p>
<h4 id="死锁避免">6.3 死锁避免</h4>
<p>死锁避免允许三个必要条件，但通过特定的选择，确保永远不会到达死锁点，死锁避免可允许更多的并发，死锁避免通过当前的资源分配采取措施，所以需要直到未来进程资源请求的情况</p>
<p>书本给出两种死锁避免方法：</p>
<ul>
<li>若一个进程的请求会导致死锁，则不启动该进程</li>
<li>若一个进程增加的资源请求会导致死锁，则不允许这一资源分配</li>
</ul>
<h5 id="进程启动拒绝">进程启动拒绝</h5>
<p>考虑 n 个进程和 m 种不同类型资源的系统，有以下定义：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_6/03.jpg" /></p>
<p>从中可以得知：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_6/04.jpg" /></p>
<h5 id="资源分配拒绝">资源分配拒绝</h5>
<p>资源分配拒绝策略，即<strong>银行家算法</strong>，定义了安全状态和不安全状态，进程请求一组资源时，查看同意此请求之后的状态，若还为安全状态，则分配资源，否则拒绝</p>
<ul>
<li>安全状态：至少有一个资源分配序列不会导致死锁</li>
<li>不安全状态：非安全的一个状态</li>
</ul>
<p>但在此处，不可能真的对所有资源分配序列进行探查，判断是否存在此分配序列，所以通常根据下面的关系式判断是否是安全序列：</p>
<p><span class="math inline">\(C_{ij} - A_{ij} \le V_j , 对所有的j\)</span></p>
<p>一个安全状态的例子：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_6/05.jpg" /></p>
<p><strong>死锁避免的优点</strong>：无须死锁预防的抢占和回滚进程，且与死锁预防相比限制较少</p>
<p><strong>死锁避免的限制</strong>：</p>
<ul>
<li>必须实现声明每个进程请求的最大资源</li>
<li>所讨论的进程必须是无关的，即它们的执行顺序必须没有同步要求的限制</li>
<li>分配的资源数量必须是固定的</li>
<li>在占有资源时，进程不能退出</li>
</ul>
<h4 id="死锁检测">6.4 死锁检测</h4>
<h5 id="死锁检测算法">死锁检测算法</h5>
<p>死锁预防策略非常保守，它们通过限制访问资源和进程上强加约束来解决死锁问题，而死锁检测不限制资源访问或约束进程行为，只要有可能就会给进程分配其所需要的资源，操作系统周期性的执行一个算法来检测前面的条件（4）（循环等待条件）</p>
<p>书本中死锁检测的算法，在之前定义的基础上还存在一个请求矩阵<span class="math inline">\(Q\)</span>，其中<span class="math inline">\(Q_{ij}\)</span>表示进程 <span class="math inline">\(i\)</span> 请求资源 <span class="math inline">\(j\)</span> 的数量，此算法主要是一个标记未死锁进程的过程，最初所有进程都是未标记的，然后执行以下步骤：</p>
<ol type="1">
<li>标记 Allocation 矩阵中一行全为零的进程</li>
<li>初始化一个临时向量 W，令 W等于 Available 向量</li>
<li>查找下标 i，使得对所有的<span class="math inline">\(1 \le k \le m, Q_{ik} \le W_k\)</span>，若找不到 i，终止</li>
<li>若找到这样的行，标记进程 i，并把 Allocation 矩阵中的相应行加到 W 中，即对所有的 <span class="math inline">\(1\le k \le m, 令 W_k += A_{ik}\)</span>，返回步骤3</li>
</ol>
<h5 id="死锁恢复">死锁恢复</h5>
<p>检测到死锁后就需要某种策略来恢复死锁，下面为按复杂度递增的顺序列出可能的方法：</p>
<ol type="1">
<li>取消所有的死锁进程，操作系统最常采用的方法</li>
<li>把每个死锁进程回滚到前面定义的某些检查点，并重新启动</li>
<li>连续取消死锁进程直到不存在死锁，所选取消进程的顺序基于某种最小代价原则，每次取消后重新检测是否存在死锁</li>
<li>连续抢占资源直到不存在死锁，和 3 一样依赖某种最小代价原则，一个资源被抢占的进程必须回滚到获得这个资源之前的某一状态</li>
</ol>
<p>对于（3）（4）可参考以下原则：</p>
<ul>
<li>目前为止小号的处理器时间最小</li>
<li>目前为止产生的输出最少</li>
<li>预计剩下的时间最长</li>
<li>目前位置分配的资源总量最少</li>
<li>优先级最低</li>
</ul>
<h4 id="一种综合的死锁策略">6.5 一种综合的死锁策略</h4>
<p>以上解决死锁的策略都各有优缺点，所以操作系统可以在不同的情况下使用不同的策略</p>
<ul>
<li>把资源分成几组不同的资源类</li>
<li>为预防在资源类之间由于循环等待产生死锁，采用前面的线性排序策略</li>
<li>在一个资源类中，使用该类资源最适合的算法</li>
</ul>
<p>其中资源可分为：</p>
<ul>
<li><strong>可交换空间</strong>：进程交换所用外存中的存储块</li>
<li><strong>进程资源</strong>：可分配的设备、如磁带设备和文件</li>
<li><strong>内存</strong>：可按页或段分配给进程</li>
<li><strong>内部资源</strong>：诸如 I/O 通道</li>
</ul>
<p>在每一类资源中，可采取一下策略确定次序：</p>
<ul>
<li><strong>可交换空间</strong>：要求一次性分配所有请求资源预防死锁</li>
<li><strong>进程资源</strong>：死锁避免通常是有效的，因为进程可以实现声明所需要的资源，采用资源排序的预防策略也是可能的</li>
<li><strong>内存</strong>：对于内存。基于抢占的预防是最适合的策略，当一个进程被抢占后，它被换到外村，释放空间可以解决死锁</li>
<li><strong>内部资源</strong>：可以使用基于资源排序的预防策略</li>
</ul>
<h4 id="哲学家就餐问题">6.6 哲学家就餐问题</h4>
<p>有五位哲学家，他们的就餐在一张圆桌上，圆桌上有5个盘子，盘子之间有一把叉子，每位想吃饭的哲学家就餐时使用盘子两侧的叉</p>
<p>为避免死锁的风险，可再买5把叉子，另一种方法是只允许四位哲学家同时进入餐厅，由于最多有4位哲学家就座，因而至少有一位哲学家可以拿到两把叉子</p>
<p>两种方案的解决代码如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_2/c_6/06.jpg" /></p>
<h2 id="第三部分-内存">第三部分 内存</h2>
<h3 id="第七章-内存管理">第七章 内存管理</h3>
<hr />
<p>在单道程序设计系统中（本书主要讨论单道），内存划分为两部分</p>
<ul>
<li>操作系统专用</li>
<li>提供“用户”进程使用</li>
</ul>
<p>简单的内存管理术语：</p>
<ul>
<li>页框：<strong>内存</strong>中固定长度的块</li>
<li>页：<strong>固定长度的数据块</strong>，存储在二级存储中，可以临时复制到内存的页框中</li>
<li>段：<strong>变长数据块</strong>，存储在二级存储中，整个段临时复制到内存中（分段），或将段变为页，然后单独将每页复制到内存中（分段、分页相结合）</li>
</ul>
<h4 id="内存管理的需求">7.1 内存管理的需求</h4>
<h5 id="重定位">重定位</h5>
<p>为了使处理器利用率最大化，程序换出到磁盘后，下次换入到换出之前的内存区域很困难，相反，我们需要把进程重定位到内存的不同区域。这样就会带来寻址的问题。处理器<strong>硬件</strong>和<strong>操作系统软件</strong>必须能以某种方式把程序代码中的内存访问转换为实际的物理内存地址，并反映程序在内存中的当前位置。</p>
<h5 id="保护">保护</h5>
<p>每个进程都应受到保护，以免其他进程有意或无意地干扰。</p>
<p>通常用户进程不能访问操作系统的任何部分，无论是程序还是数据。此外，一个进程中的程序通常不能跳转到另一个进程中的指令，若无特别许可，一个进程的程序不能访问其他进程的数据区。</p>
<p>内存保护需求必须由<strong>处理器（硬件）</strong>而非操作需要（软件）来满足，因为操作系统不能预测程序可能产生的所有内存访问，即使可以预测检查也非常费时。</p>
<h5 id="共享">共享</h5>
<p>任何保护机制都必须具有一定的灵活性，以允许多个进程访问内存的同一部分。内存管理系统在不损害基本保护的前提下，必须允许对内存共享区域进行受控访问。</p>
<h5 id="逻辑组织">逻辑组织</h5>
<p>计算机系统的内存和外存总是被组织成<strong>线性的地址空间</strong>。大多数程序被组织成模块，某些模块是不可修改的，若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来许多好处：</p>
<ol type="1">
<li>可以独立地编写和编译模块</li>
<li>通过适度的额外开销，可以为不同的模块提供不同的保护级别</li>
<li>可以引入某种机制，使得模块被多个进程共享</li>
</ol>
<p>最易于满足这些需求的根据是<strong>分段</strong></p>
<h5 id="物理组织">物理组织</h5>
<p>计算机系统分为两级，内存和外存，内存提供快速的访问，成本高，易失性；外存较慢且便宜，非易失性。</p>
<p>在这种两级方案中，系统主要关注的是内存和外存之间信息流的组织，组织这一信息流是由系统负责的，而不能由程序员负责。</p>
<h4 id="内存分区">7.2 内存分区</h4>
<p>内存管理的主要操作是处理器把程序装入内存中执行，内存管理技术由以下几种：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_7/01.jpg" /></p>
<h5 id="固定分区">固定分区</h5>
<p>管理用户内存空间的最简方案就是对它分区，以形成若干边界固定的区域</p>
<p>分区大小：</p>
<ul>
<li>大小相等的分区</li>
<li>大小不等的分区</li>
</ul>
<p><strong>内部碎片</strong>：装入的数据块小于分区大小，因而导致分区内部存在空间浪费，这种现象称为内部碎片</p>
<p><strong>放置算法</strong>：</p>
<p>对于大小相等的分区，只需要把每个进程分配到能够容纳它的最小分区中，每个分区都需要维护一个调度队列，用于保存从这个分区换出的进程</p>
<p>对于大小不等的分区，也可以采取上面这种方式，对于单个分区来说是最优的，可以达到最小的内部碎片，但是从整个系统看不是最佳的，小内存的进程可能被阻塞即使有大的空闲分区，所以一种更可取的方式是为所有的进程只提供一个队列。如果所有都被占据，则必须进行交换，一般优先考虑一些诸如优先级之类的其他因素，或者优先选择换出阻塞的进程而非就绪进程</p>
<p>固定分区方案简单，但存在以下缺点：</p>
<ul>
<li>分区的数量在系统生成阶段已经确定，因而限制了系统中活动进程的数量</li>
<li>分区的大小是在系统生成阶段实现设置的，因而小作业不能有效地利用分区空间</li>
</ul>
<h5 id="动态分区">动态分区</h5>
<p>对于动态分区，分区长度和数量是可变的，进程装入内存时，系统会给他分配一块与其所需容量完全相等的内存空间，动态分区方法会在内存中形成许多小空洞（外部碎片），内存利用率随之下降</p>
<p>克服外部碎片的一种方法是<strong>压缩</strong>，操作系统不时地移动进程，使得进程占用的空间连续，使得所有空闲空间连成一片。</p>
<p>压缩是一个非常耗时的过程，另外，压缩需要动态重定位的能力，能够把程序从内存的一块区域移动到另一块区域，且不会使程序中的内存访问无效</p>
<p><strong>放置算法</strong>：</p>
<p>可供考虑的放置算法有三种：</p>
<ul>
<li><strong>最佳适配：</strong>选择大小最接近的块，性能较差</li>
<li><strong>首次适配：</strong>从头开始扫描，选择大小足够的第一个可用块，通常是最简单有效的</li>
<li><strong>下次适配：</strong>从上一次放置的位置开始，选择下一个可用块，较首次适配差，常常会在内存的末尾分配空间，导致末尾的 最大空闲存储块很快分裂为小碎片，因此可能会需要更多的压缩</li>
</ul>
<h5 id="伙伴系统">伙伴系统</h5>
<p>伙伴系统中内存块大小为 <span class="math inline">\(2^K\)</span> 个字，<span class="math inline">\(L \le K \le U\)</span>，<span class="math inline">\(2^L\)</span> 表示分配的最小快尺寸，<span class="math inline">\(2^U\)</span> 表示分配的整个内存的大小，伙伴系统简单来说就是，给定大小为 <span class="math inline">\(2^i\)</span> （i为不小于此进程大小的最小整数），然后寻找一个大小为 <span class="math inline">\(2^i\)</span> 的空闲块，每个大小为 <span class="math inline">\(2^i\)</span> 的块都有维护列表，空闲块可以由对半分裂从大小为 <span class="math inline">\(2^{i+1}\)</span> 的列表移出，并在 <span class="math inline">\(2^i\)</span> 列表中产生两个伙伴，当 <span class="math inline">\(2^i\)</span> 列表一对伙伴都未分配时，则合并移入到 <span class="math inline">\(2^{i+1}\)</span> 中，可以由下面算法找到一个 <span class="math inline">\(2^i\)</span> 大小的空闲块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hole</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == U+<span class="number">1</span>) &lt;failure&gt;;</span><br><span class="line">    <span class="keyword">if</span>(&lt;i_list empty&gt;) &#123;</span><br><span class="line">        get_hole(i+<span class="number">1</span>);</span><br><span class="line">        &lt;split hole into buddies&gt;;</span><br><span class="line">        &lt;<span class="built_in">put</span> buddies on i_list&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;take first hole on i_list&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_7/02.jpg" /></p>
<p>释放B后的二叉树：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_7/03.jpg" /></p>
<h5 id="重定位-1">重定位</h5>
<p>在内存中放置进程需要的一种技术。进程在重新换入到内存后其地址是不确定的，所以需要<strong>逻辑地址</strong>和<strong>物理地址</strong>的转换</p>
<ul>
<li>逻辑地址：与物理分配地址无关的地址</li>
<li>相对地址：逻辑地址的特例，相对已知点的存储单元</li>
<li>物理地址：在内存中的实际位置</li>
</ul>
<p>重定位的硬件支持如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_7/04.jpg" /></p>
<h4 id="分页">7.3 分页</h4>
<p>将内存和进程都划分为大小固定，相等且比较小的块，在进程中的称为页，在内存中的称为页框。使用分页技术，每个进程在内存中浪费的空间，仅是基础最后一页一小部分形成的内部碎片，没有外部碎片。</p>
<p>他和固定分区不同的是：<strong>采用分页技术的分区相当小，一个程序可以占据多个分区，并且这些分区不需要是连续的</strong>。</p>
<p>实现上述的方法之一是，每个进程维护一个<strong>页表</strong>，页表给出了该进程每页对应页框的位置。在程序中，每个逻辑地址包括一个页号和该页中的偏移量。</p>
<p>为了使分页方案更加方便，<strong>规定页和页框的大小必须是2的幂，以便容易地表示出相对地址</strong>，有以下两个好处：</p>
<ol type="1">
<li>逻辑地址方案对编程者、汇编器和链接是透明的，程序每个逻辑地址与其相对地址是一致的</li>
<li>用硬件实现允许时动态地址转换比较容易。考虑一个 n+m 位地址，最左边的 n 位是页号，最右边的 m 位是偏移量，地址转换经过以下步骤：
<ul>
<li>提取页号，即逻辑地址左侧 n 位</li>
<li>以这个页号为索引，查找进程页表中对应的页框号 k</li>
<li>页框的起始物理地址为 <span class="math inline">\(k\times 2^m\)</span>，被访问字节的物理地址是这个数加上偏移量。可以简单地把偏移量附加到页框号后面来构建物理地址。</li>
</ul></li>
</ol>
<p>简单分页的图形表示如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_7/05.jpg" /></p>
<h4 id="分段">7.4 分段</h4>
<p>采用分段技术，可以把程序和与其相关的数据划分到几个段，尽管段的最大长度有限制的，但不要求长度都相等，和分页一样，其逻辑地址由段号和偏移量组成。</p>
<p>同样会产生外部碎片，但是由于块可以设置的很小所以外部碎片也很小，分段也不要求分区是连续的。</p>
<p>分页对程序员是透明的，<strong>分段则是可见的</strong>。为实现模块化设计，程序或数据分段或进一步分段。</p>
<p>采用大小不等的段的另一个结果是，逻辑地址和物理地址不再是简单的对应关系，在简单的分段方案中，每一个进程都有一个<strong>段表</strong>，系统也会维护一个内存中的空闲块列表，段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。</p>
<p>考虑一个 n+m 位的地址，左侧n位是段号，右侧m位是偏移量，进行地址转换有以下步骤：</p>
<ol type="1">
<li>提取段号，即左侧n位</li>
<li>以这个段号为索引，查找进程段表中该段的起始物理地址</li>
<li>最右侧m位，表示偏移量，若偏移量大于段长度则该地址无效</li>
<li>物理地址为该段起始物理地址与偏移量之和</li>
</ol>
<p>简单分段的图形表示：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_7/06.jpg" /></p>
<p>这里讨论的还是<strong>简单分页和简单分段，进程必须把所有全部加载到内存中</strong>，如果采用了覆盖或者虚存技术，则可以部分加载内存中，这部分在下一章讨论。</p>
<p><a href="https://blog.csdn.net/dongyanxia1000/article/details/51425141" target="_blank" rel="noopener"><strong>覆盖：</strong></a>所谓<strong><em>覆盖</em></strong>，就是把一个大的程序划分为<strong>一系列覆盖</strong>，每个覆盖就是一个相对独立的程序单位，<strong>把程序执行时并不要求同时装入内存的覆盖组成一组，称为覆盖段</strong>。<strong><em>一个覆盖段内的覆盖共享同一存储区域</em>，</strong>该区域成为覆盖区，它与覆盖段一一对应。显然，为了使一个覆盖区能为相应覆盖段中的每个覆盖在不同时刻共享，其大小应<strong><em>由覆盖段中的最大覆盖</em></strong>来确定。</p>
<h3 id="第八章-虚拟内存">第八章 虚拟内存</h3>
<hr />
<p>简单的虚拟内存相关定义：</p>
<ul>
<li><p><strong>虚拟内存</strong>：</p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。</p></li>
<li><p><strong>虚拟地址</strong>：</p>
<p>在虚拟内存中分配给某一位置的地址，使得该位置可被访问，如同内存</p></li>
<li><p><strong>虚拟地址空间</strong>：分配某进程的虚拟存储</p></li>
<li><p><strong>地址空间</strong>：用户某进程的内存地址范围</p></li>
<li><p><strong>实地址</strong>：内存中存储位置的地址</p></li>
</ul>
<h4 id="硬件和控制结构">8.1 硬件和控制结构</h4>
<p>分页和分段存在着这样的特点：</p>
<ul>
<li><strong>进程中所有的内存访问都是逻辑地址。</strong>意味着一个进程可被换入或换出内存，因此进程可在执行过程中的不同的时刻占据不同区域</li>
<li><strong>一个进程可划分为许多块，执行中不需要连续的位于内存中。</strong>页表和段表的使用保证这一特点</li>
</ul>
<p>这样的特点可以使得一个进程在执行的过程中，<strong>该进程不需要所有页或段都在内存中</strong>，只需要在内存保存下一条指令所在块，以及将访问的数据块即可。（这里的块都代表页或段）</p>
<p>进程执行过程中任何时刻都在内存中的部分称为进程的<strong>常驻集（resident set）</strong>，只要所有的内存访问都是常驻集中的单元，执行就可以顺利进行，并且处理器可以判断是否如此。当访问一个不再内存中（驻留集）的逻辑地址，会产生一个中断，操作系统会将此进程置于<strong>阻塞态</strong>，为此操作系统产生一个<strong>磁盘I/O读请求</strong>，在执行此I/O期间，操作系统可以调度另一个进程运行，在读入内存后（按某种置换策略），产生一个I/O中断，操作系统则将原来被阻塞的进程置为<strong>就绪态</strong>。</p>
<p>内存又称为<strong>实存储器</strong>，简称实存，但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，称为<strong>虚拟内存（virtual memory）</strong>，简称虚存。虚存支持更有效的系统并发度，解除用户与内存之间没有必要的紧密联系。</p>
<p>分页和分段的特点：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/01.jpg" /></p>
<h5 id="局部性和虚拟内存">局部性和虚拟内存</h5>
<hr />
<p>虚拟内存的开销收到<strong>系统抖动（thrashing）</strong>的影响。在虚存的机制下操作系统读取一块到内存，通常要将另一块换出，如果这块正好在将要用到之前换出，操作系统不得不很快的将他收回，会<strong>导致处理器大部分的时间都用于交换快而非执行指令</strong>。</p>
<p>避免系统抖动的算法都根据最近的历史来猜测将来最可能用到的块。这类推断基于<strong>局部性原理</strong>（一个进程中程序和数据引用的集簇倾向）</p>
<p>局部性原理表明虚存方案是可行的，要使虚存比较实用且有效，需要两方面因素：</p>
<ol type="1">
<li>必须有对分页或分段方案的硬件支持</li>
<li>操作系统必须有管理页或段在内存和辅存之间移动的软件</li>
</ol>
<h5 id="分页-1">分页</h5>
<hr />
<blockquote>
<p>主要有二级页表、倒排页表、转换检测缓冲区等结构</p>
</blockquote>
<p>虚存分页和简单分页一样都有页表，其中<strong>页表项（Page Table Entry，PTE）</strong>相比简单分页也多了一些内容，如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/02.jpg" /></p>
<p>其中的 <strong>P</strong> 表示它所对应的页当前是否在内存中，如果在内存中，则还包括页框号，另一位是<strong>修改位（M）</strong>表示相应的内容装入内存后是否发生变化，若没有改变则无需重新写入辅存，负责需要用该页更新原来的页。</p>
<p>同简单分页类似，逻辑地址依然由页号和偏移量组成，而物理地址由页框号和偏移量组成，页表的长度基于进程长度的变化而变化，以下给出了一种硬件实现：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/03.jpg" /></p>
<p>上述页表的简单处理在虚存空间大的时候会导致页表项的也十分大，一种解决方案是在虚存中保存页表，着以为着<strong>页表和其他页一样服从分页管理</strong>，一个进程在运行时，它的页表至少有一部分在内存中，这一部分包括正在运行的页的页表项，有一种<strong>两级层次页表结构</strong>来组织大型页表，典型情况如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/04.jpg" /></p>
<p>以上是32位地址两级方案的例子，假设采用字节级寻址，页尺寸为 <span class="math inline">\(4KB (2^{12})\)</span> ,则<span class="math inline">\(4GB (2^{32})\)</span>虚拟地址空间由<span class="math inline">\(2^{20}\)</span>页组成，若这些页的每一页都由一个4字节的页表项映射，则可创建由<span class="math inline">\(2^{20}\)</span>页表项组成的页表，这时需要<span class="math inline">\(4MB(2^{22})\)</span>的内存空间。这个由<span class="math inline">\(2^{10}\)</span>页组成的巨大用户页表可以保留在虚存中，并由一个包括<span class="math inline">\(2^{10}\)</span>个页表项的根页表映射，根页表占据的内存为<span class="math inline">\(4KB(2^12)\)</span>，二级页表的地址转换如下图：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/05.jpg" /></p>
<hr />
<p>即使是二级页表，页表大小与虚拟地址空间的大小成正比，可以使用<strong>倒排页表</strong>替代这种结构，称为“倒排”的原因是，它使用页框号而非虚拟页号来索引页表项，它的大小是固定的，在虚存空间特别大的时候开销比多级页表少。</p>
<p>在这种方法中，虚拟地址的页号部分使用一个散列函数映射到散列表中。散列表包含指向倒排表的指针，而倒排表中含有页表项，页表项包含以下内容：</p>
<ul>
<li><strong>页号</strong>：虚拟地址的页号部分</li>
<li><strong>进程标识符</strong>：使用该页的进程，页号和标识符确定一个特定进程的一页</li>
<li><strong>控制位</strong>：包含一些标记，如有效，访问，修改和锁定信息</li>
<li><strong>链指针</strong>：以为散列函数可能会将多个值散列到一个区域，所以存在链（下一项的索引值）</li>
</ul>
<p>下图是一个n位页号m位数索引倒排表的页表结构图：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/06.jpg" /></p>
<hr />
<p>每次虚存访问都可能会引起两次物理内存访问：</p>
<ul>
<li>取相应的页表项</li>
<li>取需要的数据</li>
</ul>
<p>因此简单的虚拟内存方案会导致内存访问时间加倍，为克服这个问题，可以采用<strong>转换检测缓冲区（Translation Lookaside Buffer，TLB）</strong>（一个特殊的高速缓存，包含最近用过的页表项）。给定一个虚拟地址，处理器首先检查TLB，若需要的页表项在其中，则检索页框号形成实地址，若未找到则使用页号检索检查页表。然后查看其”存在位“状态，若不在内存中，则会产生一次内存访问故障，称为<strong>缺页（page fault）</strong>中断，此时由操作系统负责装入所需要的页，并更新页表。基本机理如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/07.jpg" /></p>
<p>TLB使用流程如下，图中未显示磁盘I/O过程中可以调度另外进程执行。根据局部性原理大多数虚存访问都位于最近使用过的页中，所以此方案可以提高性能。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/08.jpg" /></p>
<p>TLB的实际组织还有许多额外细节，由于TLB仅包含整个页表中的部分表项，因此不能简单地把页号编入TLB的索引，所以TLB的项必须包含页号和完整的页表项（和倒排表一样），这两种技术对应直接映射（索引）和关联映射，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/09.jpg" /></p>
<p>虚存机制须与高速缓冲系统（内存高缓）进行交互。首先，内存系统查看TLB是否存在匹配的页表项，若不存在则从页表中读取页表项。产生一个TAG标记和其余部分组成的实地址后，查看高速缓存中是否存在，若有则返回给CPU，若没有，则从内存中检索这个字。若被访问的字在磁盘中，则包含该字的页必须装入内存，且所在的块须装入高速缓存，且其页表项必须更新。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/10.jpg" /></p>
<hr />
<p>页尺寸是一个重要的硬件设计决策，页越小，内部碎片总量越少；另一方面，页越小，每个进程需要的页数量越多，页表也会变得更大。大页表不容易存储(二级页表)会导致产生两次缺页中断（读取页表，读取页），但大页表又利于数据块传送。大体来说，<strong>缺页率</strong>和<strong>页尺寸</strong>和分配的<strong>页框数</strong>有关系。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/11.jpg" /></p>
<p>页尺寸的设计问题还与物理内存大小和程序大小有关。</p>
<h5 id="分段-1">分段</h5>
<hr />
<p>分段组织与非段式有许多优点：</p>
<ol type="1">
<li>简化了对不断增长的数据结构的处理</li>
<li>允许程序独立地改变或重新编译</li>
<li>有助于进程间的共享</li>
<li>有助于保护</li>
</ol>
<p>类似的虚存分段和简单分段一样也为每个进程维护一个段表，段表项包含存在位和修改位，以及该段的起始地址和长度。分段的地址转换如下图：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/12.jpg" /></p>
<hr />
<h5 id="段页式">段页式</h5>
<p>分段和分页各有所长，在段页式系统中，用户地址空间被程序员划分为许多段，每段划分为和内存页框大小相同的页。逻辑地址仍然由段号和偏移量组成，段偏移量可视为指定段中的页号和页偏移量。其地址转换如下图：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/13.jpg" /></p>
<h4 id="操作系统软件">8.2 操作系统软件</h4>
<p>操作系统内存管理设计取决于三个基本的选择：</p>
<ul>
<li>是否使用虚存技术</li>
<li>是使用分页还是分段，或同时使用两者</li>
<li>为各种存储管理特征采用的算法</li>
</ul>
<p>前两者取决于所用的硬件平台（当前计算机主流提供了虚存的支持，且纯分段的系统也越来越少，<strong>结合分段分页后操作系统内存管理问题都是面向分页的</strong>）第三个就是操作系统软件领域的问题，也是本节所述。</p>
<p>虚拟内存的操作系统策略：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/14.jpg" /></p>
<p>上表不存在一种绝对的最佳策略，<strong>在所有的策略中都要做到通过适当的安排，使得一个进程在执行时，访问一个未命中的页中的字的概率最小</strong>。</p>
<h5 id="读取策略">读取策略</h5>
<hr />
<p>读取策略决定某页何时取入内存，常用的两种方法是请求分页和预先分页</p>
<ul>
<li><strong>请求分页（demand paging）</strong>：只有当访问到某页中的一个单元时才将该页取入内存，开始缺页率高由于局部性原理之后缺页率会逐渐减少</li>
<li><strong>预先分页（prepaging）</strong>：利用大多数辅存设备的寻道时间和合理的延迟，一次读取多个连续的页，如果额外读取的页没有使用到，则低效</li>
</ul>
<h5 id="放置策略">放置策略</h5>
<hr />
<p>在纯分段系统中，放置策略并不是重要的设计问题（最佳适配、首次适配等均可）<strong>对于分页和段页式系统，如何放置通常无关紧要，以为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能</strong></p>
<h5 id="置换策略">置换策略</h5>
<hr />
<p>置换策略涉及到的问题有：</p>
<ul>
<li>给每个活动进程分配多少页框</li>
<li>计划置换的页集是局限于哪些产生缺页中断的进程还是所有页框都在内存中的进程</li>
<li>在计划置换的页集中，选择换出哪一页</li>
</ul>
<p>前两个为驻留集管理，之后讨论，置换策略专指第三个概念</p>
<p><strong>页框锁定</strong>：注意的是对于被锁定的页框，则不能被用于置换，锁定是给每个页框关联一个锁定位实现的，可以包含在页框表和当前的页表中</p>
<p>基本算法有：</p>
<ul>
<li><p><strong>最佳（Optimal，OPT）</strong>：</p>
<p>选择置换下次访问距当前时间最长的那些页，这种方法是最优的，但是操作系统必须直到将来的事件，因此不可能实现，仅作为一种衡量标准</p></li>
<li><p><strong>最近最少使用（Least Recently Used，LRU）</strong>：</p>
<p>置换内存中最长时间未被引用的页，根据局部性原理，这也是最近最不可能访问到的页，其性能接近OPT策略，但较难实现，开销大</p></li>
<li><p><strong>先进先出（First In First Out，FIFO）</strong>：</p>
<p>将分配给进程的页框视为一个循环缓冲区，并按循环方式移动页，需要一个指针在页框中循环，这种策略实际是置换驻留在内存时间最长的页，但通常导致频繁的换入换出页</p></li>
<li><p><strong>时钟（CLock）</strong>：</p>
<p>最简单的时钟策略给每个页框附加一个使用位，每当该页装入内存，或被访问时使用位置为1，并有一个指针与之相关联，当一页被置换时，该指针指向位下一个页框。需要置换一页时，操作系统扫描缓冲区，查找一个使用位为0的页框，扫描过程中遇到使用位为1时，将其置为0。</p></li>
</ul>
<p>四种方法的比较：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/15.jpg" /></p>
<p>对固定页框数量且为局部页面置换，有如下关系：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/16.jpg" /></p>
<p>一种更有效的时钟算法采取了<strong>使用位和修改位</strong>，此时每个页框状态有：</p>
<ul>
<li>最近未被访问，也未被修改 (u = 0; m = 0)</li>
<li>最近被访问，但未被修改 (u = 1; m = 0)</li>
<li>最近未被访问，但被修改 (u = 0; m = 1)</li>
<li>最近被访问，且被修改 (u = 1; m = 1)</li>
</ul>
<p>此时的时钟算法执行过程如下：</p>
<ol type="1">
<li>从指针的当前位置开始扫描缓冲区，选择遇到的第一个 (u = 0; m = 0) 用户置换</li>
<li>若第一步失败，则重新扫描，查找 (u = 0; m = 1) 的页框，选择第一次遇到的用于置换，在这一扫描过程中将每个跳过的页框的使用位置为0</li>
<li>若第2步失败，则指针回到最初的位置，且集合中所有页框的使用位均为0，重复第1步，并在必要时重复第二步，直到寻找到可用于置换的页框</li>
</ol>
<p>此策略查找自被取入至今未被修改且未访问的页，由于未被修改，则不需要写回辅存。</p>
<p>还有一种称为<strong>页缓冲</strong>的方法允许使用较简单的页面置换策略（FIFO）。这种算法不丢弃置换出的页而是分配到两个表中（不移动页移动对应的页表项）：</p>
<ol type="1">
<li>若未被修改，分配到空闲链表中</li>
<li>若已被修改则分配到修改页链表中</li>
</ol>
<p>这种方法的特定是，<strong>被置换的页仍然留在内存中</strong>，若进程访问该页，则可迅速返回该进程的驻留集且代价很小，实际上就是充当了高速缓存的角色</p>
<h5 id="驻留集管理">驻留集管理</h5>
<hr />
<p>对于驻留集（操作系统给进程分配的内存空间）大小，需要考虑以下几个因素：</p>
<ul>
<li>分配给一个进程的内存越少，则驻留在内存中的进程数就越多。增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间</li>
<li>若一个进程在内存的页数较少，尽管有局部性原理，缺页率仍相对较高</li>
<li>给特定进程分配的内存空间超过一定大小后，由于局部性原理，改进程的缺页率没有明显的变化</li>
</ul>
<p>当代操作系统通常采取两种策略：</p>
<ul>
<li><strong>固定分配策略</strong>：为一个进程在内存中分配固定数量的页框</li>
<li><strong>可变分配策略</strong>：允许分配给一个进程的页框在该进程的生命周期中不断的发生变化</li>
</ul>
<p>可变分配策略的难点在于要求操作系统评估活动进程的行为，会增加操作系统的软件开销</p>
<p>对于<strong>置换范围</strong>有局部和全局两类</p>
<ul>
<li><strong>局部置换策略</strong>：仅在产生这次缺页的进程的驻留页中选择</li>
<li><strong>全局置换策略</strong>：内存中所有未锁定的页都是置换目标</li>
</ul>
<p>置换范围和驻留集大小之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/17.jpg" /></p>
<p><strong>工作集策略</strong>：略</p>
<h5 id="清除策略">清除策略</h5>
<hr />
<p>清除策略用于确定何时将已修改的一页写回辅存，通常有两种选择：</p>
<ul>
<li><strong>请求式清除</strong>：只有当一页被选择用于置换时写回</li>
<li><strong>预约式清除</strong>：将已修改的多页在需要使用它们占据的页框之前成批写回</li>
</ul>
<p>完全使用一种策略都存在危险，预约式请求可能在写回后又发生更改，这样就没太大的意义，请求式则意味着写回修改页和读入新页，且读入在写回前，会降低处理器的利用率</p>
<p>一种较好的方法是结合<strong>页缓冲技术</strong>：只清除可用于置换的页，去除了清除和置换操作之间的成对关系，被置换页可放于修改表和未修改表。修改表中的页可以周期性的成批写出，并移到未修改表中。未修改表的一页要么被访问到而回收，要么在其页框分配给另一页时被淘汰。</p>
<h5 id="加载控制">加载控制</h5>
<hr />
<p>加载控制会影响到驻留在内存中的进程数量，着称之为系统并发度。如果驻留进程过少，那么所有进程都处于阻塞态概率就较大，因而许多时间花费在交换上。另一方面，进程过多，那么驻留集大小可能会不够用，会发生频繁的缺页中断，导致系统抖动</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_3/c_8/18.jpg" /></p>
<p>解决上述冲突，可以使用工作集策略或PFF算法。还有人提出了 L=S 准则，通过调整系统并发度，来使缺页中断之间的平均时间等于处理一次缺页中断所需的平均时间。这样处理器的利用率达到最大。</p>
<p>也可以采用时钟页面置换算法，监视该算法中扫描页框的指针循环缓冲区的速度。速度低于某个给定的最小阈值时，表明出现了如下的一种或两种情况：</p>
<ol type="1">
<li>很少发生缺页中断，因此很少需要请求指针前进</li>
<li>对每个请求，指针扫描的平均页框数很小，表明有许多驻留页未被访问到，且均易于被置换</li>
</ol>
<p>在上述情况下，系统并发度可以安全的增加，另一方面，指针扫描速度超过某个阈值，表明缺页率很高，要么难以找到可置换页，说明系统并发度过高</p>
<p>系统并发度减小时，一个或多个当前驻留进程须被挂起（换出），可根据以下标准换出进程：</p>
<ul>
<li><strong>最低优先级进程</strong>：实现调度策略决策，与性能无关</li>
<li><strong>缺页中断进程</strong>：原因在于很有可能是中断任务的工作集还未驻留，因而挂起它对性能的影响最小。此外，由于它阻塞了一个一定会被阻塞的进程，并且消除了页面置换和I/On操作的开销，可以立即收到成效</li>
<li><strong>最后一个被激活的进程</strong>：这个进程的工作集最有可能还未驻留</li>
<li><strong>驻留集最小的进程</strong>：在将来再次装入时的代价最小，不利于局部性较小的程序</li>
<li><strong>最大空间的进程</strong>：可在过来使用的内存中得到最多的空闲页框，使它不会很快又处于去活状态</li>
<li><strong>具有最大剩余执行窗口的进程</strong>：类似最短处理时间优先的调度原则</li>
</ul>
<h2 id="第四部分-调度">第四部分 调度</h2>
<h3 id="第九章-单处理器调度">第九章 单处理器调度</h3>
<hr />
<p>多道程序设计系统中，需要提高处理器处理效率，所以需要合理的调度策略以达到效率的最大化。多道程序涉及的关键就是调度，典型的调度类型有四种，处 I/O 调度外其他三种调度类型都属于处理器调度</p>
<ul>
<li><strong>长程调度</strong>：决定加入待执行进程池</li>
<li><strong>中程调度</strong>：决定加入部分或全部位于内存中的进程集合</li>
<li><strong>短程调度</strong>：决定处理器执行哪个可运行进程</li>
<li><strong>I/O调度</strong>：决定I/O设备处理哪个进程挂起的I/O请求</li>
</ul>
<p>长程调度和中程调度主要由于系统并发度相关的性能驱动，这些在前面的章节就讨论过</p>
<h4 id="处理器调度的类型">9.1 处理器调度的类型</h4>
<p>处理器调度的目的是，<strong>以满足系统目标（响应时间、吞吐率、处理器效率）的方式，把进程分配到一个或多个处理器上执行</strong>。</p>
<p>调度的层次结构以及进程状态和其所属调度种类如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/01.jpg" /></p>
<p>调度决定哪个进程须等待、哪个进程能继续运行，因此会影响系统的性能。本质上说调度属于队列管理，用于在排队环境中减少延迟并优化性能。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/02.jpg" /></p>
<h5 id="长程调度">长程调度</h5>
<hr />
<p>长程调度决定哪个程序可以进入系统中处理，因此它控制了系统的并发度。调度程序必须决定操作系统<strong>何时</strong>才能接纳一个进程或多个进程；同时，调度程序必须决定接受哪个作业或哪些作业，并将其转变为进程。</p>
<p>何时创建一个新进程，通常由要求的系统并发度驱动，下次允许哪个作业进入决策可基于简单的先来先服务（FCFS）原则，或者其他基于管理系统性能的根据。</p>
<h5 id="中程调度">中程调度</h5>
<hr />
<p>中程调度是交换功能的一部分。典型情况下，换入决定取决于管理系统并发度的需求，在不使用虚存的系统中，存储管理也是个问题。因此换入决策将考虑换出进程的存储需求。</p>
<h5 id="短程调度">短程调度</h5>
<hr />
<p>长程调度程序执行的频率相对较低。短程调度程序，也称为分派程序（dispatcher）执行最为频繁，精确的决定下次执行哪个进程。</p>
<p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序，包括：</p>
<ul>
<li>时钟中断</li>
<li>I/O 中断</li>
<li>操作系统调用</li>
<li>信号（如信号量）</li>
</ul>
<h4 id="调度算法">9.2 调度算法</h4>
<h5 id="短程调度规则">短程调度规则</h5>
<hr />
<p>短程调度的主要目标是按照优化系统一个或多个方面行为的方式，来分配处理器时间。</p>
<p>常用的规则可按两个维度来分类</p>
<ol type="1">
<li>面向用户的规则和面向系统的规则
<ul>
<li>面向用户的规则与单个用户或进程感知到的系统行为相关，例如交互式系统中的响应时间</li>
<li>面向系统则注重处理器使用的效果和效率，如吞吐量</li>
</ul></li>
<li>是否与性能直接相关维度
<ul>
<li>与性能直接相关，如响应时间和吞吐量</li>
<li>与性能无关，不易测量或者定性规则</li>
</ul></li>
</ol>
<p>下表总结了几种重要的调度规则，相互依赖，不可能同时达到最优，比如提供较好的响应时间可能需要调度算法在进程间频繁切换，但也会增加系统开销，降低吞吐量。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/03.jpg" /></p>
<h5 id="优先级的使用">优先级的使用</h5>
<hr />
<p>可以为每个进程指定一个优先级，调度程序总是优先选择具有较高优先级的进程，纯优先级调度方案可能导致低优先级进程可能会长期处于饥饿状态。可以让一个进程的优先级随时间或执行历史而变化，例如调度算法中的<strong>反馈</strong>法</p>
<h5 id="选择调度策略">选择调度策略</h5>
<hr />
<p>有以下三个参数：</p>
<ul>
<li><em>w</em>：目前为止在系统中的停留时间</li>
<li><em>e</em>：目前位置花费的执行时间</li>
<li><em>s</em>：进程所需的服务总时间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/04.jpg" /></p>
<ul>
<li><strong>非抢占</strong>：一旦进程处于运行状态，就会不断执行直到终止。进程要么因为等待I/O，要么因为请求某些操作系统服务而阻塞自己</li>
<li><strong>抢占</strong>：当前正运行进程可能被操作系统中断，并转换为就绪态</li>
</ul>
<p>与非抢占策略相比，抢占策略虽然会导致较大的开销，但能为所有进程提供较好的服务，因为它们避免了任何一个进程长时间独占处理器的情形。</p>
<p><strong>周转时间（turnaround time）</strong>：就是驻留时间 <span class="math inline">\(T_r\)</span> ，或这一项在系统中花费的总时间（等待时间+服务时间），另外有用的是归一化周转时间，为周转时间与服务时间的比值，<strong>表示一个进程的相对延迟情况</strong>。</p>
<p>下面是一个例子：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/05.jpg" /></p>
<p>调度策略的比较如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/06.jpg" /></p>
<p>各个策略的效率的简单度量：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/07.jpg" /></p>
<h5 id="先来先服务-fcfs">先来先服务 FCFS</h5>
<hr />
<p>FCFS 是长进程友好的，而且相对于I/O密集进程，更有利于处理器密集型进程，其他进程，FCFS可能导致处理器和I/O设备都未得到充分利用。</p>
<p>FCFS 自身对于单处理器系统而言并不是很有吸引力的选择，但它与优先级策略结合后通常能提供一种更有效的调度方法，如反馈。</p>
<h5 id="轮转-round-robin">轮转 Round Robin</h5>
<hr />
<p>根据<strong>时间片（time slicing）</strong>周期性的产生时钟中断，出现中断后将进程放置到就绪队列中，然后基于FCFS策略选择下一个就绪作业运行。</p>
<p>轮转法对处理器密集型进程和I/O密集进程的处理不同。处理器密集型进程在执行过程中通常会使用大部分处理器时间，导致I/O密集型进程性能降低，使用I/O设备低效，响应时间变化较大。</p>
<p>虚拟轮转法，这种方法可以避免上述不公平性，此方法的不同之处在于，接触了I/O阻塞的进程都会转移到一个FCFS辅助队列中。进行调度决策时，辅助队列中的决策优先于就绪队列中的进程，这种方法在公平性方面确实优于轮转法</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/08.jpg" /></p>
<h5 id="最短进程优先-shortest-process-next-spn">最短进程优先 （Shortest Process Next， SPN）</h5>
<hr />
<p>SPN是非抢占的，短进程友好的，SPN的难点在于需要直到或至少需要估计每个进程所需的处理时间。对于批处理作业，系统要求程序员给出估计值，若执行时间远高于实际运行时间，系统可能终止该作业。实际中操作系统可为每个进程保留一个运行平均值，计算方法如下： <span class="math display">\[
S_{n+1} = \frac{1}{n}T_n+\frac{n-1}{n}S_n \\
T_i:第i个实例的处理器执行时间 \\
S_i:第i个实例的预测值
\]</span> 这属于<strong>指数平均法</strong>的一种，SPN的风险在于，长进程可能饥饿。</p>
<h5 id="最短剩余时间shortest-remaining-timesrt">最短剩余时间（Shortest Remaining Time，SRT）</h5>
<hr />
<p>相当于是在SPN中增加了抢占机制的策略，和SPN一样，调度程序在执行选择函数的时候，必须具备关于处理时间的估计，并且具有长进程饥饿的风险。</p>
<p>SRT不像FCFS那样偏向长进程，也不像轮转法那样产生额外的中断，所以降低了开销。但是它必须记录过去的服务时间，又增加了开销，对于SPN，从周转时间上看，SRT性能更好，因为相当于一个正在运行的长作业而言，短作业可以立即选择执行。</p>
<h5 id="最高响应比优先-highest-response-ratio-nexthrrn">最高响应比优先 （Highest Response Ratio Next，HRRN）</h5>
<hr />
<p>调度规则见之前的对比图。HRRN偏向短作业（小分母产生大比值），长进程由于得不到服务等待的时间会不断增加，因此比值变大。所以是比较公平的。</p>
<h5 id="反馈法">反馈法</h5>
<hr />
<p>调度基于抢占原则（按时间片）并使用动态优先级机制。一个进程首次进入系统时，会放在<em>RQ0</em>中当它首次被抢占并返回就绪态时，会放在<em>RQ1</em>中，在随后的时间内，每当它被抢占就降级一次直到最低级。因此，新到的进程和短进程会优于老进程和长进程。这种方法称为<strong>多级反馈（Multilevel Feedback）</strong>。</p>
<p>但存在一个问题，可能会造成长进程的饥饿。可以按以下办法解决：</p>
<ol type="1">
<li>给低优先级的进程更多的时间片，一般而言，从<em>RQi</em>中调度的进程允许执行 <span class="math inline">\(q=2^i\)</span> 时间后被抢占</li>
<li>当一个进程在其队列等待服务的时间超过一定时间后，就把它提升到优先级高的队列中</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/09.jpg" /></p>
<h5 id="性能比较">性能比较</h5>
<hr />
<p>略</p>
<h5 id="公平共享调度-fair-share-scheduling">公平共享调度 （Fair-Share Scheduling ）</h5>
<hr />
<p>公平共享调度考虑了<strong>进程组</strong>调度的基本原则。每个用户（进程组）被指定了某种类型的权值，此<strong>权值定义了用户对系统资源的共享，而且是作为在所有使用资源中所占的比例来体现的，如处理器资源</strong>。</p>
<p>调度是根据优先级进行的，它会考虑三方面因素：</p>
<ol type="1">
<li>进程的基本优先级</li>
<li>近期使用处理器的情况</li>
<li>进程所在组近期使用处理器的情况</li>
</ol>
<p>优先级数值越大，所表示的优先级越低，适用于组<em>k</em>中进程<em>j</em>的公式如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_4/c_9/10.jpg" /></p>
<h2 id="第五部分-输入输出和文件">第五部分 输入/输出和文件</h2>
<h4 id="第十一章-io-管理和磁盘调度">第十一章 I/O 管理和磁盘调度</h4>
<hr />
<h4 id="io-设备">11.1 I/O 设备</h4>
<hr />
<p>计算机系统中参与I/O的外设可以分为以下三类：</p>
<ul>
<li><strong>人可读</strong>：适用于计算机用户间的交互，如打印机和终端</li>
<li><strong>机器可读</strong>：适用于电子设备通信，如磁盘驱动器</li>
<li><strong>通信</strong>：适用于远程设备通信，如调制解调器</li>
</ul>
<p>其中主要差别包括：</p>
<ul>
<li><strong>数据传送速率</strong></li>
<li><strong>应用</strong></li>
<li><strong>控制的复杂性</strong></li>
<li><strong>传送单位</strong>：字节流或者字符流的形式传送，也可按块</li>
<li><strong>数据表示</strong>：不同的数据编码方式</li>
<li><strong>错误条件</strong></li>
</ul>
<h4 id="io-功能的组织">11.2 I/O 功能的组织</h4>
<hr />
<p>执行I/O的三种技术：</p>
<ul>
<li><strong>程序控制I/O</strong>：无中断</li>
<li><strong>中断驱动I/O</strong>：中断</li>
<li><strong>直接存储器访问</strong>：中断，一个DMA模块控制内存和I/O模块之间的数据交换。传送一块数据，处理器给DMA模块发送请求，当整个模块传送结束后，它才被中断，<strong>只有传送的开始和结束才会使用处理器</strong></li>
</ul>
<p>可选的DMA配置如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_11/01.jpg" /></p>
<h4 id="操作系统设计问题">11.3 操作系统设计问题</h4>
<hr />
<p>两个最重要的目标：</p>
<ul>
<li><strong>效率</strong>：大多数I/O设备的速度非常低，进程交换本身就是I/O操作</li>
<li><strong>通用性</strong>：需要从两个方面统一：一是处理器看待I/O设备的方式，二是操作系统管理I/O设备和I/O操作的方式</li>
</ul>
<h5 id="io-功能的逻辑结构">I/O 功能的逻辑结构</h5>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_11/02.jpg" /></p>
<h4 id="io-缓冲">11.4 I/O 缓冲</h4>
<p>为避免多余的开销和低效操作，在输入请求发出前就开始执行输入传送，并且在输出请求发出一段时间后才开始执输出传送，这样的技术称为<strong>缓冲</strong>。</p>
<p>两类I/O设备：</p>
<ul>
<li><strong>面向块</strong>：将信息保存在块中，块的大小通常是固定的</li>
<li><strong>面向流</strong>：设备以字节流的方式输入输出数据</li>
</ul>
<p>I/O缓冲方案：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_11/03.jpg" /></p>
<p>缓冲的作用：</p>
<p><strong>缓冲是用来平滑I/O需求的峰值的一种技术</strong>，但在进程的平均需求大于I/O设备的服务能力时，再多的缓冲也无法让I/O设备与进程一直并驾齐驱。</p>
<p>在多道程序设计中，当存在多种I/O活动和多种进程活动时，<strong>缓冲是提高操作系统效率和单个进程性能的一种方法</strong></p>
<h4 id="磁盘调度">11.5 磁盘调度</h4>
<h5 id="磁盘性能参数">磁盘性能参数</h5>
<hr />
<p>磁盘驱动器工作时，磁盘以某个恒定的速度旋转，为了读或写，磁头必须定位于指定磁道和该磁道中指定扇区的开始处。磁头定位到磁道所需要的时间称为<strong>寻道时间</strong>，之后，磁盘控制器开始等待直到适当的扇区旋转到磁头处，这段时间称为<strong>旋转延迟</strong>，<strong>寻道时间和旋转延迟的总和为存取时间</strong>，这是达到读或写位置所需要的时间，之后便开始执行读操作或写操作，这段时间就是<strong>传输时间</strong>。</p>
<p>总平均存取时间包括上面的三个，可用公式表示 <span class="math display">\[
T_a = T_s + \frac{1}{2r}+\frac{b}{rN} \\
T_s 为平均寻道时间，b表示传输的字节数，N表示一个磁道的字节数，r表示旋转速度（转/秒）
\]</span> 时序比较的经典例子：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_11/04.jpg" /></p>
<h5 id="磁盘调度策略">磁盘调度策略</h5>
<hr />
<p>磁盘调度算法及其比较：</p>
<p>访问的磁道序列为：55、58、39、18、90、160、150、38、184</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_11/05.jpg" /></p>
<p>除此之外，还有<strong>基于优先级（PRI）</strong>和<strong>后进先出</strong>的算法</p>
<p><strong>基于优先级</strong>并不会优化磁盘的利用率，但能满足操作系统的其他目标。通常较短的批作业和交互作业的优先级较高，而较长计算时间的长作业优先级较低。对于数据库系统这类策略往往使得性能较差。</p>
<p><strong>后进先出</strong>在事务处理系统中，由于顺序读取文件，可减少磁壁的运动，可以提高吞吐量并缩短队列长度，但可能会导致饥饿。</p>
<h4 id="raid">11.6 RAID</h4>
<p>略</p>
<h4 id="磁盘高速缓存">11.7 磁盘高速缓存</h4>
<p>磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，包含磁盘中某些扇区的副本</p>
<p>进程从磁盘高速缓存中获取数据可以采取两种方式</p>
<ol type="1">
<li>在内存中把这一块数据缓存传送到用户进程的存储空间中</li>
<li>简单使用一个共享内存，传送指向磁盘告诉缓冲中响应的指针</li>
</ol>
<p>后一种方法节省了内存到内存的传输时间</p>
<p>对于<strong>置换策略</strong>可以以下两种：</p>
<ul>
<li><strong>最近最少使用（LRU）</strong>：置换在高速缓存中未被访问时间最长的块，可用一个栈完成</li>
<li><strong>最不常使用（LFU）</strong>：置换集合中访问次数最少的块</li>
</ul>
<p>简单的LFU不能判断那些整体很少访问但是近期访问频繁的块，可以使用LFU的改进版</p>
<p>使用分区，新区老区（中间区），对不同区的对应措施不同</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_11/06.jpg" /></p>
<h3 id="第十二章-文件管理">第十二章 文件管理</h3>
<p>典型情况下，文件管理系统由系统实用程序组成，它们可以作为具有特权的应用程序来运行。一般来说，整个文件管理系统都被当做操作系统的一部分</p>
<h4 id="概述">12.1 概述</h4>
<h5 id="文件和文件系统">文件和文件系统</h5>
<hr />
<p>文件有以下理想的属性：</p>
<ul>
<li>长期存在</li>
<li>可在进程间共享</li>
<li>结构</li>
</ul>
<p>文件的操作如下：</p>
<ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
</ul>
<h5 id="文件结构">文件结构</h5>
<hr />
<ul>
<li><strong>域</strong>：基本的数据单元，一个域包含一个值，域的长度是定长或者变长的，取决于文件的设计</li>
<li><strong>记录</strong>：是一组相关域的集合，可视为应用程序的一个单元</li>
<li><strong>文件</strong>：一组相似记录的集合，被用户和应用程序视为一个实体，并通过文件名访问</li>
<li><strong>数据库</strong>：一组相关数据的集合，数据元素间存在着明确的关系，且可供不同应用程序使用，数据库管理系统独立于操作系统</li>
</ul>
<p>文件系统架构：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/01.jpg" /></p>
<p>文件管理的要素：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/02.jpg" /></p>
<p>文件管理系统作为一个单独的系统实用程序和操作系统关注的是不同两方面的内容，之间的共同点是记录的处理。</p>
<h4 id="文件组织和访问">12.2 文件组织和访问</h4>
<p>在选择文件组织，有以下重要原则：</p>
<ul>
<li>快速修改</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性</li>
</ul>
<p>这些原则的优先级取决于将要使用这些文件的应用程序</p>
<p>基本文件组织：</p>
<ul>
<li><strong>堆</strong>：<strong>是简单的文件组织形式</strong>，数据按它们到达的顺序被收集，每条记录由一串数据组成。堆的目的仅是积累大量的数据并保存，对文件没有结构，使用穷举查找的方式进行，当数据难以组织或在初期前采集数据时会用到。</li>
<li><strong>顺序文件</strong>：<strong>是最常用的文件组织形式</strong>，每条记录都使用固定的格式，所有记录具有相同的长度，并由相同数量、长度固定的域按特定顺序组成。每条记录的第一个域通常是<strong>关键域</strong>，唯一的标识这条记录，性能很差，也可组织成链表的方式。</li>
<li><strong>索引顺序文件</strong>：用于克服顺序文件的缺点，增加了两个特征：用于支持随机访问的文件索引和溢出文件。索引顺序文件极大的减少了访问单条记录的时间，同时保留了文件的顺序特性，多级索引可以提供更有效的访问</li>
<li><strong>索引文件</strong>：索引顺序文件保留了顺序文件的一个限制：基于文件的一个域进行处理。当需要基于其他属性而非关键域查找一条记录时，这两种形式的顺序文件都无法胜任。索引文件采取多索引的结构，摒弃了顺序性和关键字的概念，只能通过索引来访问记录。对记录的位置不再有限制，还可使用长度可变的记录。</li>
<li><strong>直接或散列文件</strong>：直接访问磁盘中任何一个地址已知块的能力。直接文件使用基于关键字的散列，直接文件常在要求快速访问时使用，且记录的长度是固定的，通常一次访问一条记录。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/03.jpg" /></p>
<h4 id="文件目录">12.4 文件目录</h4>
<p>目录包含关于文件的信息，如属性、位置、所有权，都由操作系统管理。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/04.jpg" /></p>
<p>目录的结构通常是树状结构：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/05.jpg" /></p>
<h4 id="文件共享">12.5 文件共享</h4>
<p>文件共享会产生两个问题：<strong>访问权限</strong>和<strong>同时访问的管理</strong>。</p>
<p>访问权限有如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/06.jpg" /></p>
<p>话可以按面向用户分组：特定用户，用户组，全部</p>
<p>对于同时访问，必须解决互斥和死锁问题</p>
<h4 id="记录组块">12.6 记录组块</h4>
<p>记录是访问结构化文件的逻辑单元，而块是与辅存进行I/O操作的基本单位，为执行I/O，记录必须组织成块。</p>
<p>对于给定的块大小，有三种组块方法：</p>
<ul>
<li><strong>定长组块</strong>：使用定长的记录，且若干完整的记录保存在一个块中，块末尾可能会有未使用空间，称为内部碎片</li>
<li><strong>变长跨越式组块</strong>：使用变长的记录，并紧缩到块中，块中不存在未使用的空间，某些记录会跨越两个块，使用指针连接</li>
<li><strong>变长非跨越式组块</strong>：使用变长的记录，但不采用跨越方式，在大多数块中都会有未使用的空间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/07.jpg" /></p>
<p>定长组块是记录定产顺序文件最常用的方式，变长跨越式存储效率高，但难以实现。跨越两个块需要两次I/O操作，文件很难修改。变长非跨越式浪费空间，且存在记录大小不能超过块大小的限制。</p>
<h4 id="辅存管理">12.7 辅存管理</h4>
<p>在辅存中，文件是由许多块组成。操作系统负责为文件分配块。</p>
<h5 id="文件分配">文件分配</h5>
<hr />
<ul>
<li><strong>预分配</strong>：在发出创建文件的请求时，声明该文件的最大尺寸</li>
<li><strong>动态分配</strong>：只有在需要的时候才给文件分配空间</li>
</ul>
<p>对于分配给文件的<strong>分区大小</strong>，我们需要考虑下面四项内容：</p>
<ol type="1">
<li>邻近空间可以提高性能</li>
<li>数量较多的小分区会增加</li>
<li>使用固定大小的分区可以简化空间的再分配</li>
<li>使用可变大小的分区或固定大小的小分区，可减少超额分配导致未使用存储空间的浪费</li>
</ol>
<p>有以下两个选择：</p>
<ul>
<li><strong>大小可变的大规模连续分区</strong>：大小可变避免了浪费，且会使文件分配表较小，但着会导致空间很难再次利用</li>
<li><strong>块</strong>：小的固定分区能提供更大的灵活性，但为了分配，它们可能需要较大的表或更复杂的结构</li>
</ul>
<p>选择策略有：</p>
<ul>
<li>首次适配</li>
<li>最佳适配</li>
<li>最近适配</li>
</ul>
<h5 id="文件分配方法">文件分配方法</h5>
<hr />
<p><strong>连续分配</strong>：创建文件时，给文件分配一组连续的块。需要在创建文件时声明文件的大小，会出现外部碎片，所以需要紧缩算法</p>
<p><strong>链式分配</strong>：链式分配基于单个块，使用指针建立联系，不必担心外部碎片的出现，但是局部性原理不再适用，为了克服这个问题，有些系统会周期性的合并文件</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/08.jpg" /></p>
<p><strong>索引分配</strong>：解决了连续分配和链式分配中的许多问题。每个问价在文件分配表中都有一个一级的索引，分配给该文件的每个分区在索引中都有一个表项。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Operating-System-Internals-and-Design-Principles-8th/img/part_5/c_12/09.jpg" /></p>
<h5 id="空闲空间管理">空闲空间管理</h5>
<p>除了文件分配表外，还需要<strong>磁盘分配表（Disk Allocation Table，DAT）</strong></p>
<ul>
<li><strong>位表</strong>：使用一个向量值00111000标识空闲块，通过它能相对容易的找到一个或一组连续的空闲块，而且很小，但其长度仍然很长。</li>
<li><strong>链接空闲区</strong>：使用指向每个空闲区的指针和它们的长度值，链接在一起，开销很小。使用一段时间后，会出现许多碎片。删除一个由许多碎片组成的文件也非常耗时</li>
<li><strong>索引</strong>：索引方法把空闲空间视为一个文件，并使用一个索引表，索引基于可变大小的分区而非块</li>
<li><strong>空闲块列表</strong>：每块都指定一个序号，所有空闲块序号保存在磁盘的一个保留区中。</li>
</ul>
<p><strong>卷</strong>：一组分配在可寻址的扇区的集合，操作系统或应用程序用卷来存储数据。卷中的扇区在物理存储设备上不需要连续，只需要对操作系统或应用程序来说连续即可。卷可能由更小的卷合并或组合而成。最简单的情况下，一个单独的磁盘就是一个卷，通常一个磁盘会分为几个分区，每个分区都作为一个单独的卷来工作。</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Tutorial &amp; Note</category>
      </categories>
  </entry>
  <entry>
    <title>PAT Advanced 1003 Emergency（最短路）</title>
    <url>/2020/02/24/2020-02-24-PAT-Advanced-1003/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">题目地址<i class="fa fa-external-link"></i></span></p>
<a id="more"></a>
<p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6 0 2</span><br><span class="line">1 2 1 5 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 2</span><br><span class="line">0 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 4 1</span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h2 id="基本思路">基本思路</h2>
<p>开始以为是简单的最短路模板题，结果发现还是有点意思的，在简单的最短路的基础上更进一步，基础图论起手就是 Dijkstra。<a href="https://joke-lin.top/dsaa/2018/12/07/ShortestPath/">最短路基础算法 原地TP</a></p>
<p>和基础最短路不同的是，这里我们需要计算的是<strong>最短路的条数</strong>，以及这些最短路中<strong>节点权重和最大的值</strong>。可以作为其他类似题目的解题思路。</p>
<p>在基础的 Dijkstra 算法中我们每次更新对应点最短路当<strong>到此点距离</strong>小于<strong>到其相邻点距离</strong>与<strong>对应边权和</strong>，这样就保证每次都是“最短”了，显然最短路不只一条，那么何时可以判断有重复最短路。</p>
<p><img src="/assets/ArticleImg/2020/pat1003_01.jpg" style="zoom:50%;" /></p>
<p>简单来说 <span class="math inline">\(d[i]\)</span> 表示起始点到<em>i</em>点的最短路大小，到<em>C</em>点的最短路更新在 <span class="math inline">\(d[C] &lt; d[B] + cost\)</span> 的时候。我们使用 <span class="math inline">\(num[i]\)</span> 表示到<em>i</em>点最短路条数，此时到<em>C</em>的最短路只能是从点<em>B</em>过来，所以此时<em>C</em>的最短路数量就是<em>B</em>的最短路数量。 点<em>C</em>最短路条数增长仅当 <span class="math inline">\(d[B] + cost == d[C]\)</span> 时，这时候说明从<em>B</em>到<em>C</em>和<em>C</em>原来的最短路是一样的，所以我们需要把到<em>B</em>的最短路数量加给我们的<em>C</em>，得到新的最短路条数</p>
<p>代码表示如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新C点的最短路</span></span><br><span class="line"><span class="comment">// B为C的所有邻点</span></span><br><span class="line"><span class="keyword">for</span>(B in C_Neighbor) &#123;</span><br><span class="line">	<span class="keyword">if</span>(d[B]+cost &lt; d[C]) &#123;</span><br><span class="line">  		<span class="comment">// 此时更新最短路 通过B到C 所以C的最短路数量等于到B的最短路数量</span></span><br><span class="line">    	d[C] = d[B]+cost;</span><br><span class="line">        num[C] = num[B];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(d[B]+cost == d[C]) &#123;</span><br><span class="line">    	<span class="comment">// 从B方向来的路也是最短路 所以加上</span></span><br><span class="line">    	num[C] += num[B];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于最短路中的最大节点权值和则比较简单，当存在更短的路径时，更新对应点的权值和，当存在相同长度最短路时，比较两条路的节点权值和，取较大的，最后的逻辑代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新C点的最短路</span></span><br><span class="line"><span class="comment">// B为C的所有邻点</span></span><br><span class="line"><span class="comment">// sum[i] 表示i点的最短路径节点权值和最大值</span></span><br><span class="line"><span class="keyword">for</span>(B in C_Neighbor) &#123;</span><br><span class="line">	<span class="keyword">if</span>(d[B]+cost &lt; d[C]) &#123;</span><br><span class="line">  		<span class="comment">// 此时更新最短路 通过B到C 所以C的最短路数量等于到B的最短路数量</span></span><br><span class="line">    	d[C] = d[B]+cost;</span><br><span class="line">        num[C] = num[B];</span><br><span class="line">        sum[C] = sum[B] + weight[C]; <span class="comment">// weight[C] C节点的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(d[B]+cost == d[C]) &#123;</span><br><span class="line">    	<span class="comment">// 从B方向来的路也是最短路 所以加上</span></span><br><span class="line">    	num[C] += num[B];</span><br><span class="line">        <span class="keyword">if</span>(sum[C] &lt; sum[B] + weight[C]) &#123;</span><br><span class="line">            sum[C] = sum[B] + weight[C];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ac-代码">AC 代码</h2>
<p>注意其中对应数组<strong>变量的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;    <span class="comment">// P.first 为 起始点到 P.second 的最短路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, cost;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];   <span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];    <span class="comment">// 对应点的最短路</span></span><br><span class="line"><span class="keyword">int</span> team_num[maxn]; <span class="comment">// 每个城市对应点的救援队数量</span></span><br><span class="line"><span class="keyword">int</span> road_sum[maxn]; <span class="comment">// 最短路数量</span></span><br><span class="line"><span class="keyword">int</span> team_sum[maxn]; <span class="comment">// 节点最大权值和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="built_in">fill</span>(d, d+maxn, INF); d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fill</span>(road_sum, road_sum+maxn, <span class="number">0</span>);   <span class="comment">// 开始全部为 0</span></span><br><span class="line">    road_sum[s] = <span class="number">1</span>;    <span class="comment">// 起点到自己有1条路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, team_num+i);</span><br><span class="line">        team_sum[i] = team_num[i];  <span class="comment">// 都可以自己到自己，所以和team_num一样</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入图数据</span></span><br><span class="line">    <span class="keyword">int</span> t_s, <span class="keyword">t_t</span>, t_cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;t_s, &amp;<span class="keyword">t_t</span>, &amp;t_cost);</span><br><span class="line">        G[t_s].push_back(edge&#123;<span class="keyword">t_t</span>, t_cost&#125;);</span><br><span class="line">        G[<span class="keyword">t_t</span>].push_back(edge&#123;t_s, t_cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">    que.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        P t = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(d[t.second] &lt; t.first) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[t.second].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            edge e = G[t.second][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[t.second] + e.cost) &#123;</span><br><span class="line">                team_sum[e.to] = team_sum[t.second] + team_num[e.to];</span><br><span class="line">                road_sum[e.to] = road_sum[t.second];</span><br><span class="line">                d[e.to] = d[t.second] + e.cost;</span><br><span class="line">                que.push(make_pair(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[e.to] == d[t.second] + e.cost) &#123;</span><br><span class="line">                road_sum[e.to] += road_sum[t.second];</span><br><span class="line">                <span class="keyword">if</span>(team_sum[e.to] &lt; team_sum[t.second] + team_num[e.to]) &#123;</span><br><span class="line">                    team_sum[e.to] = team_sum[t.second] + team_num[e.to];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, road_sum[t], team_sum[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 05-08部分 从字符显示到中断处理</title>
    <url>/2020/02/09/2020-02-09-30OSMakeNote05-08/</url>
    <content><![CDATA[<h2 id="文字鼠标显示">1. 文字鼠标显示</h2>
<h3 id="a.-定义bootinfo结构体">a. 定义BOOTINFO结构体</h3>
<blockquote>
<p>这个结构体包含操作系统的基础信息</p>
</blockquote>
<a id="more"></a>
<p>结构体声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> cyls, leds, vmode, reserve;</span><br><span class="line">	short scrnx, scrny;</span><br><span class="line">	<span class="keyword">char</span> *vram;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; asmhead.nas</span><br><span class="line">; BOOT_INFO相关</span><br><span class="line">CYLS	EQU		0x0ff0			; 引导扇区设置</span><br><span class="line">LEDS	EQU		0x0ff1</span><br><span class="line">VMODE	EQU		0x0ff2			; 关于颜色的信息</span><br><span class="line">SCRNX	EQU		0x0ff4			; 分辨率X</span><br><span class="line">SCRNY	EQU		0x0ff6			; 分辨率Y</span><br><span class="line">VRAM	EQU		0x0ff8			; 图像缓冲区的起始地址</span><br><span class="line">		ORG		0xc200			;  这个的程序要被装载的内存地址</span><br><span class="line"></span><br><span class="line">; 画面设定</span><br><span class="line"></span><br><span class="line">		MOV		AL,0x13			; VGA显卡，320x200x8bit</span><br><span class="line">		MOV		AH,0x00</span><br><span class="line">		INT		0x10</span><br><span class="line">		MOV		BYTE [VMODE],8	; 屏幕的模式（参考C语言的引用）</span><br><span class="line">		MOV		WORD [SCRNX],320</span><br><span class="line">		MOV		WORD [SCRNY],200</span><br><span class="line">		MOV		DWORD [VRAM],0x000a0000</span><br></pre></td></tr></table></figure>
<p>作者没有对<code>BOOTINFO.reserve</code>说明，仔细看<code>asmhead.nas</code>可以发现VMODE只有一个字节的内容，但是<code>SCRNX</code>是从<code>0xff4</code>开始，中间有一个字节是没有做任何设定的，由此可以看出这一个字节的内容是暂时保留的。</p>
<p>启动信息的开始地址是0xff0，所以我们通过<code>struct BOOTINFO *binfo = (struct BOOTINFO *) 0x0ff0;</code>设置好我们的结构体。</p>
<h3 id="b.-字符和鼠标指针显示">b. 字符和鼠标指针显示</h3>
<p>简单来说，和之前我们绘制矩形一样的思路，整个屏幕都是就是一个<code>320*200</code>大小的一个画布，需要显示字符只要将对应位置置为一个颜色就可以了，如下</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Note/IMG/05_1.png" style="zoom:50%;" /></p>
<p>其中每一个1代表此处应该置为一个对应颜色，此时的字体大小为16*8</p>
<p>作者给出的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只是将位为1的位置置为对应的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putfont8</span><span class="params">(<span class="keyword">char</span> *vram, <span class="keyword">int</span> xsize, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c, <span class="keyword">char</span> *font)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> *p, d <span class="comment">/* data */</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">		p = vram + (y + i) * xsize + x;</span><br><span class="line">		d = font[i];</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123; p[<span class="number">0</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x40</span>) != <span class="number">0</span>) &#123; p[<span class="number">1</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x20</span>) != <span class="number">0</span>) &#123; p[<span class="number">2</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x10</span>) != <span class="number">0</span>) &#123; p[<span class="number">3</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x08</span>) != <span class="number">0</span>) &#123; p[<span class="number">4</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x04</span>) != <span class="number">0</span>) &#123; p[<span class="number">5</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x02</span>) != <span class="number">0</span>) &#123; p[<span class="number">6</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x01</span>) != <span class="number">0</span>) &#123; p[<span class="number">7</span>] = c; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者给出了他为每一个字符定义的字体，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hankaku.txt</span></span><br><span class="line"><span class="comment">// 此文件通过作者的 makefont.exe编译为目标文件</span></span><br><span class="line"><span class="comment">// 只是将其中的字体文件解析相应的字节数据</span></span><br><span class="line"><span class="keyword">char</span> <span class="number">0x41</span></span><br><span class="line">........</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">.******.</span><br><span class="line">.*....*.</span><br><span class="line">.*....*.</span><br><span class="line">.*....*.</span><br><span class="line">***..***</span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>因为这是外部定义的数据，所以在我们的C语言源文件中，需要使用的话需要增加 <strong><em>extern char hankaku[4096];</em></strong></p>
<p>字符串的显示也类似处理即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putfonts8_asc</span><span class="params">(<span class="keyword">char</span> *vram, <span class="keyword">int</span> xsize, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> hankaku[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">for</span> (; *s != <span class="number">0x00</span>; s++) &#123;</span><br><span class="line">		putfont8(vram, xsize, x, y, c, hankaku + *s * <span class="number">16</span>);</span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标的显示也是类似的，不过作者定义了一个16*16大小的指针，作者这个鼠标太没有美感了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mouse_cursor8</span><span class="params">(<span class="keyword">char</span> *mouse, <span class="keyword">char</span> bc)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* マウスカーソルを準備（16x16） */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">cursor</span>[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">		<span class="string">"**************.."</span>,</span><br><span class="line">		<span class="string">"*OOOOOOOOOOO*..."</span>,</span><br><span class="line">		<span class="string">"*OOOOOOOOOO*...."</span>,</span><br><span class="line">		<span class="string">"*OOOOOOOOO*....."</span>,</span><br><span class="line">		<span class="string">"*OOOOOOOO*......"</span>,</span><br><span class="line">		<span class="string">"*OOOOOOO*......."</span>,</span><br><span class="line">		<span class="string">"*OOOOOOO*......."</span>,</span><br><span class="line">		<span class="string">"*OOOOOOOO*......"</span>,</span><br><span class="line">		<span class="string">"*OOOO**OOO*....."</span>,</span><br><span class="line">		<span class="string">"*OOO*..*OOO*...."</span>,</span><br><span class="line">		<span class="string">"*OO*....*OOO*..."</span>,</span><br><span class="line">		<span class="string">"*O*......*OOO*.."</span>,</span><br><span class="line">		<span class="string">"**........*OOO*."</span>,</span><br><span class="line">		<span class="string">"*..........*OOO*"</span>,</span><br><span class="line">		<span class="string">"............*OO*"</span>,</span><br><span class="line">		<span class="string">".............***"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">16</span>; y++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">16</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">cursor</span>[y][x] == <span class="string">'*'</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = COL8_000000;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">cursor</span>[y][x] == <span class="string">'O'</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = COL8_FFFFFF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">cursor</span>[y][x] == <span class="string">'.'</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = bc;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在https://www.cnblogs.com/bitzhuwei/p/OS-in-30-days-05-initialize-keyboard-and-mouse.html有人给出了一个更好看的鼠标，更加符合Windows风格的鼠标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">cursor</span>[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	<span class="string">"*..............."</span>,</span><br><span class="line">	<span class="string">"**.............."</span>,</span><br><span class="line">	<span class="string">"*O*............."</span>,</span><br><span class="line">	<span class="string">"*OO*............"</span>,</span><br><span class="line">	<span class="string">"*OOO*..........."</span>,</span><br><span class="line">	<span class="string">"*OOOO*.........."</span>,</span><br><span class="line">	<span class="string">"*OOOOO*........."</span>,</span><br><span class="line">	<span class="string">"*OOOOOO*........"</span>,</span><br><span class="line">	<span class="string">"*OOOOOOO*......."</span>,</span><br><span class="line">	<span class="string">"*OOOO*****......"</span>,</span><br><span class="line">	<span class="string">"*OO*O*.........."</span>,</span><br><span class="line">	<span class="string">"*O*.*O*........."</span>,</span><br><span class="line">	<span class="string">"**..*O*........."</span>,</span><br><span class="line">	<span class="string">"*....*O*........"</span>,</span><br><span class="line">	<span class="string">".....*O*........"</span>,</span><br><span class="line">	<span class="string">"......*........."</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后的效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Note/IMG/05_2.png" style="zoom:50%;" /></p>
<h2 id="gdtidt初始化">2. GDT/IDT初始化</h2>
<h3 id="a.-gdtidt基础">a. GDT/IDT基础</h3>
<p>所谓分段，简单来说就是把4GB的内存切分为很多的块，每一块的起始地址都可以看作0来处理，这样子对我们写程序就十分的方便，通过<code>DS:EBX</code>获取对应的地址，在32位模式（保护模式）下，需要对GDT（global（segment） descriptor table 全局段号记录表）进行相应的配置。（这里DS：EBX是作者给出的32位寻址方式，但是有32位的EDS也可以作为寄存器，我怀疑是否是进行了DS和GDT之间的一个映射）</p>
<p>表示一个段需要有以下几个信息:</p>
<ul>
<li>段的大小是多少</li>
<li>段的起始地址在哪里</li>
<li>段的管理属性（禁止写入， 禁止执行， 系统专用等）</li>
</ul>
<p>CPU使用8个字节的数据来表示这些信息，用于指定段的寄存器只有16位。 或许有人会猜想在32位模式下， 段寄存器会扩展到64位， 但事实上段寄存器仍然是16位。那该怎么办才好呢？ 可以模仿图像调色板的做法。 也就是说， 先有一个段号4， 存放在段寄存器里。 然后预先设定好段号与段的对应关系。</p>
<p>段寄存器是16位，但由于CPU设计上的原因，段寄存器的低三位不能够使用（作者也没有表明是用作什么用），所以我们只有13位的段号，范围是0~8191，所以我们需要把8192*8 = 64KB的数据写到内存的对应位置，这一部分的数据就是GDT了。</p>
<p>相应的IDT（interrupt descriptor table 中断记录表）是实现操作系统中断功能必需的。IDT记录了0~255的中断号码与调用函数之间的对应关系，设定方法和GDT十分类似，在对IDT设置之前必须进行GDT的设定。</p>
<h3 id="b.-gdtidt设置">b. GDT/IDT设置</h3>
<p>部分摘自：</p>
<p>https://blog.csdn.net/misskissC/article/details/100593986 (haribote dsctbl.c 设置GDT和IDT程序阅读注释)</p>
<p>IDT 描述符可参考：https://blog.csdn.net/fwqcuc/article/details/5855460</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">base指的是32位的基地址，在这里分为了low,mid,high三个部分，这里分为3段主要是和80286时代的程序相兼容</span></span><br><span class="line"><span class="comment">limit是指段上限，表示这个段有多少字节</span></span><br><span class="line"><span class="comment">段上限分为高低，但是只有20位，这里看上去有3个字节但是limit_high的高四位用于保存段属性</span></span><br><span class="line"><span class="comment">limit_high的高四位和access_right这12位是段属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short limit_low, base_low;</span><br><span class="line">    <span class="keyword">char</span> base_mid, access_right;</span><br><span class="line">    <span class="keyword">char</span> limit_high, base_high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">offset_high&amp;&amp;offset_low,</span></span><br><span class="line"><span class="comment">中断或异常处理程序在其所在内存段中的偏移;</span></span><br><span class="line"><span class="comment">selector,处理程序所在内存段的段选择符;</span></span><br><span class="line"><span class="comment">dw_count,保留未用;</span></span><br><span class="line"><span class="comment">access_right,IDT描述符有效位,特权级(DPL),类型(TYPE)等属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GATE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short offset_low, selector;</span><br><span class="line">    <span class="keyword">char</span> dw_count, access_right;</span><br><span class="line">    short offset_high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_gdtidt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0x270000~0x27ffff设为GDT，将此处设置为地址并没有特别的意义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span> *<span class="title">gdt</span> = (<span class="title">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span> *)0<span class="title">x00270000</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GATE_DESCRIPTOR</span> *<span class="title">idt</span> = (<span class="title">struct</span> <span class="title">GATE_DESCRIPTOR</span> *)0<span class="title">x0026f800</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/* GDT的初始化 这里只是简单的全部初始化为1*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8192</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_segmdesc(gdt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置1，2两个段1代表的是整个内存，2保留的是我们的bootpack.hrb</span></span><br><span class="line">    set_segmdesc(gdt + <span class="number">1</span>, <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, <span class="number">0x4092</span>);</span><br><span class="line">    set_segmdesc(gdt + <span class="number">2</span>, <span class="number">0x0007ffff</span>, <span class="number">0x00280000</span>, <span class="number">0x409a</span>);</span><br><span class="line">    <span class="comment">// gdtr保存的是GDT的首地址，修改寄存器需要使用汇编，所以定义在naskfunc.nas</span></span><br><span class="line">    <span class="comment">// 下面这个函数就是设置段上限和起始地址</span></span><br><span class="line">    <span class="comment">// _load_gdtr: ; void load_gdtr(int limit, int addr);</span></span><br><span class="line">    <span class="comment">//     MOV AX,[ESP+4] ; limit</span></span><br><span class="line">    <span class="comment">//     MOV [ESP+6],AX</span></span><br><span class="line">    <span class="comment">//     LGDT [ESP+6]    ; 从ESP+6处读取6个字节内容</span></span><br><span class="line">    <span class="comment">//     RET</span></span><br><span class="line">    load_gdtr(<span class="number">0xffff</span>, <span class="number">0x00270000</span>);</span><br><span class="line">    <span class="comment">/* IDT的初始化 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_gatedesc(idt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    load_idtr(<span class="number">0x7ff</span>, <span class="number">0x0026f800</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_segmdesc,</span></span><br><span class="line"><span class="comment">设置sd指向的GDT段描述符,</span></span><br><span class="line"><span class="comment">sd,GDT段描述符内存首地址;limit,段描述符所描述内存段基于段基址最大偏移;</span></span><br><span class="line"><span class="comment">base,段描述符所描述内存段基址;ar,段描述符特权级,类型等属性。</span></span><br><span class="line"><span class="comment">ar格式为：xxxx0000xxxxxxxx 高四位存入limit_high的高四位低8位保存到access_right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_segmdesc</span><span class="params">(struct SEGMENT_DESCRIPTOR *sd, <span class="keyword">unsigned</span> <span class="keyword">int</span> limit, <span class="keyword">int</span> base, <span class="keyword">int</span> ar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    高四位格式为GD00,G代表是否*4KB计算，D代表段的模式1为32位模式，0为16位</span></span><br><span class="line"><span class="comment">    如果超过1M大小则将G_bit置为1，此时CPU会将limit*4KB计算段上限</span></span><br><span class="line"><span class="comment">    ar的低8位有以下：</span></span><br><span class="line"><span class="comment">    00000000（0x00） ： 未使用的记录表（descriptor table） 。</span></span><br><span class="line"><span class="comment">    10010010（0x92） ： 系统专用， 可读写的段。 不可执行。</span></span><br><span class="line"><span class="comment">    10011010（0x9a） ： 系统专用， 可执行的段。 可读不可写。</span></span><br><span class="line"><span class="comment">    11110010（0xf2） ： 应用程序用， 可读写的段。 不可执行。</span></span><br><span class="line"><span class="comment">    11111010（0xfa） ： 应用程序用， 可执行的段。 可读不可写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (limit &gt; <span class="number">0xfffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ar |= <span class="number">0x8000</span>; <span class="comment">/* G_bit = 1 */</span></span><br><span class="line">        limit /= <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据GDT段描述符位格式,通过GDT段描述符结构体设置GDT描述符。</span></span><br><span class="line"><span class="comment">    bit[15..0],内存段长度低16位;</span></span><br><span class="line"><span class="comment">    bit[31..16],内存段基址低16位;</span></span><br><span class="line"><span class="comment">    bit[39..32],内存段基址23..16位;</span></span><br><span class="line"><span class="comment">    bit[47..40],有效位P,特权级DPL,类型TYPE等;</span></span><br><span class="line"><span class="comment">    bit[55..48],内存颗粒度,内存段长度19..16位;</span></span><br><span class="line"><span class="comment">    bit[63..56],内存段基址高8位。    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sd-&gt;limit_low = limit &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_low = base &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_mid = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>) | ((ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xf0</span>);</span><br><span class="line">    sd-&gt;base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_gatedesc,</span></span><br><span class="line"><span class="comment">设置gd指向的IDT描述符,</span></span><br><span class="line"><span class="comment">gd,IDT描述符内存首地址;offset,处理程序在其所在段的偏移地址;</span></span><br><span class="line"><span class="comment">selector,处理程序所在内存段的段选择符;ar,IDT描述符有效位,特权级,类型等属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gatedesc</span><span class="params">(struct GATE_DESCRIPTOR *gd, <span class="keyword">int</span> offset, <span class="keyword">int</span> selector, <span class="keyword">int</span> ar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据IDT段描述符位格式,通过IDT描述符结构体设置IDT描述符。</span></span><br><span class="line"><span class="comment">    bit[15..0],处理程序偏移地址低16位;</span></span><br><span class="line"><span class="comment">    bit[31..16],处理程序所在内存段的段选择符;</span></span><br><span class="line"><span class="comment">    bit[39..32],保留未用;</span></span><br><span class="line"><span class="comment">    bit[47..40],有效位P,特权级DPL,类型TYPE等;</span></span><br><span class="line"><span class="comment">    bit[63..48],处理程序偏移地址高16位。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    gd-&gt;offset_low = offset &amp; <span class="number">0xffff</span>;</span><br><span class="line">    gd-&gt;selector = selector;</span><br><span class="line">    gd-&gt;dw_count = (ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    gd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    gd-&gt;offset_high = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断处理">3. 中断处理</h2>
<p>前面已经正确的将GDT以及IDT初始化完成了，要使用中断还需要初始化<strong><em>PIC（programmable interrupt controller 可编程中断控制器）</em></strong>，前面提到中断向量表IDT可以配置256个中断向量号，但是x86系列机提供15个可编程中断，其他中断大多是系统中断。</p>
<p>x86使用的是2片PIC（8259A）级联形成的15个可编程中断。如下图主IPC的2号中断和从IPC连接，所以一共只有15个中断。</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Note/IMG/06_1.png" style="zoom:50%;" /></p>
<p>链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmdpbnRjaGFyL2FydGljbGUvZGV0YWlscy83OTQzOTQ2Ng==" title="https://blog.csdn.net/longintchar/article/details/79439466">8259A详细工作原理<i class="fa fa-external-link"></i></span></p>
<p>PIC 初始化（对相关寄存器进行配置）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pic</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* PIC初始化 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	io_out8(PIC0_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 禁止所有中断 */</span></span><br><span class="line">	io_out8(PIC1_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 禁止所有中断 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC0_ICW1, <span class="number">0x11</span>  ); <span class="comment">/* 边缘触发模式（edge trigger mode） */</span></span><br><span class="line">	io_out8(PIC0_ICW2, <span class="number">0x20</span>  ); <span class="comment">/* IRQ0-7由INT20-27接收 */</span></span><br><span class="line">	io_out8(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">/* PIC1由IRQ2相连 */</span></span><br><span class="line">	io_out8(PIC0_ICW4, <span class="number">0x01</span>  ); <span class="comment">/* 无缓冲区模式 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC1_ICW1, <span class="number">0x11</span>  ); <span class="comment">/* 边缘触发模式（edge trigger mode） */</span></span><br><span class="line">	io_out8(PIC1_ICW2, <span class="number">0x28</span>  ); <span class="comment">/* IRQ8-15由INT28-2f接收 */</span></span><br><span class="line">	io_out8(PIC1_ICW3, <span class="number">2</span>     ); <span class="comment">/* PIC1由IRQ2连接 */</span></span><br><span class="line">	io_out8(PIC1_ICW4, <span class="number">0x01</span>  ); <span class="comment">/* 无缓冲区模式 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC0_IMR,  <span class="number">0xfb</span>  ); <span class="comment">/* 11111011 PIC1以外全部禁止 */</span></span><br><span class="line">	io_out8(PIC1_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 11111111 禁止所有中断 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<strong>ICW2</strong>我们实现将IRQ和INT号相绑定</p>
<p>大家可能会对此有兴趣， 所以再详细介绍一下。 中断发生以后， 如果CPU可以受理这个中断， CPU就会命令PIC发送2个字节的数据。 这2个字节是怎么传送的呢？ CPU与PIC用IN或OUT进行数据传送时， 有数据信号线连在一起。 PIC就是利用这个信号线发送这2个字节数据的。 送过来的数据是“0xcd 0x??”这两个字节。 由于电路设计的原因， 这两个字节的数据在CPU看来， 与从内存读进来的程序是完全一样的， 所以CPU就把送过来的“0xcd 0x??”作为机器语言执行。这恰恰就是把数据当作程序来执行的情况。 这里的0xcd就是调用BIOS时使用的那个INT指令。 我们在程序里写的“INT 0x10”， 最后就被编译成了“0xcd0x10”。 所以， CPU上了PIC的当， 按照PIC所希望的中断号执行了INT指令。</p>
<p>注意这里的IRQ全部绑定到了INT 20开始的位置，PIC的中断一般默认都是设置在此位置，其他的中断号一般是为其他类型的中断准备的。</p>
<p><strong>鼠标是IRQ12， 键盘是IRQ1，对应的INT是于INT 0x2c和INT 0x21。</strong>这似乎是规定好的。</p>
<p>中断与函数跳转很相似，但是需要IRETD作为中断返回的标志，这个指令不能使用C语言编写，所以需要汇编的帮助。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;因为inthandler21定义在别的文件所以要加上extern</span><br><span class="line">EXTERN	_inthandler21</span><br><span class="line">_asm_inthandler21:</span><br><span class="line">		PUSH	ES</span><br><span class="line">		PUSH	DS</span><br><span class="line">		PUSHAD</span><br><span class="line">		MOV		EAX,ESP</span><br><span class="line">		PUSH	EAX</span><br><span class="line">		MOV		AX,SS</span><br><span class="line">		MOV		DS,AX</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		CALL	_inthandler21</span><br><span class="line">		POP		EAX</span><br><span class="line">		POPAD</span><br><span class="line">		POP		DS</span><br><span class="line">		POP		ES</span><br><span class="line">		IRETD</span><br></pre></td></tr></table></figure>
<p>关于在DS和ES中放入SS值的部分， 因为C语言自以为是地认为“DS也好， ES也好，SS也好， 它们都是指同一个段”， 所以如果不按照它的想法设定的话， 函数inthandler21就不能顺利执行。 所以， 虽然麻烦了一点， 但还是要这样做。</p>
<p>然后我们只需要对<code>inthandler21</code>和其他类似的中断函数进行编写了</p>
<p>通过<code>set_gatedesc</code>配置中断记录表，这个函数在前面提到过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INT 21键盘中断</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x21</span>, (<span class="keyword">int</span>) asm_inthandler21, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT 27 IRQ中断</span></span><br><span class="line"><span class="comment">PIC0中断的不完整策略</span></span><br><span class="line"><span class="comment">这个中断在Athlon64X2上通过芯片组提供的便利，只需执行一次</span></span><br><span class="line"><span class="comment">这个中断只是接收，不执行任何操作</span></span><br><span class="line"><span class="comment">为什么不处理？</span></span><br><span class="line"><span class="comment">	→  因为这个中断可能是电气噪声引发的、只是处理一些重要的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x27</span>, (<span class="keyword">int</span>) asm_inthandler27, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="comment">// INT 2c鼠标中断</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x2c</span>, (<span class="keyword">int</span>) asm_inthandler2c, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br></pre></td></tr></table></figure>
<h3 id="fifo-缓冲配置">FIFO 缓冲配置</h3>
<p>中断几乎是无时无刻不再发生的，处理一个中断的过程中可能有其他中断发生，所以我们需要把处理中断的程序编写的越短越好（操作系统中中断是有优先级的，这里作者并没有明确的说明）</p>
<p>所以在我们处理键盘鼠标这类外部设备的中断时，获取到数据之后不用急忙处理，而是将其放置到一个缓冲区中，等到之后处理。这个缓冲区的大小和其他设计很值得考量。作者给出了一个FIFO缓冲区的实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FIFO */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bootpack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAGS_OVERRUN		0x0001</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fifo8_init</span><span class="params">(struct FIFO8 *fifo, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 初始化FIFO缓冲区 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fifo-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">	fifo-&gt;buf = buf;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span> = <span class="built_in">size</span>; <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">	fifo-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;p = <span class="number">0</span>; <span class="comment">/* 下一个数据写入位置 */</span></span><br><span class="line">	fifo-&gt;q = <span class="number">0</span>; <span class="comment">/* 下一个数据读出位置 */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fifo8_put</span><span class="params">(struct FIFO8 *fifo, <span class="keyword">unsigned</span> <span class="keyword">char</span> data)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 向FIFO传送数据并保存 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;<span class="built_in">free</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 没有空间了，溢出 */</span></span><br><span class="line">		fifo-&gt;flags |= FLAGS_OVERRUN;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;buf[fifo-&gt;p] = data;</span><br><span class="line">	fifo-&gt;p++;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;p == fifo-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">		fifo-&gt;p = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span>--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fifo8_get</span><span class="params">(struct FIFO8 *fifo)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 从FIFO取得一个数据 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;<span class="built_in">free</span> == fifo-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">		<span class="comment">/* 如果缓冲区为空则返回-1 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	data = fifo-&gt;buf[fifo-&gt;q];</span><br><span class="line">	fifo-&gt;q++;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;q == fifo-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">		fifo-&gt;q = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span>++;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fifo8_status</span><span class="params">(struct FIFO8 *fifo)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 报告一下积攒是数据量 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fifo-&gt;<span class="built_in">size</span> - fifo-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现还是比较容易的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inthandler21</span><span class="params">(<span class="keyword">int</span> *esp)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 来自PS/2键盘的中断 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> *<span class="title">binfo</span> = (<span class="title">struct</span> <span class="title">BOOTINFO</span> *) <span class="title">ADR_BOOTINFO</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> data, s[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">/* 通知PIC IRQ-01 已经受理完毕 否则不处理下一次中断 */</span></span><br><span class="line">	io_out8(PIC0_OCW2, <span class="number">0x61</span>);</span><br><span class="line">	data = io_in8(PORT_KEYDAT);</span><br><span class="line">	fifo8_put(&amp;keyfifo, data);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>inthandler21</code>里面只需要对数据保存即可，然后在<code>bootpack.c</code>主循环中显示对应的信息即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bootpack.c</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_cli();</span><br><span class="line">		<span class="keyword">if</span> (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == <span class="number">0</span>) &#123;</span><br><span class="line">			io_stihlt();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (fifo8_status(&amp;keyfifo) != <span class="number">0</span>) &#123;</span><br><span class="line">				i = fifo8_get(&amp;keyfifo);</span><br><span class="line">				io_sti();</span><br><span class="line">				<span class="built_in">sprintf</span>(s, <span class="string">"%02X"</span>, i);</span><br><span class="line">				boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484,  <span class="number">0</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">31</span>);</span><br><span class="line">				putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="number">0</span>, <span class="number">16</span>, COL8_FFFFFF, s);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fifo8_status(&amp;mousefifo) != <span class="number">0</span>) &#123;</span><br><span class="line">				i = fifo8_get(&amp;mousefifo);</span><br><span class="line">				io_sti();</span><br><span class="line">				<span class="built_in">sprintf</span>(s, <span class="string">"%02X"</span>, i);</span><br><span class="line">				boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, <span class="number">32</span>, <span class="number">16</span>, <span class="number">47</span>, <span class="number">31</span>);</span><br><span class="line">				putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="number">32</span>, <span class="number">16</span>, COL8_FFFFFF, s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对鼠标的操作也是类似的</p>
<h2 id="鼠标控制">4. 鼠标控制</h2>
<p>参考代码解释：<span class="exturl" data-url="aHR0cHM6Ly93d3cudHdibG9ncy5uZXQvYS81ZDczN2YxOWJkOWVlZTUzMjdmZjdmNjQvemgtY24=" title="https://www.twblogs.net/a/5d737f19bd9eee5327ff7f64/zh-cn">粗略阅读haribote鼠标管理程序 mouse.c<i class="fa fa-external-link"></i></span></p>
<p>要使鼠标中断可以被CPU响应，除了配置中断记录表还需要执行激活鼠标的指令，所以我们需要配置两个装置，一个是鼠标控制电路，一个是鼠标本身。鼠标控制电路包含在键盘控制电路中，只要键盘控制电路初始化完成，鼠标电路控制器也就激活完成了。</p>
<p>键盘电路初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_KEYDAT 0x0060</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_KEYSTA 0x0064</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_KEYCMD 0x0064</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYSTA_SEND_NOTREADY 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYCMD_WRITE_MODE 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBC_MODE 0x47</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_KBC_sendready</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    等待键盘控制电路准备完毕</span></span><br><span class="line"><span class="comment">    因为键盘控制电路的工作没有CPU快，需要循环判断是否准备好</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((io_in8(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_keyboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化键盘控制电路 */</span></span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);</span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYDAT, KBC_MODE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在之前的键盘程序上并没有对键盘进行初始化（感觉是默认初始化的），在初始化后就可以激活鼠标了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYCMD_SENDTO_MOUSE 0xd4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOUSECMD_ENABLE 0xf4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数与init_keyboard函数非常相似。 不同点仅在于写入的数据不同。 如果往键</span></span><br><span class="line"><span class="comment">盘控制电路发送指令0xd4， 下一个数据就会自动发送给鼠标。 我们根据这一特性来</span></span><br><span class="line"><span class="comment">发送激活鼠标的指令。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_mouse</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 激活鼠标 */</span></span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);</span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 顺利的话,键盘控制其会返送回ACK(0xfa)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>激活过程很简单，只是对相应的端口输出数据即可，<strong>鼠标一旦激活就会返回发送一个0xfa的答复信息</strong></p>
<p>接下来就是从鼠标获取数据了，因为和键盘共用一个控制电路，所以获取数据的代码很类似，两者是通过中断号区分的。<strong>由于12号IRQ在从片上所以需要告知从片受理完成</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIFO8</span> <span class="title">mousefifo</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inthandler2c</span><span class="params">(<span class="keyword">int</span> *esp)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 来自PS/2鼠标的中断 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    io_out8(PIC1_OCW2, <span class="number">0x64</span>); <span class="comment">/* 通知PIC1 IRQ-12的受理已经完成 */</span></span><br><span class="line">    io_out8(PIC0_OCW2, <span class="number">0x62</span>); <span class="comment">/* 通知PIC0 IRQ-02的受理已经完成 */</span></span><br><span class="line">    data = io_in8(PORT_KEYDAT);</span><br><span class="line">    fifo8_put(&amp;mousefifo, data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标信息由三个字节的数据构成，而且需要丢弃掉鼠标激活时发送的<code>0xfa</code>，其他便比较简单了，作者构建了一个鼠标缓冲，当接收到完整的三个字节后重新打印鼠标，实现鼠标的移动</p>
<p><strong>鼠标返回的数据主要由鼠标按键信息，垂直和水平偏移量构成，主要注意鼠标的坐标系和屏幕是上下颠倒的</strong></p>
<p>具体处理信息和鼠标三字节结构体字节分配在下面的链接中有很详细的说明</p>
<p>具体代码实现过程见：https://www.twblogs.net/a/5d737f19bd9eee5327ff7f64/zh-cn</p>
<p>但是没有处理画面叠加的问题，所以会有鼠标涂抹掉其他画面，第八天的<strong><em>通往32位模式之路</em></strong>放到下一次笔记</p>
<p>效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Note/IMG/08_1.gif" alt="效果图" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Tutorial &amp; Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 04 C语言和画面显示的练习</title>
    <url>/2020/01/26/2020-01-26-30OSMakeNote04/</url>
    <content><![CDATA[<h1 id="c语言和画面显示的练习">04 C语言和画面显示的练习</h1>
<p>原文中作者花了很大的力气讲解C语言的有关知识，这里就不多赘述了。。</p>
<a id="more"></a>
<h2 id="显示模式和显存">1. 显示模式和显存</h2>
<p>前一天的内容作者就将我们的操作系统的显示设置为<code>VGA 320*200 8 位调色板</code>模式，8位意味着我们可以使用256种颜色，但本质上VGA还是RGB成色模式，需要3个字节表示一个完整的颜色，我们只能设置色号，就是一个8位数到24位颜色的映射，设置的方法后面介绍。</p>
<p>并且将显示的分辨率设置为<code>320*200</code>，每一个像素都需要一个字节（8位）来表示颜色</p>
<p>此模式下显存的地址范围为<code>0xa0000 -0xaffff</code>，但是一个像素存储一个字节只需要<code>320*200</code>字节，但是显存范围是64K比存储像素的大一些，也不知是什么原因。。</p>
<h2 id="汇编实现内存写入">2. 汇编实现内存写入</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_write_mem8: ; void write_mem8(int addr, int data);</span><br><span class="line">    MOV ECX,[ESP+4] ; [ESP + 4]中存放的是地址， 将其读入ECX</span><br><span class="line">    MOV AL,[ESP+8] ; [ESP + 8]中存放的是数据， 将其读入AL</span><br><span class="line">    MOV [ECX],AL</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<p>这里是32位模式所以我们使用的寄存器都是拓展寄存器，这里C语言编译器函数参数是从右到左压入栈，所以这里只是简单的把一个32位的数据写到指定的32位地址的内存中去</p>
<h2 id="色号设定">3. 色号设定</h2>
<p>前面提到过我们的显示模式是VGA 8位调色板模式，需要自己对不同的256个颜色编号指定不同的颜色。作者使用了16种颜色来绘制他的操作系统，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  0:黑 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  1:梁红 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0x00</span>,	<span class="comment">/*  2:亮绿 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>,	<span class="comment">/*  3:亮黄 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>,	<span class="comment">/*  4:亮蓝 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xff</span>,	<span class="comment">/*  5:亮紫 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,	<span class="comment">/*  6:浅亮蓝 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,	<span class="comment">/*  7:白 */</span></span><br><span class="line">	<span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="number">0xc6</span>,	<span class="comment">/*  8:亮灰 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  9:暗红 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x00</span>,	<span class="comment">/* 10:暗绿 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x00</span>,	<span class="comment">/* 11:暗黄 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>,	<span class="comment">/* 12:暗青 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x84</span>,	<span class="comment">/* 13:暗紫 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x84</span>,	<span class="comment">/* 14:浅暗蓝 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x84</span>	<span class="comment">/* 15:暗灰 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时作者提供了许多帮助写如端口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_hlt</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 之前出现过的悬停CPU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_cli</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 中断标识位清零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_out8</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> data)</span></span>;	<span class="comment">// 输出8位数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_load_eflags</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">// 返回表示寄存器值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_store_eflags</span><span class="params">(<span class="keyword">int</span> eflags)</span></span>; <span class="comment">// 使用eflags重载表示寄存器</span></span><br></pre></td></tr></table></figure>
<p>其汇编实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]				; 制作目标文件的模式	</span><br><span class="line">[INSTRSET &quot;i486p&quot;]				; 使用到486为止的指令</span><br><span class="line">[BITS 32]						; 3制作32位模式用的机器语言</span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]			; 文件名</span><br><span class="line"></span><br><span class="line">		GLOBAL	_io_hlt, _io_cli, _io_sti, _io_stihlt</span><br><span class="line">		GLOBAL	_io_in8,  _io_in16,  _io_in32</span><br><span class="line">		GLOBAL	_io_out8, _io_out16, _io_out32</span><br><span class="line">		GLOBAL	_io_load_eflags, _io_store_eflags</span><br><span class="line"></span><br><span class="line">[SECTION .text]</span><br><span class="line"></span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_cli:	; void io_cli(void);</span><br><span class="line">		CLI</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_sti:	; void io_sti(void);</span><br><span class="line">		STI</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_stihlt:	; void io_stihlt(void);</span><br><span class="line">		STI</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in8:	; int io_in8(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		IN		AL,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in16:	; int io_in16(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		IN		AX,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in32:	; int io_in32(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		IN		EAX,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out8:	; void io_out8(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		AL,[ESP+8]		; data</span><br><span class="line">		OUT		DX,AL</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out16:	; void io_out16(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,[ESP+8]		; data</span><br><span class="line">		OUT		DX,AX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out32:	; void io_out32(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,[ESP+8]		; data</span><br><span class="line">		OUT		DX,EAX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_load_eflags:	; int io_load_eflags(void);</span><br><span class="line">		PUSHFD		; PUSH EFLAGS </span><br><span class="line">		POP		EAX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_store_eflags:	; void io_store_eflags(int eflags);</span><br><span class="line">		MOV		EAX,[ESP+4]</span><br><span class="line">		PUSH	EAX</span><br><span class="line">		POPFD		; POP EFLAGS </span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>代码中右<code>IN OUT</code>指令，这两个指令是CPU和其他输入输出设备交互的必备指令，<code>IN</code>从指定端口读入数据，<code>OUT</code>则是写数据，注意汇编中（C语言编译后）函数的返回值都是通过EAX寄存器</p>
<p>接下来要开始真正设置色号，VGA 调色板模式设置流程如下：</p>
<ol type="1">
<li>首先在一连串的访问中屏蔽中断（比如CLI） 。</li>
<li>将想要设定的调色板号码写入0x03c8， 紧接着， 按R， G， B的顺序写入 0x03c9。 如果还想继续设定下一个调色板， 则省略调色板号码， 再按照RGB的 顺序写入0x03c9就行了。</li>
<li>如果想要读出当前调色板的状态， 首先要将调色板的号码写入0x03c7， 再从 0x03c9读取3次。 读出的顺序就是R， G， B。 如果要继续读出下一个调色板， 同 样也是省略调色板号码的设定， 按RGB的顺序读出。</li>
<li>如果最初执行了CLI， 那么最后要执行STI</li>
</ol>
<p>对应的C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_hlt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_cli</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_out8</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_load_eflags</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_store_eflags</span><span class="params">(<span class="keyword">int</span> eflags)</span></span>;</span><br><span class="line"><span class="comment">/*就算写在同一个源文件里， 如果想在定义前使用， 还是必须事先声明一下。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_palette</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_palette</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span> *rgb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; <span class="comment">/* 声明变量。 变量i是32位整数型 */</span></span><br><span class="line">	<span class="keyword">char</span> *p; <span class="comment">/* 变量p是BYTE [...]用的地址 */</span></span><br><span class="line">	init_palette(); <span class="comment">/* 设定调色板 */</span></span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="number">0xa0000</span>; <span class="comment">/* 指定地址 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    	p[i] = i &amp; <span class="number">0x0f</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_hlt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_palette</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 0:黑 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 1:亮红 */</span></span><br><span class="line">    	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="comment">/* 2:亮绿 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="comment">/* 3:亮黄 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="comment">/* 4:亮蓝 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="comment">/* 5:亮紫 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* 6:浅亮蓝 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* 7:白 */</span></span><br><span class="line">        <span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="comment">/* 8:亮灰 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 9:暗红 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="comment">/* 10:暗绿 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="comment">/* 11:暗黄 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="comment">/* 12:暗青 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="comment">/* 13:暗紫 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="comment">/* 14:浅暗蓝 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x84</span> <span class="comment">/* 15:暗灰 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	set_palette(<span class="number">0</span>, <span class="number">15</span>, table_rgb);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* C语言中的static char语句只能用于数据， 相当于汇编中的DB指令 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_palette</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span> *rgb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, eflags;</span><br><span class="line">    eflags = io_load_eflags(); <span class="comment">/* 记录中断许可标志的值*/</span></span><br><span class="line">    io_cli(); <span class="comment">/* 将中断许可标志置为0， 禁止中断 */</span></span><br><span class="line">    io_out8(<span class="number">0x03c8</span>, start);</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">0</span>] / <span class="number">4</span>);</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">1</span>] / <span class="number">4</span>);</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">2</span>] / <span class="number">4</span>);</span><br><span class="line">		rgb += <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    io_store_eflags(eflags); <span class="comment">/* 复原中断许可标志 */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Note/IMG/04_1.png" style="zoom:50%;" /></p>
<h2 id="绘制矩形">3. 绘制矩形</h2>
<p>画面坐标系都是左上坐标系（左上角为顶点），所以对于坐标<code>(x,y)</code>我们只需要通过<code>0xa0000 + x + y * 320</code>定为该坐标的对应地址，这么一来绘制矩形就简单多了</p>
<p>绘制矩形代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vram: 对应显存地址 0xa0000</span></span><br><span class="line"><span class="comment">xsize: 对应宽</span></span><br><span class="line"><span class="comment">c: 颜色编号</span></span><br><span class="line"><span class="comment">左上-右下坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxfill8</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *vram, <span class="keyword">int</span> xsize, <span class="keyword">unsigned</span> <span class="keyword">char</span> c, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (y = y0; y &lt;= y1; y++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x = x0; x &lt;= x1; x++)</span><br><span class="line">			vram[y * xsize + x] = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Note/IMG/04_2.png" style="zoom:50%;" /></p>
<p>作者最后还绘制了一个简陋的界面都是通过绘制矩形实现这里就不多说了</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Tutorial &amp; Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 笔记目录</title>
    <url>/2020/01/24/2020-01-24-30OSMakeNoteAll/</url>
    <content><![CDATA[<h1 id="daysmakeos-note">30DaysMakeOS-Note</h1>
<blockquote>
<p>《30天自制操作系统》（川合秀实）阅读笔记</p>
</blockquote>
<h2 id="笔记目录">笔记目录</h2>
<ul>
<li><a href="https://joke-lin.top/os/tutorial/2020/01/24/30OSMakeNote1-3/">第一天到第三天——从汇编到C语言</a></li>
<li><a href="https://joke-lin.top/os/tutorial/2020/01/26/30OSMakeNote04/">第四天——C语言和画面显示的练习</a></li>
</ul>
<hr />
<a id="more"></a>
<p>书本实现了一个名为OSASK的只有80KB的简单操作系统，效果图如下</p>
<p><img src="https://raw.githubusercontent.com/Joke-Lin/30DaysMakeOS-Note/master/Screen.png" style="zoom:50%;" /></p>
<h2 id="书本各章内容概要摘自原文">书本各章内容概要（摘自原文）</h2>
<h3 id="第一周第1天-第7天">第一周（第1天 ～ 第7天）</h3>
<p>一开始首先要考虑怎么来写一个“只要一通电就能运行的程序”。 这部分用C语言写 起来有些困难， 所以主要还是用汇编语言来写。 这步完成之后， 下一步就要写一个从磁盘读取操作系统的程序。 这时即便打开电脑 电源， 它也不会自动地将操作系统全部都读进来， 它只能读取磁盘上最开始的512 字节的内容， 所以我们要编写剩余部分的载入程序。 这个程序也要用汇编语言编 写。 一旦完成了这一步， 以后的程序就可以用C语言来编写了。 我们就尽快使用C语言 来学习开发显示画面的程序。 同时， 我们也能慢慢熟悉C语言语法。 这个时候我们 好像在做自己想做的事， 但事实上我们还没有自由操纵C语言。 接下来， 为了实现“移动鼠标”这一雄心， 我们要对CPU进行细致的设定， 并掌握中 断处理程序的写法。 从全书总体看来， 这一部分是水平相当高的部分， 笔者也觉得 放在这里有些不妥， 但从本书条理上讲， 这些内容必须放在这里， 所以只好请大家 忍耐一下了。 在这里， CPU的规格以及电脑复杂的规格都会给我们带来各种各样的 麻烦。 而且开发语言既有C语言， 又有汇编语言， 这又给我们造成了更大的混乱。 这个时候我们一点儿也不会觉得这是在做自己想做的事， 怎么看都像是在“受人摆 布”。 渡过这个痛苦的时期， 第一周就该结束了。</p>
<h3 id="第二周第8天-第14天">第二周（第8天 ～ 第14天）</h3>
<p>一周的苦战还是很有意义的， 回头一看， 我们就会发现自己还是斩获颇丰的。 这时 我们已经基本掌握了C语言的语法， 连汇编语言的水平也能达到本书的要求了。 所以现在我们就可以着手开发像样的操作系统了。 但是这一次我们又要为算法头痛 了。 即使掌握了编程语言的语法， 如果不懂得好的算法的话， 也还是不能开发出来 自己想要的操作系统。 所以这一周我们就边学习算法边慢慢地开发操作系统。 不过 到了这一阶段， 我们就能感觉到基本上不会再受技术问题限制了。</p>
<h3 id="第三周第15天-第21天">第三周（第15天 ～ 第21天）</h3>
<p>现在我们的技术已经相当厉害了， 可以随心所欲地开发自己的操作系统了。 首先是 要支持多任务， 然后是开发命令行窗口， 之后就可以着手开发应用程序了。 到本周 结束时， 就算还不够完备， 我们也能拿出一个可以称之为操作系统的软件了。</p>
<h3 id="第四周第22天-第28天">第四周（第22天 ～ 第28天）</h3>
<p>在这个阶段， 我们可以尽情地给操作系统增加各种各样的功能， 同时还可以开发出 大量像模像样的应用程序来。 这个阶段我们已经能做得很好了， 这可能也是我们最 高兴的时期。 这部分要讲解的内容很少， 笔者也不用再煞费苦心地去写那些文字说 明了， 可以把精力都集中在编程上（笑） 。 对了， 说起文字才想起来， 正好在这个 时期可以让我们的操作系统显示文字了。</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Tutorial &amp; Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 01-03 从汇编到C语言</title>
    <url>/2020/01/24/2020-01-24-30OSMakeNote01-03/</url>
    <content><![CDATA[<h1 id="day-note">01-03-Day-Note</h1>
<blockquote>
<p>第一天到第三天的笔记</p>
</blockquote>
<a id="more"></a>
<h2 id="运行环境准备">1. 运行环境准备</h2>
<p>中文源码（包含每章节最终的翻译代码）：https://github.com/yourtion/30dayMakeOS</p>
<p>可以直接在作者提供的开发包中执行作者提供的文件，执行过程如下：</p>
<ol type="1">
<li>将对应<code>project</code>中包含源代码的目录复制到<code>tolset</code>中</li>
<li>执行对应的<code>Makefile</code>指令</li>
</ol>
<p><strong>需要在Windows的Shell环境下执行，在Git Bash执行会存在命令的不一致问题</strong></p>
<p>作者在<code>nasm</code>的基础上开发了名为<code>nask</code>的汇编编译器，然后通过<code>imgtol</code>制作img镜像文件，最后通过<code>qemu</code>虚拟机运行此镜像文件，作者已经写好所有样例代码以及运行的脚本文件（批处理文件和Makefile）</p>
<p>上面所有的作者工具都在书本配套文件的<code>tolset</code>中</p>
<p>当然以上基础编译工具都可以使用已有工具代替（作者的类似很古老了）</p>
<h4 id="其他工具替代">其他工具替代</h4>
<ul>
<li><p>使用<code>nasm</code>替代<code>nask</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm infile.asm -o outfile.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用最新的 <code>qemu</code> 替代（此处为qemu4)</p>
<p><code>qemu</code>基本命令行参数参考 https://www.datarelab.com/blog/Technical_literature/562.html</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -fda youros.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>代替作者的<code>imgtol</code></p>
<p>可以使用Linux的<code>dd</code>命令替换 Windows 下可在此处下载：http://www.chrysocome.net/download</p>
<p><code>dd</code>是类似<code>cp</code>的一个工具，不过<code>dd</code>针对的是块而cp针对的是文件</p>
<p>可参考：http://blackblog.tech/2018/07/19/CreateOSDay3/#comments</p></li>
</ul>
<h2 id="汇编">2. 汇编</h2>
<h3 id="i.-寄存器">i. 寄存器</h3>
<h4 id="位寄存器">16 位寄存器</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名字</th>
<th style="text-align: left;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AX</td>
<td style="text-align: left;">accumulator， 累加寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">CX</td>
<td style="text-align: left;">counter， 计数寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DX</td>
<td style="text-align: left;">data， 数据寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">BX</td>
<td style="text-align: left;">base， 基址寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SP</td>
<td style="text-align: left;">stack pointer， 栈指针寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">BP</td>
<td style="text-align: left;">base pointer， 基址指针寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SI</td>
<td style="text-align: left;">source index， 源变址寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">DI</td>
<td style="text-align: left;">destination index， 目的变址寄存器</td>
</tr>
</tbody>
</table>
<h4 id="位寄存器-1">8 位寄存器</h4>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AL</td>
<td>累加寄存器低位（accumulator low）</td>
</tr>
<tr class="even">
<td>CL</td>
<td>计数寄存器低位（counter low）</td>
</tr>
<tr class="odd">
<td>DL</td>
<td>数据寄存器低位（data low）</td>
</tr>
<tr class="even">
<td>BL</td>
<td>基址寄存器低位（base low）</td>
</tr>
<tr class="odd">
<td>AH</td>
<td>累加寄存器高位（accumulator high）</td>
</tr>
<tr class="even">
<td>CH</td>
<td>计数寄存器高位（counter high）</td>
</tr>
<tr class="odd">
<td>DH</td>
<td>数据寄存器高位（data high）</td>
</tr>
<tr class="even">
<td>BH</td>
<td>基址寄存器高位（base high）</td>
</tr>
</tbody>
</table>
<h4 id="段寄存器">段寄存器</h4>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ES</td>
<td>附加段寄存器（extra segment）</td>
</tr>
<tr class="even">
<td>CS</td>
<td>代码段寄存器（code segment）</td>
</tr>
<tr class="odd">
<td>SS</td>
<td>栈段寄存器（stack segment）</td>
</tr>
<tr class="even">
<td>DS</td>
<td>数据段寄存器（data segment）</td>
</tr>
<tr class="odd">
<td>FS</td>
<td>没有名称（segment part 2）</td>
</tr>
<tr class="even">
<td>GS</td>
<td>没有名称（segment part 3）</td>
</tr>
</tbody>
</table>
<h4 id="位拓展寄存器">32 位拓展寄存器</h4>
<p>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI （加了个extend拓展的标签）</p>
<h3 id="ii.-基础指令">ii. 基础指令</h3>
<ul>
<li><p>DB：按字节定义类似的还有DW（定义字），DD（定义双字）</p></li>
<li><p>MOV：移动指令<code>mov A, B</code>意为<code>A = B</code>, <code>mov</code>后的寄存器或者字面量加上<code>[]</code>则代表引用此地址的值</p>
<p>如：<code>MOV AL, BYTE [BX]</code>，会将指定段寄存器乘16倍将上BX的值形成目标地址</p>
<p>BX、 BP、 SI、 DI这几个。 剩下的AX、 CX、 DX、 SP不能用来指定内存地址</p></li>
<li><p>JMP：跳转指令 跳转到指定内存地址</p></li>
<li><p>INT：软件中断指令 后接中断号，调用BIOS预设的函数（功能）</p></li>
<li><p>JE：相等则跳转（工具FLAGS寄存器的标志寄存器的值跳转）</p></li>
<li><p>CMP：比较两个寄存器（书面量）的值，修改对应的标志寄存器</p></li>
<li><p>HLT：让CPU进入待机状态只要外部发生变化， 比如按下键盘， 或是移动鼠标， CPU就会醒过来， 继续执行程序</p></li>
<li><p>RESB：填充指定数量字节的0x00</p></li>
<li><p>ORG：将指令加载到指定位置，详情可见：https://blog.csdn.net/yuduoluogongwu/article/details/7359242</p></li>
</ul>
<h3 id="iii.-nasm-和-nask-的区别">iii. NASM 和 NASK 的区别</h3>
<p>nask 和 nasm 部分语法不同，差别如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">NASK代码</th>
<th style="text-align: left;">NASM代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">JMP entry</td>
<td style="text-align: left;">JMP SHORT entry</td>
</tr>
<tr class="even">
<td style="text-align: right;">RESB <填充字节数></td>
<td style="text-align: left;">TIMES <填充字节数> DB <填充数据></td>
</tr>
<tr class="odd">
<td style="text-align: right;">RESB 0x7dfe-$</td>
<td style="text-align: left;">TIMES 0x1fe-($-$$) DB 0</td>
</tr>
<tr class="even">
<td style="text-align: right;">ALIGNB 16</td>
<td style="text-align: left;">ALIGN 16, DB 0</td>
</tr>
</tbody>
</table>
<p>在文中出现了美元符代表的意思如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ 是当前位置</span><br><span class="line">$$ 是段开始位置</span><br><span class="line">$ - $$ 是当前位置在段内的偏移</span><br></pre></td></tr></table></figure>
<h2 id="makefile">3. Makefile</h2>
<p>Makefile就像是一个非常聪明的批处理文件</p>
<p>具体操作说明可参考：http://www.ruanyifeng.com/blog/2015/02/make.html</p>
<h2 id="ipl">4. IPL</h2>
<h3 id="软盘-fat12">软盘 FAT12</h3>
<p>作者使用的是格式为<code>FAT12</code>格式的软盘</p>
<p>用Windows或MS-DOS格式化出来的软盘就是这种格式。 作者的helloos也采用了这种格式， 其中容纳了作者开发的操作系统。 这个格式兼容性好， 在Windows上也能用， 而且剩余的磁盘空间还可以用来保存自己喜欢的文件。</p>
<p>1张软盘有80个柱面， 2个磁头， 18个扇区， 且一个扇区有512字节。 所以， 一张软盘的容量是： 80×2×18×512 = 1474560 Byte = 1440KB</p>
<h3 id="启动区">启动区</h3>
<p>（boot sector） 软盘第一个的扇区称为启动区。 那么什么是扇区呢？ 计算机读写软盘的时候， 并不是一个字节一个字节地读写的， 而是以512字节为一个单位进行读写。 因此,软盘的512字节就称为一个扇区。 一张软盘的空间共有1440KB， 也就是1474560字节， 除以512得2880， 这也就是说一张软盘共有2880个扇区。 那为什么第一个扇区称为启动区呢？ 那是因为计算机首先从最初一个扇区开始读软盘， 然后去检查这个扇区最后2个字节的内容。如果这最后2个字节不是0x55 AA， 计算机会认为这张盘上没有所需的启动程序， 就会报一个不能启动的错误。 （也许有人会问为什么一定是0x55AA呢？ 那是当初的设计者随便定的， 笔者也没法解释） 。 如果计算机确认了第一个扇区的最后两个字节正好是0x55 AA， 那它就认为这个扇区的开头是启动程序， 并开始执行这个程序。</p>
<h3 id="ipl-启动程序装载器">IPL 启动程序装载器</h3>
<p>initial program loader的缩写。 启动程序加载器。 启动区只有区区512字节， 实际的操作系统不像hello-os这么小， 根本装不进去。 所以几乎所有的操作系统， 都是把加载操作系统本身的程序放在启动区里的。 有鉴于此， 有时也将启动区称为IPL。 但hello-os没有加载程序的功能， 所以HELLOIPL这个名字不太顺理成章。 如果有人正义感特别强， 觉得“这是撒谎造假， 万万不能容忍！ ”， 那也可以改成其他的名字。 但是必须起一个8字节的名字， 如果名字长度不到8字节的话， 需要在最后补上空格</p>
<h3 id="制作-ipl">制作 IPL</h3>
<p>计算机加载操作系统的流程如下：</p>
<ol type="1">
<li>从特定位置读取操作系统数据（USB或者软盘，软盘已经淘汰了），但这里使用的是软盘</li>
<li>软盘的第一个512字节的扇区作为启动区，执行此启动区指令</li>
<li>该启动区将软盘内容加载到内存指定位置(0x7c00)运行，根据最后两字节判断是否是启动区</li>
</ol>
<p>文中的IPL加载了软盘的10个柱面</p>
<p>文中的IPL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; haribote-ipl</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">CYLS	EQU		10				; 声明CYLS&#x3D;10</span><br><span class="line"></span><br><span class="line">		ORG		0x7c00			; 指明程序装载地址</span><br><span class="line"></span><br><span class="line">; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code</span><br><span class="line"></span><br><span class="line">		JMP		entry</span><br><span class="line">		DB		0x90</span><br><span class="line">		DB		&quot;HARIBOTE&quot;		; 启动扇区名称（8字节）</span><br><span class="line">		DW		512				; 每个扇区（sector）大小（必须512字节）</span><br><span class="line">		DB		1				; 簇（cluster）大小（必须为1个扇区）</span><br><span class="line">		DW		1				; FAT起始位置（一般为第一个扇区）</span><br><span class="line">		DB		2				; FAT个数（必须为2）</span><br><span class="line">		DW		224				; 根目录大小（一般为224项）</span><br><span class="line">		DW		2880			; 该磁盘大小（必须为2880扇区1440*1024&#x2F;512）</span><br><span class="line">		DB		0xf0			; 磁盘类型（必须为0xf0）</span><br><span class="line">		DW		9				; FAT的长度（必??9扇区）</span><br><span class="line">		DW		18				; 一个磁道（track）有几个扇区（必须为18）</span><br><span class="line">		DW		2				; 磁头数（必??2）</span><br><span class="line">		DD		0				; 不使用分区，必须是0</span><br><span class="line">		DD		2880			; 重写一次磁盘大小</span><br><span class="line">		DB		0,0,0x29		; 意义不明（固定）</span><br><span class="line">		DD		0xffffffff		; （可能是）卷标号码</span><br><span class="line">		DB		&quot;HARIBOTEOS &quot;	; 磁盘的名称（必须为11字?，不足填空格）</span><br><span class="line">		DB		&quot;FAT12   &quot;		; 磁盘格式名称（必??8字?，不足填空格）</span><br><span class="line">		RESB	18				; 先空出18字节</span><br><span class="line"></span><br><span class="line">; 程序主体</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">		MOV		AX,0			; 初始化寄存器</span><br><span class="line">		MOV		SS,AX</span><br><span class="line">		MOV		SP,0x7c00</span><br><span class="line">		MOV		DS,AX</span><br><span class="line"></span><br><span class="line">; 读取磁盘</span><br><span class="line"></span><br><span class="line">		MOV		AX,0x0820</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		MOV		CH,0			; 柱面0</span><br><span class="line">		MOV		DH,0			; 磁头0</span><br><span class="line">		MOV		CL,2			; 扇区2</span><br><span class="line"></span><br><span class="line">readloop:</span><br><span class="line">		MOV		SI,0			; 记录失败次数寄存器</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">		MOV		AH,0x02			; AH&#x3D;0x02 : 读入磁盘</span><br><span class="line">		MOV		AL,1			; 1个扇区</span><br><span class="line">		MOV		BX,0</span><br><span class="line">		MOV		DL,0x00			; A驱动器</span><br><span class="line">		INT		0x13			; 调用磁盘BIOS</span><br><span class="line">		JNC		next			; 没出错则跳转到fin</span><br><span class="line">		ADD		SI,1			; 往SI加1</span><br><span class="line">		CMP		SI,5			; 比较SI与5</span><br><span class="line">		JAE		error			; SI &gt;&#x3D; 5 跳转到error</span><br><span class="line">		MOV		AH,0x00</span><br><span class="line">		MOV		DL,0x00			; A驱动器</span><br><span class="line">		INT		0x13			; 重置驱动器</span><br><span class="line">		JMP		retry</span><br><span class="line">next:</span><br><span class="line">		MOV		AX,ES			; 把内存地址后移0x200（512&#x2F;16十六进制转换）</span><br><span class="line">		ADD		AX,0x0020</span><br><span class="line">		MOV		ES,AX			; ADD ES,0x020因为没有ADD ES，只能通过AX进行</span><br><span class="line">		ADD		CL,1			; 往CL里面加1</span><br><span class="line">		CMP		CL,18			; 比较CL与18</span><br><span class="line">		JBE		readloop		; CL &lt;&#x3D; 18 跳转到readloop</span><br><span class="line">		MOV		CL,1</span><br><span class="line">		ADD		DH,1</span><br><span class="line">		CMP		DH,2</span><br><span class="line">		JB		readloop		; DH &lt; 2 跳转到readloop</span><br><span class="line">		MOV		DH,0</span><br><span class="line">		ADD		CH,1</span><br><span class="line">		CMP		CH,CYLS</span><br><span class="line">		JB		readloop		; CH &lt; CYLS 跳转到readloop</span><br><span class="line"></span><br><span class="line">; 读取完毕，跳转到haribote.sys执行！</span><br><span class="line">		MOV		[0x0ff0],CH		; IPLがどこまで読んだのかをメモ</span><br><span class="line">		JMP		0xc200</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">		MOV		SI,msg</span><br><span class="line"></span><br><span class="line">putloop:</span><br><span class="line">		MOV		AL,[SI]</span><br><span class="line">		ADD		SI,1			; 给SI加1</span><br><span class="line">		CMP		AL,0</span><br><span class="line">		JE		fin</span><br><span class="line">		MOV		AH,0x0e			; 显示一个文字</span><br><span class="line">		MOV		BX,15			; 指定字符颜色</span><br><span class="line">		INT		0x10			; 调用显卡BIOS</span><br><span class="line">		JMP		putloop</span><br><span class="line"></span><br><span class="line">fin:</span><br><span class="line">		HLT						; 让CPU停止，等待指令</span><br><span class="line">		JMP		fin				; 无限循环</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">		DB		0x0a, 0x0a		; 换行两次</span><br><span class="line">		DB		&quot;load error&quot;</span><br><span class="line">		DB		0x0a			; 换行</span><br><span class="line">		DB		0</span><br><span class="line"></span><br><span class="line">		RESB	0x7dfe-$		; 填写0x00直到0x001fe</span><br><span class="line"></span><br><span class="line">		DB		0x55, 0xaa</span><br></pre></td></tr></table></figure>
<p>最后以0x55aa结尾说明是启动区</p>
<p>该启动区代码包含了试错，循环读取扇区和柱面</p>
<p>主要注意：</p>
<ol type="1">
<li><p>第41行：<code>MOV        AX,0x0820</code></p>
<p>这段是把第一个柱面的第二个扇区（第一个为启动扇区），加载到内存<code>0x8200</code>的位置，0x13通过段寄存器ES和BX设置，这里ES为<code>0x0820</code>需要扩大16倍即为<code>0x8200</code></p>
<p>这里BIOS将系统启动代码（第一个扇区）加载到<code>0x8000</code>处，然后我们的IPL加载之后的扇区，所以将AX赋值为<code>0x0820</code>然后在赋值给ES</p></li>
<li><p>第82行：<code>JMP        0xc200</code></p>
<p>这里是启动区代码执行成功后，跳转到<code>0xc200</code>处执行代码</p>
<p>我们的真正的OS代码保留在软盘的<code>0x4200</code>的位置，软盘的第一个扇区的位置是<code>0x8000</code>所以有<code>0x8000+0x4200 = 0xc200</code>，所以跳转到此位置</p>
<p><code>0x4200</code>是因为向软盘写文件时一帮保存到此位置</p></li>
<li><p>第107行：<code>RESB  0x7dfe-$        ; 填写0x00直到0x001fe</code></p>
<p>只是将启动区后续部分填充为0</p>
<p><code>0x7dfe = 0x7c00 + 511</code>得到，表示512字节的启动区</p></li>
</ol>
<h2 id="导入c语言">5. 导入C语言</h2>
<p>文章中将C语言代码<code>bootpack.c</code>编译为32位汇编，要使用C语言，在操作系统中必然是C语言和汇编是混合复用的，所以需要专门的代码进行链接，文章中给出的是<code>asmhead.nas</code>,这里进行了对显卡显示模式的设置，以及对C语言的导入操作，可以到此文件中看一看，作者给出了很清楚的注释。（中文代码：https://github.com/yourtion/30dayMakeOS/blob/master/03_day/）</p>
<p>对C语言的处理作者分为以下几步：</p>
<ul>
<li>使用cc1.exe从bootpack.c生成bootpack.gas</li>
<li>使用gas2nask.exe从bootpack.gas生成bootpack.nas</li>
<li>使用nask.exe从bootpack.nas生成bootpack.obj</li>
<li>使用obj2bim.exe从bootpack.obj生成bootpack.bim</li>
<li>使用bim2hrb.exe从bootpack.bim生成bootpack.hrb</li>
<li>这样就做成了机器语言， 再使用copy指令将asmhead.bin与bootpack.hrb单纯结合到起来， 就成了haribote.sys</li>
</ul>
<p><code>cc1</code>是C编译器， 将C语言代码编译为32位的GAS的汇编代码</p>
<p><code>gas2nask</code>是将gas汇编编译为nasm识别的汇编格式了,通过nask（nasm）编译位OBJ目标文件</p>
<p><code>obj2bim</code>将目标文件编译为二进制镜像文件，方便不同的目标文件进行合并</p>
<p><code>bim2hrb</code>将最后的合并目标文件编译为<code>hrb</code>文件（这个是适合作者的这个编译环境的最终二进制文件）</p>
<h3 id="c语言调用汇编">C语言调用汇编</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]				; 制作目标文件的模式	</span><br><span class="line">[BITS 32]						; 制作32位模式用的机器语言</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 制作目标文件的信息</span><br><span class="line"></span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]			; 源文件名信息</span><br><span class="line"></span><br><span class="line">		GLOBAL	_io_hlt			; 程序中包含的函数名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 以下是实际的函数</span><br><span class="line"></span><br><span class="line">[SECTION .text]		; 目标文件中写了这些后再写程序</span><br><span class="line"></span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>将此文件的<code>obj</code>文件和C语言的<code>obj</code>文件一起编译为<code>bim</code>即可(使用作者自带的工具)</p>
<p>有几个需要注意的地方：</p>
<ol type="1">
<li>需要和C语言链接的函数都需要标识为<code>GLOBAL</code>，反义为<code>LOCAL</code></li>
<li>导出的函数需要前加<code>_</code>，这样才能和C语言链接，C语言编译后的函数会加<code>_</code></li>
</ol>
<p>可以看看作者的<code>Makefile</code>可以更好的明白整个编译的过程</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Tutorial &amp; Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>图像旋转算法实现 Python</title>
    <url>/2019/05/12/2019-05-13-Img_Rotation/</url>
    <content><![CDATA[<h3 id="旋转原理">旋转原理</h3>
<blockquote>
<p>参考博客：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXVhbjAyL2FydGljbGUvZGV0YWlscy82NzUwODI4" title="https://blog.csdn.net/liyuan02/article/details/6750828">https://blog.csdn.net/liyuan02/article/details/6750828<i class="fa fa-external-link"></i></span></p>
</blockquote>
<a id="more"></a>
<p>如下图，推导点$(x_0,y_0) <span class="math inline">\(旋转\)</span><span class="math inline">\(到到点\)</span>(x,y)$，半径为R</p>
<p><img src="/assets/ArticleImg/2019/ImgRotation_1.png" /></p>
<p>对于两点坐标可以这样表示：</p>
<p><span class="math display">\[
\begin{align}
x_0 =&amp; R*\cos\alpha \\
y_0 =&amp; R*\sin\alpha \\
For:x\\
x =&amp; R*\cos(\alpha-\theta) \\
=&amp; R*(\cos\alpha\cos\theta+\sin\alpha\sin\theta) \\
=&amp; x_0\cos\theta+y_0\sin\theta \\
For:y\\
y =&amp; R*(\sin(\alpha-\theta)) \\
=&amp; R*(\sin\alpha\cos\theta-\cos\alpha\sin\theta) \\
=&amp; y_0\cos\theta-x_0\sin\theta
\end{align}
\]</span></p>
<p>使用矩阵表示有：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
\]</span></p>
<p>此为顺时针旋转<span class="math inline">\(\theta\)</span> ，逆时针旋转<span class="math inline">\(\theta\)</span>只需要将 <span class="math inline">\(\theta=-\theta\)</span> 即可，易得：<span class="math inline">\((x,y)\rightarrow(x_0,y_0)\)</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
\]</span></p>
<h3 id="用于实际的旋转矩阵">用于实际的旋转矩阵</h3>
<p>上一部分的旋转矩阵是以数字坐标系推导的，而图像坐标系是以左上角为原点的图像坐标系，我们需要将图像坐标系转换为数字坐标系，方便的也需要从数字坐标系到图像坐标系的逆转换</p>
<p>假设原图片大小为<span class="math inline">\(W,H\)</span>，旋转后所包含图片的最小矩形大小为<span class="math inline">\(W^{&#39;},H^{&#39;}\)</span></p>
<p>设数字坐标系点为<span class="math inline">\((x,y)\)</span>其相应的图像坐标系点为 <span class="math inline">\((x_0,y_0)\)</span> 有如下表达式：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
-0.5W &amp; 0.5H &amp; 1
\end{matrix} \right]
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]
\]</span></p>
<p>假设在图像坐标系中有点<span class="math inline">\((x_0,y_0)\)</span>顺时针旋转<span class="math inline">\(\theta\)</span> 到<span class="math inline">\((x,y)\)</span>处转换后大小为<span class="math inline">\(W^{&#39;},H^{&#39;}\)</span>，转换公式有：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix}
\right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix}
\right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp;0 \\
-0.5W &amp; 0.5H &amp; 0 \\
\end{matrix}
\right]
*
\left[
\begin{matrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]\tag{1}
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix}
\right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix}
\right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
-0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp;0 \\
0.5W &amp; 0.5H &amp; 0 \\
\end{matrix}
\right]\tag{2}
\]</span></p>
<p>(1)式为前向映射（直接从原图映射到旋转后的图），（2）式为后向映射（用于旋转后映射到旋转前）</p>
<h4 id="为什么需要后向映射而不是前向映射">为什么需要后向映射而不是前向映射</h4>
<p>之所以有<strong>后向映射</strong>是因为在<strong>前向映射</strong>中获取的旋转后坐标是浮点数，但是像素只能是整数，所以就产生了像素缺失</p>
<p>而从后向前映射像素信息都是存在的，但又存在映射到原图中的浮点坐标改如何选择颜色信息的问题</p>
<p>这就有内插值的问题，提供的解决办法有三个，<strong>最邻近内插</strong>、<strong>双线性内插</strong>、<strong>双三次内插</strong>，最邻近就是直接对浮点坐标取整，取最接近它的像素值，双线性内插就是取与它相邻的4个点，求线性渲染值</p>
<p>其本质就是：假设在数轴上有两个点A，B（A&lt;B) AB中间有个点X，那么双线性内插就和知道X到点A的距离求X的值是一个道理，不过双线性需要对X和Y两个方向求值</p>
<p>双三次内插有点麻烦，这里。。我也不清楚，嘿嘿</p>
<p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb21pbjFoYW8vYXJ0aWNsZS9kZXRhaWxzLzgxMDkyMTM0" title="https://blog.csdn.net/caomin1hao/article/details/81092134">https://blog.csdn.net/caomin1hao/article/details/81092134<i class="fa fa-external-link"></i></span></p>
<h3 id="python-实践">Python 实践</h3>
<p>所需外部库：</p>
<ul>
<li>numpy（矩阵计算）</li>
<li>matplotlib (效果演示)</li>
<li>skimage （只读取使用其内置图片 换cv2读自己图片也可以）</li>
</ul>
<blockquote>
<p>使用按像素遍历，比较耗时</p>
</blockquote>
<p>后向映射中使用最邻近内插和双线性内插（双三次内插暂未处理）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> skimage.data</span><br><span class="line"><span class="keyword">import</span> skimage.io</span><br><span class="line"></span><br><span class="line">angle = <span class="number">30</span>*np.pi/<span class="number">180</span></span><br><span class="line"><span class="comment"># 读取库图片 Attention 转换 默认为int8 运算时可能会溢出</span></span><br><span class="line">img = skimage.data.chelsea().astype(int)</span><br><span class="line"><span class="comment"># 设置新的图像大小</span></span><br><span class="line">h,w = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line">newW = int(w*abs(np.cos(angle)) + h*abs(np.sin(angle)))+<span class="number">1</span></span><br><span class="line">newH = int(w*abs(np.sin(angle)) + h*abs(np.cos(angle)))+<span class="number">1</span></span><br><span class="line"><span class="comment"># Attention dtype</span></span><br><span class="line">newimg1 = np.zeros((newH,newW,<span class="number">3</span>),dtype = int)</span><br><span class="line">newimg2 =  np.zeros((newH,newW,<span class="number">3</span>),dtype = int)</span><br><span class="line">newimg3 =  np.zeros((newH,newW,<span class="number">3</span>),dtype = int)</span><br><span class="line"><span class="comment"># 设置旋转矩阵 scr -&gt; dex</span></span><br><span class="line">trans1 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">-0.5</span>*w,<span class="number">0.5</span>*h,<span class="number">1</span>]])</span><br><span class="line">trans1 = trans1.dot(np.array([[np.cos(angle),-np.sin(angle),<span class="number">0</span>],[np.sin(angle),np.cos(angle),<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br><span class="line">trans1 = trans1.dot(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">0.5</span>*newW,<span class="number">0.5</span>*newH,<span class="number">1</span>]]))</span><br><span class="line"><span class="comment"># des -&gt; src</span></span><br><span class="line">trans2 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">-0.5</span>*newW,<span class="number">0.5</span>*newH,<span class="number">1</span>]])</span><br><span class="line">trans2 = trans2.dot(np.array([[np.cos(angle),np.sin(angle),<span class="number">0</span>],[-np.sin(angle),np.cos(angle),<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br><span class="line">trans2 = trans2.dot(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">0.5</span>*w,<span class="number">0.5</span>*h,<span class="number">1</span>]]))</span><br><span class="line"><span class="comment"># 开始旋转</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(h):</span><br><span class="line">        newPos = np.array([x,y,<span class="number">1</span>]).dot(trans1)</span><br><span class="line">        newimg1[int(newPos[<span class="number">1</span>])][int(newPos[<span class="number">0</span>])] = img[y][x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(newW):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(newH):</span><br><span class="line">        srcPos = np.array([x,y,<span class="number">1</span>]).dot(trans2)</span><br><span class="line">        <span class="keyword">if</span> srcPos[<span class="number">0</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> srcPos[<span class="number">0</span>] &lt; w <span class="keyword">and</span> srcPos[<span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> srcPos[<span class="number">1</span>] &lt; h:</span><br><span class="line">            <span class="comment"># 最邻近内插</span></span><br><span class="line">            newimg2[y][x] = img[int(srcPos[<span class="number">1</span>])][int(srcPos[<span class="number">0</span>])]</span><br><span class="line">            <span class="comment"># 双线性内插</span></span><br><span class="line">            bix,biy = int(srcPos[<span class="number">0</span>]),int(srcPos[<span class="number">1</span>]) <span class="comment"># 取左上角坐标</span></span><br><span class="line">            <span class="comment"># 避免最后一行溢出</span></span><br><span class="line">            <span class="keyword">if</span> bix &lt; w<span class="number">-1</span> <span class="keyword">and</span> biy &lt; h<span class="number">-1</span>:</span><br><span class="line">                <span class="comment"># 沿 X 方向线性内插</span></span><br><span class="line">                rgbX1 = img[biy][bix] + (img[biy][bix+<span class="number">1</span>] - img[biy][bix])*(srcPos[<span class="number">0</span>]-bix)</span><br><span class="line">                rgbX2 = img[biy+<span class="number">1</span>][bix] + (img[biy+<span class="number">1</span>][bix+<span class="number">1</span>] - img[biy+<span class="number">1</span>][bix])*(srcPos[<span class="number">0</span>]-bix)</span><br><span class="line">                <span class="comment"># 沿 Y  方向内插</span></span><br><span class="line">                rgb = rgbX1 + (rgbX2-rgbX1)*(srcPos[<span class="number">1</span>]-biy)</span><br><span class="line">                newimg3[y][x] = rgb</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sub.set_title(<span class="string">"Src Img"</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sub.set_title(<span class="string">"Src-&gt;Des"</span>)</span><br><span class="line">plt.imshow(newimg1)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sub.set_title(<span class="string">"Des-&gt;Src &amp; Nearest"</span>)</span><br><span class="line">plt.imshow(newimg2)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">sub.set_title(<span class="string">"Des-&gt;Src &amp; Bilinear"</span>)</span><br><span class="line">plt.imshow(newimg3)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="效果图展示">效果图展示</h3>
<p><img src="\assets\ArticleImg\2019\ImgRotation_2.png" /></p>
<p>可以看出来双线性比最邻近好的多了</p>
<p><img src="\assets\ArticleImg\2019\ImgRotation_3.png" /></p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CYK Algorithm</title>
    <url>/2019/05/03/2019-05-03-CYK/</url>
    <content><![CDATA[<blockquote>
<p>原理参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NzYWFsa2poZ2YvYXJ0aWNsZS9kZXRhaWxzLzgwNDM1Njc2" title="https://blog.csdn.net/ssaalkjhgf/article/details/80435676">https://blog.csdn.net/ssaalkjhgf/article/details/80435676<i class="fa fa-external-link"></i></span></p>
</blockquote>
<a id="more"></a>
<h3 id="实现过程">实现过程</h3>
<h4 id="类说明">类说明</h4>
<h5 id="cnf">CNF</h5>
<p>由一个字典初始化，输入为规范的范式</p>
<p><code>find_product</code>方法实现输入一个变元组合返回其生成变元</p>
<h5 id="cyk">CYK</h5>
<p>由一个CNF初始化，<code>find</code>方法用于判断字符串是否在CNF中</p>
<p>并保存推导过程，即动态规划数组</p>
<h5 id="input">Input</h5>
<p>实现自己的输入函数，一直等待输入直到输入EOF（Ctrl + Z）</p>
<p>并对输入字符串进行简单处理，切分</p>
<p>输入字符串格式为：<span class="math display">\[A -&gt; BC|AD|b \]</span></p>
<p>其中空格可含可不含</p>
<h5 id="visualization">Visualization</h5>
<p>可视化类，将推导过程输出到<code>.csv</code>文件中</p>
<p>将<code>.csv</code>文件使用<strong>Excel</strong>打开便可查看完整推导过程</p>
<p>代码中已有完整注释和使用说明</p>
<h4 id="代码">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Used for judging a string whether be in the CFL (presented in CNF) using CYK algorithm</span></span><br><span class="line"><span class="string">Author: JOke-Lin</span></span><br><span class="line"><span class="string">Time: 2019-4-27</span></span><br><span class="line"><span class="string">Introduction: </span></span><br><span class="line"><span class="string">    For reading CNF you should use the format "A -&gt; BC|a|b" (the blank space is allowed except "-&gt;")</span></span><br><span class="line"><span class="string">    The first character will be considered as CFL's Start Symbol</span></span><br><span class="line"><span class="string">    And end inputing by input "Ctrl + Z"</span></span><br><span class="line"><span class="string">    For testing strings, you can input as many as strings you want</span></span><br><span class="line"><span class="string">    And exit by using "ctrl + Z"</span></span><br><span class="line"><span class="string">    For Output, the output format is the .csv file whcih should be checked by Excel</span></span><br><span class="line"><span class="string">    The output file name can be changed in codes (the default is "result.csv")</span></span><br><span class="line"><span class="string">Attention:</span></span><br><span class="line"><span class="string">    When you test a new string, you must closed the last .csv file</span></span><br><span class="line"><span class="string">    Otherwise you will meet a I/O Error because the read-write conflict</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNF</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cnf: dict)</span>:</span></span><br><span class="line">        <span class="string">''' cnf: [str:list] '''</span></span><br><span class="line">        self.cnf = cnf</span><br><span class="line">        self.S = list(cnf.keys())[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_product</span><span class="params">(self, target: str)</span>:</span></span><br><span class="line">        <span class="string">''' find the productor  '''</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.cnf.items():</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> value:</span><br><span class="line">                res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CYK</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cnf: CNF)</span>:</span></span><br><span class="line">        self.cnf = cnf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, target: str)</span>:</span></span><br><span class="line">        <span class="string">''' judge if the target is in the CNF '''</span></span><br><span class="line">        self.dp_mat = [[<span class="string">""</span>]*len(target) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target))]</span><br><span class="line">        <span class="comment"># initialize</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target)):</span><br><span class="line">            self.dp_mat[i][i] = list(set(self.cnf.find_product(target[i])))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> range(<span class="number">2</span>, len(target) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i,j are the position in dp_mat</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target) - length + <span class="number">1</span>):</span><br><span class="line">                j = i + length - <span class="number">1</span></span><br><span class="line">                temp = []</span><br><span class="line">                <span class="comment"># split the sub_target</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i, j):</span><br><span class="line">                    list1 = self.dp_mat[i][k]</span><br><span class="line">                    list2 = self.dp_mat[k+<span class="number">1</span>][j]</span><br><span class="line">                    temp += self.find_product(list1, list2)</span><br><span class="line">                self.dp_mat[i][j] = list(set(temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cnf.S <span class="keyword">in</span> self.dp_mat[<span class="number">0</span>][len(target) - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_product</span><span class="params">(self, list1: list, list2: list)</span>:</span></span><br><span class="line">        <span class="string">''' find all productions from Cartesian product of two lists '''</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(list2)):</span><br><span class="line">                temp = self.cnf.find_product(list1[i]+list2[j])</span><br><span class="line">                <span class="keyword">if</span> temp != <span class="literal">None</span>:</span><br><span class="line">                    res += temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span>:</span></span><br><span class="line">    <span class="string">''' my input class for reading the CNF '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDictItemFromInput</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        s = s.replace(<span class="string">' '</span>, <span class="string">''</span>)  <span class="comment"># delete extra blank spacing</span></span><br><span class="line">        temp = s.split(<span class="string">"-&gt;"</span>)</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">0</span>], temp[<span class="number">1</span>].split(<span class="string">"|"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getInput</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">''' return a dict CNF '''</span></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                s = input()</span><br><span class="line">                dict_item = self.getDictItemFromInput(s)</span><br><span class="line">                res[dict_item[<span class="number">0</span>]] = dict_item[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visualization</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    make the deduction visualized</span></span><br><span class="line"><span class="string">    use dp_mat from class CYK to initialize</span></span><br><span class="line"><span class="string">    and creat .csv file to show in Excel</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data: list)</span>:</span></span><br><span class="line">        self.data = [[<span class="string">""</span>]*len(data) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">            temp = data[i][i:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(data) - i):</span><br><span class="line">                self.data[len(data) - j - <span class="number">1</span>][i] = temp[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seeAsCsv</span><span class="params">(self, filename: str)</span>:</span></span><br><span class="line">        <span class="string">''' write data to filename as .csv '''</span></span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data)):</span><br><span class="line">                line = <span class="string">""</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(self.data[i])):</span><br><span class="line">                    temp = <span class="string">""</span></span><br><span class="line">                    <span class="keyword">if</span> type(self.data[i][j]) == str:</span><br><span class="line">                        temp = self.data[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        temp = <span class="string">"\"X&#123;&#125;,&#123;&#125;="</span>.format(j+<span class="number">1</span>,len(self.data)-i)+<span class="string">"&#123;"</span></span><br><span class="line">                        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(self.data[i][j])):</span><br><span class="line">                            temp = temp + self.data[i][j][k]</span><br><span class="line">                            <span class="keyword">if</span> k != len(self.data[i][j]) - <span class="number">1</span>:</span><br><span class="line">                                temp = temp + <span class="string">","</span></span><br><span class="line">                        temp = temp + <span class="string">"&#125;\""</span></span><br><span class="line">                    line = line + temp + <span class="string">","</span></span><br><span class="line">                f.write(line + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"Please Input the CNF: (The First Character must be Start symbol until Ctrl+Z )"</span>)</span><br><span class="line">    myinput = Input()</span><br><span class="line">    <span class="comment"># get the CNF read until miss ctrl + Z</span></span><br><span class="line">    data_dict = myinput.getInput()</span><br><span class="line">    <span class="comment"># creat my CYK algorithm</span></span><br><span class="line">    cyk = CYK(CNF(data_dict))</span><br><span class="line">    print(<span class="string">"input the string: (until Ctrl+Z)"</span>)</span><br><span class="line">    <span class="comment"># test the input string until read the ctrl + z</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            target_str = input()</span><br><span class="line">            <span class="keyword">if</span> cyk.find(target_str):</span><br><span class="line">                print(<span class="string">"Yes"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"No"</span>)</span><br><span class="line">            visual = Visualization(cyk.dp_mat)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                visual.seeAsCsv(<span class="string">"result.csv"</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">"Write Error: Please Close Last csv file"</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Compute Theory</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图像库stb_image &amp; stb_image_write</title>
    <url>/2019/02/24/2019-02-24-stb_image/</url>
    <content><![CDATA[<blockquote>
<p>Github: https://github.com/nothings/stb/</p>
</blockquote>
<h2 id="stb_image">stb_image</h2>
<blockquote>
<p>stb的库像素数据都是从左到右，从上到下存储</p>
<p>使用 stbi_set_flip_vertically_on_load(true); 上下翻转</p>
<p>使用 stbi_flip_vertically_on_write(true); 在写数据的时候翻转 （在stb_write_image中）</p>
</blockquote>
<a id="more"></a>
<h3 id="使用库">- 使用库</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;...&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION	<span class="comment">// include之前必须定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stb_image.h"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="局限">- 局限</h3>
<ul>
<li>no 12-bit-per-channel JPEG</li>
<li>no JPEGs with arithmetic coding</li>
<li>GIF always returns *comp=4</li>
</ul>
<h3 id="基础用法">- 基础用法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">"filename"</span>,&amp;x,&amp;y,&amp;n,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// filename : 文件名</span></span><br><span class="line"><span class="comment">// x : 图片宽 </span></span><br><span class="line"><span class="comment">// y : 图片高</span></span><br><span class="line"><span class="comment">// n : 颜色通道个数</span></span><br><span class="line"><span class="comment">// 最后一个为自己设置的颜色通道个数，如果非0就按照此数值读取图像</span></span><br><span class="line"><span class="comment">// 返回值非NULL说明导入成功</span></span><br><span class="line"><span class="comment">// Do Something</span></span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure>
<h4 id="颜色通道">颜色通道</h4>
<ul>
<li>1： 灰度图</li>
<li>2： 灰度Alpha图</li>
<li>3： 红绿蓝三色图</li>
<li>4： 红绿蓝三色Alpha图</li>
</ul>
<h4 id="错误信息">错误信息</h4>
<figure class="highlight plain"><figcaption><span>char* stbi_failure_reason()```返回错误信息字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 定义 STBI_NO_FAILURE_STRINGS  避免编译这些字符串</span><br><span class="line">- 定义 STBI_FAILURE_USERMSG 使错误信息更加容易阅读</span><br><span class="line"></span><br><span class="line">#### Unicode</span><br><span class="line"></span><br><span class="line">Windows环境下可能需要满足Unicode的文件名</span><br><span class="line"></span><br><span class="line">&#96;#define STBI_WINDOWS_UTF8&#96;可以使文件名满足Unicode</span><br><span class="line"></span><br><span class="line">也可以使用&#96;stbiw_convert_wchar_to_utf8&#96;将&#96;Windows wchar_t&#96; 转换为 &#96;utf8&#96;.</span><br><span class="line"></span><br><span class="line">#### Addition</span><br><span class="line"></span><br><span class="line">- 预编译取消对某个格式的解析 ：#define STBI_NO_PNG....</span><br><span class="line">- 预编译限制只能某个格式解析 ：#define STBI_ONLY_PNG...</span><br><span class="line"></span><br><span class="line">### Else</span><br><span class="line"></span><br><span class="line">获取x,y位置的像素信息，data为图像指针,n为颜色通道数</span><br><span class="line"></span><br><span class="line">data[w\*n\*x+n\*y+i] (i &#x3D; 0,1,..,n-1)</span><br><span class="line"></span><br><span class="line">作者还介绍了 SIMD支持， HDR图像支持， Iphone PNG支持</span><br><span class="line"></span><br><span class="line">## stb_image_write</span><br><span class="line"></span><br><span class="line">### - 使用库</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#include &lt;...&gt;</span><br><span class="line">#define #define STB_IMAGE_WRITE_IMPLEMENTATION	&#x2F;&#x2F; include之前必须定义</span><br><span class="line">#include &quot;stb_image_write.h&quot;</span><br></pre></td></tr></table></figure>
<h3 id="简单的使用">- 简单的使用</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stbi_write_png</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">int</span> stride_in_bytes)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_bmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_tga</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_jpg</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">int</span> quality)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_hdr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">float</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="else">- Else</h3>
<p>作者还提到了PNG压缩，可提供自己的压缩函数，还有JPG质量的参数</p>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image_write.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span> alpha, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span> </span>&#123;</span><br><span class="line">	data[w*n*x + y * n + n - <span class="number">1</span>] = alpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *filepath = <span class="string">"demo.png"</span>;</span><br><span class="line">	<span class="keyword">int</span> w, h, n;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(filepath, &amp;w, &amp;h, &amp;n, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROE_FILE_NOT_LOAD"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span> &lt;&lt; h &lt;&lt; <span class="string">" "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">// 将上半身设置为透明</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">				setAlpha(i, j, n, w, <span class="number">0</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写的时候翻转</span></span><br><span class="line">		stbi_flip_vertically_on_write(<span class="literal">true</span>);</span><br><span class="line">		stbi_write_png(<span class="string">"out.png"</span>, w, h, n, data, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">        stbi_image_free(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原图像 <img src="https://img-blog.csdnimg.cn/20190224135232798.png" alt="在这里插入图片描述" /></li>
<li>处理后 <img src="https://img-blog.csdnimg.cn/20190224135301289.png" alt="在这里插入图片描述" /></li>
</ul>
<p>作者还有一个<code>stb_image_resize.h</code>支持对图像的简单放缩平移等操作</p>
]]></content>
      <categories>
        <category>Tutorial &amp; Note</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Life Record 1</title>
    <url>/2019/02/21/2019-02-21-Life/</url>
    <content><![CDATA[<blockquote>
<p>2019正月至开学前一天</p>
</blockquote>
<ul>
<li><p>2018下学期的离散70+</p></li>
<li><p>老弟学会吞药</p></li>
<li><p>没有钱是万万不能的</p></li>
<li><p>人老了是真的可怜</p></li>
<li><p>呆在家里真好</p></li>
</ul>
<a id="more"></a>
<h2 id="新年flag">新年Flag</h2>
<p>是时候真正努力了，自己还是很自私的，</p>
<p>改掉这些毛病，做一件事就认真去做，马上去做，时间是真的会消磨人</p>
<p>自以为自我控制能力很好，也就是自欺欺人罢了</p>
<p>坦白吧，多去图书馆，学习为什么怕别人知道呢</p>
<p>再加一条，多锻炼</p>
<p>做个爱学习的人吧 ：）</p>
<p>—— 2019-2-21 绿皮火车</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
  </entry>
  <entry>
    <title>Virtual Box 配置虚拟机 Ubuntu</title>
    <url>/2019/02/14/2019-02-14-VirtualBox_Ubuntu/</url>
    <content><![CDATA[<h2 id="虚拟机的简单概念">虚拟机的简单概念</h2>
<blockquote>
<p>摘自百度百科</p>
</blockquote>
<p>​ 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 ​ 虚拟系统通过生成现有操作系统的全新虚拟镜像，它具有真实windows系统完全一样的功能，进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 ，而且具有能够在现有系统与虚拟镜像之间灵活切换的一类操作系统。虚拟系统和传统的虚拟机（Parallels Desktop ，Vmware，VirtualBox，Virtual pc）不同在于：虚拟系统不会降低电脑的性能，启动虚拟系统不需要像启动windows系统那样耗费时间，运行程序更加方便快捷；虚拟系统只能模拟和现有操作系统相同的环境，而虚拟机则可以模拟出其他种类的操作系统；而且虚拟机需要模拟底层的硬件指令，所以在应用程序运行速度上比虚拟系统慢得多。</p>
<a id="more"></a>
<h2 id="下载-virtual-box">1. 下载 Virtual Box</h2>
<h3 id="下载位置">下载位置</h3>
<p><code>https://www.virtualbox.org/wiki/Downloads</code></p>
<p>下载相应的版本即可</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_1.jpg" alt="Download_Virtual_Box" /><figcaption>Download_Virtual_Box</figcaption>
</figure>
<h2 id="下载ubuntu镜像文件">2. 下载Ubuntu镜像文件</h2>
<h3 id="下载位置-1">下载位置</h3>
<p><strong>官方网站：</strong><code>https://www.ubuntu.com/download/desktop</code></p>
<p><strong>网易镜像：</strong><code>http://mirrors.163.com/ubuntu-releases/</code> =&gt; <strong>ubuntu-18.10-desktop-amd64.iso</strong></p>
<p>选一个合适的版本即可 这里采用的是Ubuntu-18.10, 国内镜像可能会快一些，你也可以采用其他镜像源</p>
<h2 id="开始安装">3. 开始安装</h2>
<h3 id="新建虚拟机">- 新建虚拟机</h3>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_2.jpg" alt="add a VM" /><figcaption>add a VM</figcaption>
</figure>
<p>后面都只需要默认即可</p>
<h3 id="配置选项">- 配置选项</h3>
<p>在这里设置内存大小，处理器等设置，内存、处理器酌情增加，太小巨卡</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_3.jpg" alt="set VM" /><figcaption>set VM</figcaption>
</figure>
<p>在第二个小光盘出点击选择一个虚拟光盘文件，也就是前面下载的Ubuntu镜像文件</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_4.jpg" alt="set VM" /><figcaption>set VM</figcaption>
</figure>
<h3 id="双击开启安装">- 双击开启安装</h3>
<p>语言可以先设置为中文简体，后面都只需要默认即可</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_5.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_9.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_6.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_7.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_8.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<h3 id="最后重启即可">- 最后重启即可</h3>
<h3 id="注意事项">- 注意事项</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qaW5neWFuLmJhaWR1LmNvbS9hcnRpY2xlL2FiMGI1NjMwNWYyODgyYzE1YWZhN2RkYS5odG1s" title="https://jingyan.baidu.com/article/ab0b56305f2882c15afa7dda.html">BIOS可能未开启虚拟化<i class="fa fa-external-link"></i></span></p>
<p>一般不行就删掉重新来一遍，一般都可以</p>
<p>处理器最好选择2个以上，不然容易中途安装失败</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Tutorial &amp; Note</category>
      </categories>
  </entry>
  <entry>
    <title>IF I STAY</title>
    <url>/2019/01/12/2019-01-12-If_I_Stay/</url>
    <content><![CDATA[<blockquote>
<p>A Song To Share And Save</p>
</blockquote>
<a id="more"></a>
<h1 id="if-i-stay">IF I STAY</h1>
<figure>
<img src="/assets/ArticleImg/Life/If_I_Stay.jpg" alt="if i stay" /><figcaption>if i stay</figcaption>
</figure>
<p>作曲 : <strong><em>逃跑计划</em></strong></p>
<p>作词 : <strong><em>Shaun Gibson</em></strong></p>
<p><a href="http://music.163.com/song?id=37782201&amp;userid=592448485" target="_blank" rel="noopener"><strong>Click To Listening</strong></a></p>
<p><strong>Don’t you ever question why</strong></p>
<p>你从未问过我</p>
<p><strong>I’m by your side</strong></p>
<p>为何我会陪伴在你左右</p>
<p><strong>I’m here when you cry</strong></p>
<p>你哭泣时我在你身旁</p>
<p><strong>Cause he told you lies so slyly</strong></p>
<p>因为他那么狡猾 对你说尽谎言</p>
<p><strong>I run my fingers through your hair</strong></p>
<p>我的手指穿过你的秀发</p>
<p><strong>And show I care</strong></p>
<p>对你表明我多么在乎你</p>
<p><strong>But I’m not the one</strong></p>
<p>而我却不是那个</p>
<p><strong>That your heart belongs to nightly</strong></p>
<p>你每晚牵挂的唯一</p>
<p><strong>But if I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>I’ve loved you without regret</strong></p>
<p>我爱你无怨无悔</p>
<p><strong>Since the day we met</strong></p>
<p>自从我们相遇的那一天起</p>
<p><strong>If what you see’s what you get</strong></p>
<p>如果眼前的人就是你终会拥有的人</p>
<p><strong>Well I’ve had nothing yet</strong></p>
<p>那我认了 我依然一无所有</p>
<p><strong>For these past years</strong></p>
<p>即使过去了这么多年</p>
<p><strong>Tell me will you ever feel the same</strong></p>
<p>告诉我 你是否有过和我同样的感受</p>
<p><strong>If my love won’t tame?</strong></p>
<p>如果我的爱永不消减</p>
<p><strong>Or just like cellophane</strong></p>
<p>或者它就如玻璃纸一般脆弱</p>
<p><strong>Will I call your name unto deaf ears?</strong></p>
<p>我是否会在你耳畔轻唤你名字 就算你置若罔闻</p>
<p><strong>And if I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>If I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>But if I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
  </entry>
  <entry>
    <title>最短路径的三种算法以及路径还原与负圈判断</title>
    <url>/2018/12/07/2018-12-07-ShortestPath/</url>
    <content><![CDATA[<blockquote>
<p>图的基础，最短路径的几种解答</p>
<p>单源最短路： Bellman-Ford &amp; Dijkstra 及其简单优化 以及负圈的判断</p>
<p>多源最短路：Floyd-Warshall 算法的简单理解</p>
<p>路径还原问题</p>
<p>算法代码及思路主要参考：《挑战程序设计竞赛》</p>
</blockquote>
<p>在此之前读者应对图已经有基础的概念，以及图的邻接表 &amp; 邻接矩阵的表示方法</p>
<a id="more"></a>
<h2 id="bellman-ford">Bellman-Ford</h2>
<p>单源最短路问题是固定一个起点，然后求这个点到其他各个顶点的最短路（最小权值和）</p>
<p>设起点s到其他顶点i的距离为 <strong>d[i]</strong> 则很容易可以得到下面这个结论： <span class="math display">\[
d[i] = min\{d[j] + edge(j,i)\} edge(j,i) \in E 
\]</span> 设置初始状态d[s] = 0 else d[i] = INF 然后只要在循环里不断更新这些值</p>
<p>如果不再更新说明所有路都已达到最短 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> from, to, cost;&#125;; <span class="comment">// 定义从点from指向to权值为cost的边</span></span><br><span class="line">Edge edges[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 最短距离</span></span><br><span class="line"><span class="keyword">int</span> V,E; <span class="comment">// V: 顶点数 E: 边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从点s到其他点的最小距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> isUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            <span class="keyword">if</span>(d[temp.from] != INF &amp;&amp; d[temp.to] &gt; d[temp.from]+temp.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[temp.to] = d[temp.from] + temp.cost;</span><br><span class="line">                isUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isUpdate) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果图中不存在s可达的负圈，那么最短路不会经过一个顶点两次，也就是说 最多通过V-1条边，也可以这样理</p>
<p>解，每一次更新都会有更短的路径产生，那么在V个点的图中，两个点的最远距离只能是V-1条边，所以循环最多</p>
<p>只会执行V-1次，这个特性将是我们判断是否存在负圈的重要性质</p>
<p>所以我们也可以将上面的代码简单化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="comment">// 不存在负圈的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; V<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            d[temp.to] = <span class="built_in">min</span>(d[temp.to],d[temp.from]+temp.cost)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易可以看出来Bellman算法的复杂度为 **O(V*E)**</p>
<h3 id="负圈的判断">负圈的判断</h3>
<p>在这里，首先要明确<strong>负圈（负权环）</strong>和<strong>负权边</strong>的区别</p>
<p>负圈是指一条环状路径上的综合权值为负的，负权边是指权值为负数的边，在算法中如果图是无向图的话，</p>
<p><strong>负权边</strong>和<strong>负圈</strong>是<strong>等价</strong>的。如下图：也就是在A与B之间形成了一个环，这个环的权值为-2</p>
<p><img src="/assets/ArticleImg/2018/shortpath1.png" /></p>
<p>所以在无向图中负边的存在也就是负圈的存在。所以Bellman主要是可以用来判断有向图中是否存在负圈。</p>
<p>只要存在了负圈，那么Bellman的松弛操作（也就是那个每次更新的内容）将会永远的执行下去。</p>
<p>相当于没走一个这个负圈总的权值（路径长度）就会减少。但是我们上面已经得到在不存在负圈的图中最多执行</p>
<p>V-1次循环，所以我们只要判断在第V次仍然更新了，那么就存在负圈了。代码只要更改一点点就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="comment">// 不存在负圈的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            <span class="keyword">if</span>(d[temp.from] != INF &amp;&amp; d[temp.to] &gt; d[temp.from]+temp.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[temp.to] = d[temp.from] + temp.cost;</span><br><span class="line">                <span class="comment">// 只要再次加上到第V-1次的特判</span></span><br><span class="line">                <span class="keyword">if</span>(j == V<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"存在负圈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra">Dijkstra</h2>
<p>我们先考虑不存在负边的情况，在Bellman算法中每一次都要全部遍历所有的边，而且如果d[i]本身不是最短路径</p>
<p>那么进行那个松弛操作之后的d[i]依然不是最短，所以可以对此进行优化：</p>
<ul>
<li><p>找到最短路径已经确定的顶点，更新从他出发相邻顶点的最短距离</p></li>
<li><p>从此不需要在更新上面已经确定的哪些顶点（即不需要遍历）</p></li>
</ul>
<p>这就衍生出了Dijkstra算法。上面两点用图来描述就是：</p>
<p><img src="/assets/ArticleImg/2018/shortpath2.png" /></p>
<p>假设初始点为A首先AC &lt; AB</p>
<p>很清楚的我们可以得出结论AC就是A到C的最短路径，因为如果从AB方向走的话，AB ＞AC 而且我们的图是</p>
<p>没有负边的，所以BD &gt; 0 也就是说AB + BD.... &gt; AC 是必然成立的。 所以A-&gt;C的最短路径已经确定了，之后就</p>
<p>需要再去管C点了。算法总的描述如下：</p>
<blockquote>
<p>在最开始时，只有起点的最短距离是确定的（而且所有点都未曾使用）。而在尚未使用的顶点中，距离d[i]最小的顶点就是最短距离已经确定的顶点。因为不存在负边，所以d[i]不会在以后的更新中变小。这就是Dijkstra算法</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN]; <span class="comment">// cost[i][j] 表示从i到j之间的权值（不存在是为INF）</span></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d,d+V,INF); <span class="comment">// algorithm中的函数 将d数组全部赋为INF</span></span><br><span class="line">    <span class="built_in">fill</span>(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// c从未使用过的点集中取一个距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        	<span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v])) v = u;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有的点的最短路径确定则退出</span></span><br><span class="line">       	used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[u] = <span class="built_in">min</span>(d[u],d[v]+cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单的优化">简单的优化</h3>
<p>上面代码的时间复杂度是 O(V<sup>2</sup>) , 我们可以通过堆（优先队列）降为O(E*log(V))</p>
<p>上面有一个操作是找到距离最小的点和标记是否使用，这个就可以使用堆来优化</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P; <span class="comment">// first 是最短距离 second 是顶点编号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to, cost&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAXN]; <span class="comment">// 使用邻接表存图</span></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que; <span class="comment">// 定义一个堆 从按最短距离小到的大排</span></span><br><span class="line">    <span class="built_in">fill</span>(d,d+V,INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) <span class="comment">// 为空就说明所有节点都已经用过</span></span><br><span class="line">    &#123;</span><br><span class="line">        P temp = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = temp.second;</span><br><span class="line">        <span class="keyword">if</span>(d[v] &lt; temp.first) <span class="keyword">continue</span>; <span class="comment">// 没必要更新了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[v].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[v]+e.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[e.to] = d[v]+e.cost;</span><br><span class="line">                que.push(P(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd-warshall">Floyd-Warshall</h2>
<blockquote>
<p>Floyd算法简单暴力，主要用于求多源最短路径（任意两个点的最短路径）</p>
</blockquote>
<p>核心代码十分短小精悍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAXN][MAXN]; <span class="comment">// d[u][v] 表示从u -&gt; v的权值 不存在的时候为0</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; V;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十分暴力复杂度可想而知O(V<sup>3</sup>)</p>
<p>那么这几行代码是什么意思呢？ 这其实还是DP</p>
<p>我们用<strong>d[k+1][i][j]</strong> 来表示只使用<strong>0~k和i,j</strong>顶点的情况下的最短路</p>
<p>初始状态为<strong>d[0][i][j] = cost[i][j]</strong> 所以我们可以得到下面这个式子： <span class="math display">\[
d[k][i][j] = 
\begin{cases}
d[k-1][i][j] 　(不经过点K)\\
d[k-1][i][k] + d[k-1][k][j]　（经过K点）\\
\end{cases}　＝　min(d[k-1][i][j],d[k-1][i][k] + d[k-1][k][j])
\]</span> 当然 我们可以稍微优化一下，时间以及到极限了，我们可以想办法把空间复杂度降下来</p>
<p>也就是我们上面那个形式，也就是为什么K必须放在最外面的原因</p>
<p>我们观察三维的那个式子与K相关的就只有K与K-1所以我们可以进行降维操作</p>
<p>也就是当K=s的时候，在执行状态压缩之前d[i][j]的值存都是的d[k-1][i][j]</p>
<p>也就是将上一个状态动态保存起来了 所以才有上面的简短的代码</p>
<h2 id="路径还原">路径还原</h2>
<p>最后的问题就是当我们知道最短路径多少的时候，难免有时候需要知道该怎么走才有这条最短路径呢</p>
<p>用 Dijkstra来演示路径还原 其他的算法也都可以用这个来解决</p>
<p>在此算法中满足 d[j] = d[k] + cost[k][j]的点K我们称为j的前驱结点，也就是在到j之前必须经过点K</p>
<p>我们用一个数组prev来存相应节点的前驱结点，不断寻找前驱结点就可以找到最短路了，不过这是从后往前找</p>
<p>最后需要反转一下得到最后的答案。</p>
<p>示例代码如下： 注意第25行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN]; <span class="comment">// cost[i][j] 表示从i到j之间的权值（不存在是为INF）</span></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"><span class="keyword">int</span> prev[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d,d+V,INF); <span class="comment">// algorithm中的函数 将d数组全部赋为INF</span></span><br><span class="line">    <span class="built_in">fill</span>(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">fill</span>(prev,prev+V,<span class="number">-1</span>); <span class="comment">// -1表示到头了 即没有前驱结点</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// c从未使用过的点集中取一个距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        	<span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v])) v = u;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有的点的最短路径确定则退出</span></span><br><span class="line">       	used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[u] = <span class="built_in">min</span>(d[u],d[v]+cost[v][u]);</span><br><span class="line">            prev[u] = v; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到顶点t的最短路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(; t != <span class="number">-1</span>;t = prev[t]) path.push_pack(t);</span><br><span class="line">    reverse(path.<span class="built_in">begin</span>(),path.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>The end</strong> !!!</p>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的二进制阅读器</title>
    <url>/2018/11/02/2018-11-02-BinaryFileReader/</url>
    <content><![CDATA[<blockquote>
<p>在学习BMP位图的构成时，对网上的收费16进制查看器很是烦躁，notepad查看时卡到放弃人生</p>
<p>因为只是为了初步学习图片知识，以及查看2进制文件内部构成的话，可以自己实现一个</p>
</blockquote>
<h2 id="思路">思路</h2>
<ul>
<li><p>使用C++的文件操作进行二进制的读操作，这里默认以1个字节为单位（2位16进制）</p></li>
<li><p>每次读一个字节，就将其转化位16进制，读取的时候需要注意有符号数和无符号数的区别，我这里用<strong>unsigned Char</strong> 来存取每一个字节的内容</p></li>
<li><p>对于C++的文件读写网上很多介绍</p></li>
<li><p>对于每一个读取的数写入文本文件内（.txt文件）便于查看</p></li>
<li><p>计算文件大小 通过C++的文件指针移动即首尾文件指针差除以1024即文件大小（KB）</p></li>
</ul>
<a id="more"></a>
<h2 id="代码如下">代码如下</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> HEX[<span class="number">16</span>] = &#123; <span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfrom</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span>* hexNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hexNumber[i] = <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">while</span> (num != <span class="number">0</span> &amp;&amp; index &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hexNumber[index--] = HEX[num % <span class="number">16</span>];</span><br><span class="line">		num = num / <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getFileName</span><span class="params">(<span class="built_in">string</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = filename.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (filename[i] == <span class="string">'\\'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> filename.substr(index + <span class="number">1</span>, filename.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;    <span class="comment">//The Byte have been read</span></span><br><span class="line">	<span class="built_in">string</span> path_r;</span><br><span class="line">	<span class="built_in">string</span> path_w;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the File for read and write's name: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"The file path to read: "</span>;</span><br><span class="line">		getline(<span class="built_in">cin</span>, path_r);</span><br><span class="line">		in = ifstream(path_r, ios::binary);</span><br><span class="line">		<span class="keyword">if</span> (!in.is_open())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: File Path is Wrong"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Get the file path to Write</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The File Path to save(.txt): "</span>;</span><br><span class="line">	getline(<span class="built_in">cin</span>, path_w);</span><br><span class="line">	out = ofstream(path_w);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Get the File size</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Beg = in.tellg();</span><br><span class="line">	in.seekg(<span class="number">0</span>, ios::<span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> End = in.tellg();</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> fileSize = End - Beg;</span><br><span class="line">	in.seekg(<span class="number">0</span>, ios::beg);</span><br><span class="line">	out &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; getFileName(path_r) &lt;&lt; <span class="string">"\tFile Size: "</span> &lt;&lt; fileSize / <span class="number">1024.0</span> &lt;&lt; 	<span class="string">"KB"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//The index of every row</span></span><br><span class="line">	<span class="keyword">char</span> hexNumber[<span class="number">9</span>] = <span class="string">"00000000"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Print the first row's index</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</span><br><span class="line">	out &lt;&lt; <span class="string">"\t\t"</span>; <span class="comment">//Format index</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) out &lt;&lt; HEX[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">	out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Read and Write File</span></span><br><span class="line">	<span class="keyword">while</span> (in.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;temp, <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			transfrom(num, hexNumber);</span><br><span class="line">			out &lt;&lt; hexNumber &lt;&lt; <span class="string">":\t"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">int</span> hex = (<span class="keyword">unsigned</span>)temp;</span><br><span class="line">		<span class="keyword">char</span> a = HEX[hex / <span class="number">16</span>];</span><br><span class="line">		<span class="keyword">char</span> b = HEX[hex % <span class="number">16</span>];</span><br><span class="line">		out &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out.seekp(<span class="number">0</span>,ios::beg);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Close file</span></span><br><span class="line">	in.<span class="built_in">close</span>();</span><br><span class="line">	out.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Read Successfully"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行说明">运行说明</h2>
<ul>
<li>不能输入输出文件名一致（可以自己试试ㄟ( ▔, ▔ )ㄏ）</li>
<li>首先输入需要读的文件（可以直接将文件拖入黑框 系统会自动输入绝对路径）</li>
<li>然后输入用于保存结果的 TXT 文件（如果不存在则在当前目录新建）</li>
</ul>
<h2 id="运行截图">运行截图</h2>
<blockquote>
<p>以读取Bmp图像为例</p>
</blockquote>
<p><img src="/assets/ArticleImg/2018/BinaryInput.jpg" /></p>
<p><img src="/assets/ArticleImg/2018/BinaryOutput.jpg" /></p>
]]></content>
      <categories>
        <category>ELSE</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串 马拉车算法</title>
    <url>/2018/10/01/2018-10-01-manacher/</url>
    <content><![CDATA[<blockquote>
<p>leetcode5:<code>https://leetcode-cn.com/problems/longest-palindromic-substring/description/</code><br />
可以自己提交看看对不对</p>
</blockquote>
<h2 id="暴力搜索">暴力搜索</h2>
<p>这个应该是最容易的方法了，但是一看复杂度O(n<sup>3</sup>)，还是放弃好了。</p>
<p>但是这个方法也是遍历所有字符串字串的一种方法。下面是暴力搜索的代码：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringForce</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> BeginIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; target.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromeString(target.substring(i, j + <span class="number">1</span>)) &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                BeginIndex = i;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(BeginIndex, BeginIndex + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeString</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = target.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.charAt(l) != target.charAt(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心拓展法">中心拓展法</h2>
<p>这个比暴力搜索复杂度要少一个数量级<br />
为什么呢？它用到了回文串的一个特性左右对称<br />
其实在暴力搜索的判断是否为回文串的时候我们已经用了这个特性了<br />
但是我们是对每一段字串用这个特性<u><strong>即用它去判断而不是去获取</strong></u><br />
所以我们对每一个字符从中间向外展开以获取以此字符为中心的最长回文字串<br />
这样外循环为字符串遍历 内循环为获得回文子串 复杂度最差意思就是O(n<sup>2</sup>)<br />
但是有一个地方必须注意，<u><strong><em>中心拓展</em></strong></u>中心一词是相对于长度为奇数的串的，<br />
对于偶数串我们要单独判断，方法也很简单看看该字符后一个字符是不是一样就行，代码里有解释<br />
代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中心向外拓展</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringCenter</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target; <span class="comment">// 如果是空字符串则直接返回</span></span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">int</span> r = i;</span><br><span class="line">        <span class="comment">// 回文串是奇数</span></span><br><span class="line">        <span class="keyword">while</span> (target.charAt(l) == target.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (l == -<span class="number">1</span> || r == target.length())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; end - beg) &#123;</span><br><span class="line">            beg = l;</span><br><span class="line">            end = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文串是偶数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; target.length() - <span class="number">1</span> &amp;&amp; target.charAt(i + <span class="number">1</span>) == target.charAt(i)) &#123;</span><br><span class="line">            r = i + <span class="number">1</span>;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">while</span> (target.charAt(l) == target.charAt(r)) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span> (l == -<span class="number">1</span> || r == target.length())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; end - beg) &#123;</span><br><span class="line">                beg = l;</span><br><span class="line">                end = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(beg, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp动态规划">Dp动态规划</h2>
<p>字符串类的题目怎么可能少了动态规划呢<br />
那么状态该怎么转移呢</p>
<p><strong><em>dp[i][j] = true ,if dp[i+1][j-1] == true &amp;&amp; str[i]==str[j]</em></strong><br />
否则 <strong><em>dp[i][j] = false</em></strong></p>
<p>至于为什么，因为我们在已经知道串[i,j]是回文字串的时候<br />
只要 <strong><em>str[i-1] == str[j+1]</em></strong> 那么[i-1,j+1]也是一个回文子串<br />
为了更好找到最长所以这里将微循环设置为长度循环，内循环为字串头地址<br />
需要注意的是预处理，每个字母都是一个长度为1 的回文串<br />
和中心拓展类似偶数串中心是两个相同的字母所以还要考虑相邻字母相同的情况<br />
复杂度虽然和中心拓展一个数量级但是还是要比它快许多哦<br />
代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dp动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringDp</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">int</span> len = target.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">int</span> beginIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] isPalindrom = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            isPalindrom[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        isPalindrom[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; target.charAt(i) == target.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            isPalindrom[i][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            beginIndex = i;</span><br><span class="line">            maxLen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> strlen = <span class="number">3</span>; strlen &lt;= len; strlen++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len - strlen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = i + strlen - <span class="number">1</span>; <span class="comment">// 字串结束的位置</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrom[i + <span class="number">1</span>][end - <span class="number">1</span>] == <span class="keyword">true</span> &amp;&amp; target.charAt(i) == target.charAt(end)) &#123;</span><br><span class="line">                isPalindrom[i][end] = <span class="keyword">true</span>;</span><br><span class="line">                maxLen = strlen;</span><br><span class="line">                beginIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(beginIndex, beginIndex + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="manacher算法">Manacher算法</h2>
<p>很多人也许和我一样听到最长回文子串还有O(n)解法的时候是不相信的<br />
但是事实就是如此，这个算法也叫马拉车算法（只是谐音哦）<br />
我认为它也是一种动态规划思想 但是用的更加的巧妙<br />
在某种程度上和KMP算法有异曲同工之处</p>
<h3 id="统一格式化源字符串">1.统一格式化源字符串</h3>
<p>不知道是否有人注意到了上面几种算法在某些方面都考虑奇数串和偶数串的情况<br />
为了简化考虑情况设置一下规则：</p>
<p><span class="math inline">\(abcd\rightarrow \#a\#b\#c\#d\#\)</span></p>
<p>这样所有的字符串就都是奇数串了</p>
<h3 id="设置映射关系">2.设置映射关系</h3>
<p>我们需要的是源字符串啊<br />
处理成那种乱七八糟的字符串，即使得到了结果还要将所有 <strong>#</strong> 取代<br />
所以我们看看能不能找到新串和原串之间的关系<br />
这样处理后表达一个回文串最好的方式就是中心mid（也就是为什么统一为奇数串的原因）和半径来表示r<br />
在我们知道mid和r的时候怎么确定原串呢。<br />
假设有串 <strong><em>#c#a#b#a#</em></strong> 原串是 <strong><em>caba</em></strong><br />
显而易见的是 <strong><em>aba</em></strong> 是回文串a在原串的下标是1<br />
在新串中下标是5，也就是 <strong><em>mid = 5 , r = 4</em></strong><br />
乍一看就是 <strong><em>beginIndex = mid-r</em></strong><br />
但是 <strong><em>#a#b#a# 此时 mid = 3， r = 4</em></strong> 那么 <strong><em>beginIndex = -1</em></strong><br />
显然不对所以我们在最开始处加上一个与#不同的符号$，那么新串即是 $#a#b#a#<br />
此时 <strong><em>mid = 4 r = 4</em></strong> 那就很符合了<br />
但是对 <strong><em>#c#a#b#a#</em></strong> 又不符合了，所以我们找到了新的关系 <strong><em>beginIndex = (mid-r)/2</em></strong> 这是最符合的 感兴趣的小伙伴可以自己推一推</p>
<h3 id="找到-mid-以及-r">3.找到 <strong>mid</strong> 以及 <strong>r</strong></h3>
<p><strong><em>p[i] = mostRight &gt; i ? min(p[2 * mid - i], mostRight - i) : 1;</em></strong><br />
p[i] 为以i为中心的半径 mostRight是已知的回文串右端点最右的那个的下标 mid则是其中心<br />
由于回文串的对称性 <strong><em>p[i] = min(p[2 * mid - i], mostRight - i)</em></strong> p[2*mid-i]是其对称中心点下标<br />
他们两个在以mid为中心的<u><strong>回文串内</strong></u>对称部分相同也就是半径相同(一定注意是回文串内)<br />
在外面的部分我们无从得知只能老老实实匹配 也就是置为1（自己就是回文串）</p>
<h3 id="复杂度">4.复杂度</h3>
<p>因为每次循环内要不是用到以前的结论（对于的中心点）要么就是向右拓展<br />
所以复杂度是O(n)<br />
并不是有两个循环复杂度就是O(n<sup>2</sup>)</p>
<h3 id="代码如下其实先看代码可能更好理解">5.代码如下（其实先看代码可能更好理解）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manacher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringManacher</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    StringBuffer temp = <span class="keyword">new</span> StringBuffer(<span class="string">"$#"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        temp.append(target.charAt(i) + <span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止$#a#b#a# 读到最后a的时候向两边扩散的时候溢出 C++则不需要C++字符串有/0结束符最后加的字符不能为$否则还是会溢出</span></span><br><span class="line">    temp.append(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[temp.length() + <span class="number">1</span>]; <span class="comment">//以i为中心的半径</span></span><br><span class="line">    <span class="keyword">int</span> mostRight = <span class="number">0</span>; <span class="comment">// 已知回文串所能达到的最右边的下标</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">// 已知最右边的回文串的中心下标</span></span><br><span class="line">    <span class="keyword">int</span> resLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> resMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; temp.length() - <span class="number">1</span>; i++) &#123; <span class="comment">// 注意是从1开始第一个字符不算在内</span></span><br><span class="line">        <span class="comment">// 最关键一步 初始化已知的 p[i]</span></span><br><span class="line">        p[i] = mostRight &gt; i ? Math.min(p[<span class="number">2</span> * mid - i], mostRight - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.charAt(i + p[i]) == temp.charAt(i - p[i]))</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (mostRight &lt; i + p[i]) &#123;</span><br><span class="line">            mostRight = i + p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">            resLen = p[i];</span><br><span class="line">            resMid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring((resMid - resLen) / <span class="number">2</span>, (resMid - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果还有疑惑 可以参考下面两篇文章（我觉得很不错的）：<br />
<code>https://www.cnblogs.com/grandyang/p/4475985.html</code>(我也是这里学习的) <code>https://mp.weixin.qq.com/s/Zrj35DrnQKtAENiR5llrcw</code>(漫画的形式讲的很清楚) 不好的地方 欢迎提出(￣▽￣)&quot;</p>
</blockquote>
]]></content>
      <categories>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬取有道翻译</title>
    <url>/2018/09/18/2018-09-18-youdao/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/sss4/p/7809821.html" target="_blank" rel="noopener"><strong>爬虫原理</strong></a></p>
<blockquote>
<p>Attention: Python3 将urlib2 urlib3 结合为urlib</p>
</blockquote>
<ul>
<li><strong>Urlib</strong>:<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhby1hcHBsZTM2L3AvODQzMzQwMC5odG1s" title="https://www.cnblogs.com/xiao-apple36/p/8433400.html">Python3中urllib详细使用方法(header,代理,超时,认证,异常处理)<i class="fa fa-external-link"></i></span></li>
<li><strong>urlib2</strong> :<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0MDk0NDUvYXJ0aWNsZS9kZXRhaWxzLzczNDM4ODE2" title="https://blog.csdn.net/u010409445/article/details/73438816">python urllib2详解及实例(从底层说起)<i class="fa fa-external-link"></i></span></li>
</ul>
<h2 id="基本原理">基本原理</h2>
<ul>
<li><p>通过给网页提供一个数据，然后获取其反馈</p></li>
<li>使用到的模块
<ul>
<li><strong>urllib.request:</strong> 访问网站，提出请求，获取反馈</li>
<li><strong>urllib.parse:</strong> 格式化请求数据</li>
<li><strong>json:</strong> 格式化反馈信息，使其格式化为字典</li>
</ul></li>
<li><p>新版有道翻译爬取实现比较复杂 这里是对老的版本的爬取</p></li>
</ul>
<a id="more"></a>
<h2 id="实现过程及代码">实现过程及代码</h2>
<h3 id="分步解释">分步解释</h3>
<p><strong>1.</strong> 获取处理翻译信息的网页（这里采用的是谷歌浏览器）<br />
打开有道翻译网页 进入开发者模式<br />
选择Network <img src="/assets/ArticleImg/2018/Youdao1.png" alt="Youdao1" /><br />
然后在左边的输入框随便输入一个单词 会发现多了很多文件 <img src="/assets/ArticleImg/2018/Youdao2.png" alt="Youdao2" /> <strong>Headers</strong> 里面就是我们需要发送给他的信息<br />
其中 <strong>Request Url</strong> 就是真正处理翻译的网页<br />
由于我们采用旧版所以将url里的 <strong>&quot;translate_o&quot;</strong> 改为 <strong>&quot;translate&quot;</strong></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 真正翻译的网址 Request Url</span></span><br><span class="line">url = <span class="string">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong> 发送信息包 如下 <img src="/assets/ArticleImg/2018/Youdao3.png" alt="Youdao3" /> 将其包装成字典 并且格式化为网页可以识别的格式</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建列表 模拟传入数据</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">'i'</span>] = String</span><br><span class="line">data[<span class="string">'from'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">data[<span class="string">'to'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">data[<span class="string">'smartresult'</span>] = <span class="string">'dict'</span></span><br><span class="line">data[<span class="string">'client'</span>] = <span class="string">'fanyideskweb'</span></span><br><span class="line">data[<span class="string">'doctype'</span>] = <span class="string">'json'</span></span><br><span class="line">data[<span class="string">'version'</span>] = <span class="string">'2.1'</span></span><br><span class="line">data[<span class="string">'keyfrom'</span>] = <span class="string">'fanyi.web'</span></span><br><span class="line">data[<span class="string">'action'</span>] = <span class="string">'FY_BY_REALTIME'</span></span><br><span class="line">data[<span class="string">'typoResult'</span>] = <span class="string">'false'</span></span><br><span class="line"><span class="comment">#该变格式</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>3.</strong> 获取反馈并处理<br />
<img src="/assets/ArticleImg/2018/Youdao4.png" alt="Youdao4" /></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(url, data)  <span class="comment"># 得到回复</span></span><br><span class="line">html = response.read().decode(<span class="string">'utf-8'</span>)  <span class="comment"># 重新编码</span></span><br><span class="line">result = json.loads(html)  <span class="comment"># json 字典化</span></span><br><span class="line"><span class="comment"># return result["translateResult"][0][0]["tgt"] 返回结果</span></span><br></pre></td></tr></table></figure></p>
<h3 id="全部代码如下">全部代码如下</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Author: Joke-R</span></span><br><span class="line"><span class="string">    IDE: python3.6</span></span><br><span class="line"><span class="string">    Purpose: translate words by youdao</span></span><br><span class="line"><span class="string">    Time: 2018-09-18</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Translate</span><span class="params">(String)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        String: str</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 真正翻译的网址 Request Url</span></span><br><span class="line">    url = <span class="string">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'</span></span><br><span class="line">    <span class="comment"># 新建列表 模拟传入数据</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    data[<span class="string">'i'</span>] = String</span><br><span class="line">    data[<span class="string">'from'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">    data[<span class="string">'to'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">    data[<span class="string">'smartresult'</span>] = <span class="string">'dict'</span></span><br><span class="line">    data[<span class="string">'client'</span>] = <span class="string">'fanyideskweb'</span></span><br><span class="line">    data[<span class="string">'doctype'</span>] = <span class="string">'json'</span></span><br><span class="line">    data[<span class="string">'version'</span>] = <span class="string">'2.1'</span></span><br><span class="line">    data[<span class="string">'keyfrom'</span>] = <span class="string">'fanyi.web'</span></span><br><span class="line">    data[<span class="string">'action'</span>] = <span class="string">'FY_BY_REALTIME'</span></span><br><span class="line">    data[<span class="string">'typoResult'</span>] = <span class="string">'false'</span></span><br><span class="line"></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    response = urllib.request.urlopen(url, data)  <span class="comment"># 得到回复</span></span><br><span class="line">    html = response.read().decode(<span class="string">'utf-8'</span>)  <span class="comment"># 重新编码</span></span><br><span class="line">    result = json.loads(html)  <span class="comment"># json 字典化</span></span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">"translateResult"</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="string">"tgt"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(__doc__)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            String = input(<span class="string">"please input a string:\n"</span>)</span><br><span class="line">            print(<span class="string">"result:"</span>, Translate(String))</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> reason:</span><br><span class="line">            print(reason + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Retro Snake Easyx版本</title>
    <url>/2018/09/15/2018-09-15-Retro-Snake/</url>
    <content><![CDATA[<h2 id="部分文件说明">部分文件说明</h2>
<h3 id="snakeprev.h"><strong>Snakeprev.h</strong></h3>
<ol type="1">
<li>蛇节点声明 <code>struct snake;</code></li>
<li>蛇存储结构链表 <code>snake * snakelist(int,int*);</code></li>
<li>增加节点方法 <code>void addsnake(snake *);</code></li>
<li>绘画蛇身 <code>void drawsnake(snake *,char);</code></li>
<li>清空蛇 <code>void clearsnake(snake *);</code></li>
</ol>
<a id="more"></a>
<h3 id="mapgraph.h"><strong>mapgraph.h</strong></h3>
<p>主要是页面布局 背景（box map)的制作 布局</p>
<h3 id="main.cpp"><strong>main.cpp</strong></h3>
<p>主要方法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcomegraph</span><span class="params">()</span></span>;<span class="comment">//欢迎界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Finish</span><span class="params">()</span></span>;<span class="comment">//结束界面</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clickcontrol</span><span class="params">()</span></span>;<span class="comment">//鼠标控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Movingsnake</span><span class="params">(<span class="keyword">char</span>)</span></span>;<span class="comment">//蛇身移动控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Changesnakebody</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> )</span></span>;<span class="comment">//蛇身改变控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eating</span><span class="params">()</span></span>;<span class="comment">//吃到食物的操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Deadjudge</span><span class="params">()</span></span>;<span class="comment">//死亡判断</span></span><br></pre></td></tr></table></figure>
<h3 id="运行截图">运行截图</h3>
<ul>
<li><strong>Start</strong></li>
</ul>
<figure>
<img src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/start.png?raw=true" alt="Start" /><figcaption>Start</figcaption>
</figure>
<ul>
<li><strong>Run</strong></li>
</ul>
<figure>
<img src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/run.png?raw=true" alt="Run" /><figcaption>Run</figcaption>
</figure>
<ul>
<li><strong>Over</strong></li>
</ul>
<figure>
<img src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/over.png?raw=true" alt="Over" /><figcaption>Over</figcaption>
</figure>
<h3 id="注意事项及运行说明">注意事项及运行说明</h3>
<p><strong>WASD：</strong>　来操控蛇的上下左右移动 注意打开英文输入<br />
<strong>初始界面：</strong> 用户名及密码只是模拟 回车键确定输入<br />
<strong>EXE目录：</strong> exe文件在debug目录下 release发布因为其优化运行出错<br />
<strong>源代码下载：</strong> <code>https://github.com/LWJ9527/Retro-Snake.git</code><br />
<strong>C控制台源代码：</strong> <code>https://blog.csdn.net/qq_40953281/article/details/79315254</code><br />
<strong>To Be Continue...</strong> &gt; Easyx 下载地址 <code>https://www.easyx.cn/downloads/</code><br />
&gt; 更新 2018-9-10</p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
