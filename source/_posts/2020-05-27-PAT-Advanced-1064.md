---
title: PAT Advanced 1064 Complete Binary Search Tree （二叉树）
date: 2020-05-27
tags:
- C/C++
- Tree
categories:
- OJ
- PAT
---

## 题目描述

给定一个各个数不同的序列，给出满足完全二叉树定义的二叉搜索树的层序遍历结果

Sample Input:

```in
10
1 2 3 4 5 6 7 8 9 0
```

Sample Output:

```out
6 3 8 1 5 7 9 0 2 4
```

<!-- more -->

## 基本思路

主要需要知道完全二叉树的定义以及一些性质，完全二叉树即除底层之外，为满二叉树，且底层为从左到右排列。所以对于给定数量的节点，它的完全二叉树结构是确定的，此时只需要用中序遍历，将给定的序列排序后依次放入就可以了，因为它也是一个搜索树。最后在层序遍历输出结果即可。

代码如下：

```cpp
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
#include <cstring>
#include <stack>
#include <algorithm>
#include <iterator>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;

int Tree[1010][2];
int vals[1010];
int nodes[1010];

int layers;

void midorder(int root, int &tar) {
    // 遍历左边
    if(Tree[root][0] != -1) {
        midorder(Tree[root][0], tar);
    }
    nodes[root] = vals[tar++];
    // 遍历右边
    if(Tree[root][1] != -1) {
        midorder(Tree[root][1], tar);
    }
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    memset(Tree, -1, sizeof(Tree));
    int n; scanf("%d", &n);
    for(int i = 0;i < n;i++) {
        scanf("%d", vals + i);
    }
    int l, r;
    // 构建树结构
    for(int i = 0;i < n;i++) {
        l = 2*i+1, r = 2*i+2;
        if(l < n) {
            Tree[i][0] = l;
        }
        if(r < n) {
            Tree[i][1] = r;
        }
    }
    sort(vals, vals+n);
    int cnt = 0;
    // 通过中序遍历
    midorder(0, cnt);
    //层序遍历
    queue<int> q;
    q.push(0);
    cnt = 0;
    while(!q.empty()) {
        int r = q.front(); q.pop();
        cnt++;
        printf("%d%s", nodes[r], cnt == n ? "" : " ");
        if(Tree[r][0] != -1) {
            q.push(Tree[r][0]);
        }
        if(Tree[r][1] != -1) {
            q.push(Tree[r][1]);
        }
    }
    return 0;
}
```

