---
title: PAT Advanced 1065 A+B and C (64bit) 
date: 2020-05-28
tags:
- C/C++
categories:
- OJ
- PAT
---

##　题目描述

给定三个数A，B，C，范围在$[-2^{63},2^{63}]$，判断`A+B>C`

<!-- more -->

## 简单思路

网上很多都是将范围看作$[-2^{63},2^{63}-1]$的范围（因为测试点没有$2^{63}$这个数据……），这样就可以直接使用`long long`类型存数据然后判断是否溢出即可。但终究不符合题意，如果真有$2^{63}$便不行了。

既然`long long`存不下，就可以改用`unsigned long long`，符号位另外单独保存，所以只需要根据符号位计算对应的和就可以了，但是相加之后还是会出现溢出的情况，所以单独判断溢出即可。

出现溢出的情况只有在正+正，负+负的情况，并且假设`A+B = S`，那么有`S < A and S < B`，根据这个结论便可以判断是否溢出。

对于符号位的存储，需要首先将数存为字符串类型，然后通过`sscanf`读入，对于负号要先去掉。

当然你也可以直接使用字符串模拟加法操作也是可以的。

参考代码如下：

```cpp
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
#include <cstring>
#include <stack>
#include <algorithm>
#include <iterator>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;

typedef unsigned long long llu;

bool isGreater(bool s_a, llu a, bool s_b, llu b) {
    // 正 负
    if(s_a && !s_b) {
        return true;
    }
    // 负 正
    if(!s_a && s_b) {
        return false;
    }
    // 负 负
    if(!s_a && !s_b) {
        return a < b;
    }
    return a > b;
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    char str[3][50];    // 保存为字符串 区别正负数
    bool s[3];          // 0 非负数 1 负数 符号位保存
    llu nums[3];        // 保存数值
    int n; scanf("%d", &n);
    for(int i = 1;i <= n;i++) {
        scanf("%s %s %s", str[0], str[1], str[2]);
        for(int k = 0;k < 3;k++) {
            s[k] = str[k][0] == '-' ? false : true;
            char *buffer = str[k][0] == '-' ? str[k]+1 : str[k];
            sscanf(buffer, "%llu", &nums[k]);
        }
        bool flag;  // 结果的符号
        llu res;    // 存放结果
        // 正 负
        if(s[0] && !s[1]) {
            flag = nums[0] >= nums[1];  // a >= b true
            res = flag ? nums[0] - nums[1] : nums[1] - nums[0];
            flag = isGreater(flag, res, s[2], nums[2]);
        }
        // 负 正
        else if(!s[0] && s[1]) {
            flag = nums[1] >= nums[0];  // a >= b true
            res = flag ? nums[1] - nums[0] : nums[0] - nums[1];
            flag = isGreater(flag, res, s[2], nums[2]);
        }
        // 负 负
        else if(!s[0] && !s[1]) {
            flag = false;
            res = nums[0] + nums[1];
            flag = isGreater(flag, res, s[2], nums[2]);
            // 必然是小于溢出，溢出则必定是小于
            if(res < nums[0]) {
                flag = false;
            }
        }
        else {
            flag = true;
            res = nums[0] + nums[1];
            flag = isGreater(flag, res, s[2], nums[2]);
            if(res < nums[0]) {
                flag = true;
            }
        }
        printf("Case #%d: %s\n", i, flag ? "true" : "false");
    }

    return 0;
}
```



