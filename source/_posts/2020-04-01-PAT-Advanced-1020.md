---
title: PAT Advanced 1020 Tree Traversals （二叉树）
date: 2020-04-01
tags:
- C/C++
categories:
- Computer Science
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072)

给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了

<!-- more -->

## 解决思路

这是一个很经典的重构二叉树的问题了，只要清楚每种遍历的规则和规律即可。

后序遍历：左子树，右子树，根节点

中序遍历：左子树，根节点，右子树

所以对后序遍历而言，后面的节点是前面节点构成的树的根节点，前面节点构成左子树和右子树，所以我们可以采取以下方案获取整棵树的结构。

从后序遍历数组`postorder`的末尾开始，从`inorder`数组中寻找和`postorder`相同值的，**这样就可以分为两边，分别是左子树和右子树**。然后将`postorder`末尾向前移动一步，对应的就是右子树的根节点。然后在`inorder`刚刚分开的右半边继续寻找即可。

代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#define LOCAL

using namespace std;

const int maxn = 31;
int postorder[maxn];
int inorder[maxn];

// 声明节点
struct Node {
    int val;
    Node *left = NULL, *right = NULL;
};

// 返回一棵树 根据根节点的值（这里提供postorder的下标），以及inorder的左右边界
Node* getTree(int post_i, int l, int r) {
    if(l > r) {
        return NULL;
    }
    Node *t_root = new Node();
    int mid = -1;
    // 分开左右子树
    for(int i = l;i <= r;i++) {
        if(inorder[i] == postorder[post_i]) {
            mid = i;
        }
    }
    t_root->val = inorder[mid];
    // 递归左右子数
    t_root->right = getTree(post_i-1, mid+1, r);
    t_root->left = getTree(post_i - (r - mid) - 1, l, mid-1);
    return t_root;
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    int n; scanf("%d", &n);
    for(int i = 0;i < n;i++) {
        scanf("%d", postorder + i);
    }
    for(int i = 0;i < n;i++) {
        scanf("%d", inorder + i);
    }
    Node *root = getTree(n-1, 0, n-1);
    printf("%d", root->val);
    // 层序遍历
    queue<Node*> que;
    que.push(root->left);
    que.push(root->right);
    while(!que.empty()) {
        Node *t = que.front(); que.pop();
        if(t == NULL) {
            continue;
        }
        printf(" %d",t->val);
        que.push(t->left);
        que.push(t->right);
    }
    return 0;
}
```

