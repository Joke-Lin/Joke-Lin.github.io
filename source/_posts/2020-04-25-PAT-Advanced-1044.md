---
title: PAT Advanced 1044 Shopping in Mars（二分）
date: 2020-04-21
tags:
- C/C++
- PAT
- 二分
categories:
- OJ
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264)

简单来说，即给定一串数字序列，以及目标值M，找出一段和为M的子串，若不存在找出大于M的最小子串

<!-- more -->

## 简单思路

这是一道二分法的题目，开始很难看出来，因为二分意味着有序，这里并没有什么有序。唯一可能有序的就是和了，如果让一个数组sums保存从开始到此位置的和，那这个数组就是递增的了，也就可以使用二分法了。

从位置i开始（左界）寻找符合条件的右界，也就是找前缀和为sums[i-1]+M的下标，这就可以使用二分查找了

代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;

const int maxn = 1e5+1;
int n, m;
int sums[maxn];

int divide(int st) {
    int ed = n, mid, tar = m+sums[st-1];
    while(st < ed) {
        mid = (st + ed) >> 1;
        if(sums[mid] >= tar) {
            ed = mid;
        }
        else {
            st = mid+1;
        }
    }
    return ed;
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    sums[0] = 0;
    scanf("%d %d", &n, &m);
    for(int i = 1;i <= n;i++) {
        int mid; scanf("%d", &mid);
        sums[i] = sums[i-1] + mid;
    }
    int min_m = sums[n];
    vector<pair<int, int>> res;
    for(int i = 1;i <= n;i++) {
        int tar_pos = divide(i);
        int temp = sums[tar_pos]-sums[i-1];
        if(temp > min_m) {
            continue;
        }
        if(temp >= m) {
            if(temp < min_m) {
                res.clear();
                min_m = temp;
            }
            res.push_back({i, tar_pos});
        }
    }
    for(auto v : res) {
        printf("%d-%d\n", v.first, v.second);
    }
    return 0;
}
```

