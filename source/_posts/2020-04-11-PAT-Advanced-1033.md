---
title: PAT Advanced 1033 To Fill or Not to Fill （贪心）
date: 2020-04-11
tags:
- C/C++
- 贪心
categories:
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080)

给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。

<!-- more -->

## 思路

思路清楚的话便十分简单了，大体思想就是贪心。贪心策略如下：

当到达一个加油站的时候，获取其满油状态下可以到达的最远距离，然后**在当前和最远距离之间**选取一个合适的加油站，作为下一次加油的站点。通过下面的方式获取合适站点：

1. 如果存在**油价比当前所在加油站价格低**的，则在当前加油站加油到恰好可以到达第一个油价低于它的
2. 否则直接在当前加油站加满油，然后下一个加油站为满油状态下可到达的最远加油站

如果到不了下一个油站则直接输出最大可到达距离即可。

需要特判一下开始位置没有加油站的情况，直接输出最大距离0.00。

此贪心策略画个图便很容易想到并证明了。如果在当前加油站可开到一个比他油价低的加油站则在低油价站点补充油一定比直接开要开销小。相反如果不能开到油价低的，则说明途径的油站价格都比原油站价格高，则在途中补充不如直接开到最后一个在补充。**此正确性来自，每个加油站最多且保证可加到满油状态。**

注意在考虑的时候，要注意到此油站可能还剩余一些油。

代码如下:

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#define LOCAL

using namespace std;

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    float tank, dis, avg, n;
    scanf("%f %f %f %f", &tank, &dis, &avg, &n);
    vector<pair<float, float> > gas_stations;
    for(int i = 0;i < n;i++) {
        float v, d;
        scanf("%f %f", &v, &d);
        gas_stations.push_back({d, v});
    }
    gas_stations.push_back({dis, 0});   // 将最后一个站设为免费加油站 便于后面处理
    sort(gas_stations.begin(), gas_stations.end()); // 按距离排序
    // 起始位置没有加油站
    if(gas_stations[0].first != 0) {
        printf("The maximum travel distance = %.2f", 0);
        return 0;
    }
    float cost = 0, last_gas = 0;  // 开销 & 到此加油站剩余油
    int cur_pos = 0, stations_size = gas_stations.size();
    while(true) {
        float next_dis = gas_stations[cur_pos].first + tank*avg;  // 在这个站满油情况下的可以开到的最远位置
        int tar_pos = -1;   // 获取开销最小的下一个加油站
        // 从这段距离中获取合适的
        for(int i = cur_pos+1;i < stations_size;i++) {
            if(gas_stations[i].first > next_dis) {
                break;
            }
            tar_pos = i;
            if(gas_stations[i].second <= gas_stations[cur_pos].second) {
                break;
            }
        }
        // 不能到达到下一个站
        if(tar_pos == -1) {
            printf("The maximum travel distance = %.2f", next_dis);
            return 0;
        }
        float gas_need; // 需要购买的油
        // 有价格更小的站
        if(gas_stations[tar_pos].second <= gas_stations[cur_pos].second) {
            gas_need = (gas_stations[tar_pos].first-gas_stations[cur_pos].first)/avg - last_gas;
            last_gas = 0;   // 直接买足够到下一个站的油即可
        }
        // 价格都比它大
        else {
            gas_need = tank - last_gas;   // 直接加满
            last_gas = (next_dis - gas_stations[tar_pos].first)/avg; // 更新到下一个站的油量
        }
        cost += gas_need*gas_stations[cur_pos].second;
        // 到达目标地
        if(tar_pos == stations_size-1) {
            break;
        }
        cur_pos = tar_pos;
    }
    printf("%.2f", cost);
    return 0;
}
```

