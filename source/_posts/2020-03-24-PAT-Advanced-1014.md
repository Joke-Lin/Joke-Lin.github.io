---
title: 'PAT Advanced 1014 Waiting in Line（优先队列）'
date: 2020-03-21
tags:
- C/C++
- PAT
categories:
- DSAA
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936)

之前一直错还是题目看错，英文题目还是要注意啊。

17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。

<!-- more -->

## 基本思路

题目本身不难，理清楚过程即可。（他题目有些也迷）

给出了N个窗口以及最大等待区M，K个顾客。相当于本来就有K个人在排队，然后每个人依次选窗口当等待区有空位的适合。等待区总共可以容纳NM个人，所以最前面的NM个人依次排满等待区即可（按照题目定的规则），当等待区满的时候，只要有一个人结束服务，那在等待区外排队的人就马上可以塞进去一个。

所以我们需要知道的就是最早结束服务的人，这就可以用到优先队列了，维护结束服务的时间。时间越早优先级越高。每当他进入等待区，就push到优先队列中。

代码如下：

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
//#define LOCAL

using namespace std;

const int maxn = 1001;

struct Customer {
    int win_index;
    int end_time;
    bool operator < (const Customer& other) const {
        // 同时离开 选择编号小的
        return end_time != other.end_time ? end_time > other.end_time : win_index > other.win_index;
    }
}customers[maxn];

int cost_time[maxn];    // 用户的花费时间
int end_time[maxn];     // 每个用户的结束时间
int win_cur_time[21];   // 当前窗口等待区清空的最晚时间

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    memset(win_cur_time, 0, sizeof(win_cur_time));
    memset(end_time, 0xff, sizeof(end_time));
    int n, m, k, q; scanf("%d %d %d %d", &n, &m, &k, &q);
    for(int i = 0;i < k;i++) {
        scanf("%d", cost_time+i);
    }
    priority_queue<Customer> que;
    // 前NM个直接加入
    for(int i = 0;i < k && i < n*m;i++) {
        win_cur_time[i%n] += cost_time[i];
        end_time[i] = win_cur_time[i%n];
        que.push({i%n, end_time[i]});
    }
    for(int i = n*m;i < k;i++) {
        Customer temp = que.top(); que.pop();   // 获取最早离开的
        win_cur_time[temp.win_index] += cost_time[i];
        end_time[i] = win_cur_time[temp.win_index];
        temp.end_time = end_time[i];
        que.push(temp);
    }
    int tar;
    for(int i = 0;i < q;i++) {
        scanf("%d", &tar);
        int mins = end_time[tar-1];
        // 开始服务的时间不能晚于17:00
        if(mins - cost_time[tar-1] >= 540) {
            printf("Sorry\n");
        }
        else {
            printf("%02d:%02d\n", 8+mins/60, mins%60);
        }
    }
    return 0;
}
```

