---
title: 'PAT Advanced 1010 Radix（二分法）'
date: 2020-03-19
tags:
- 二分
- C/C++
categories:
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536)

<!-- more -->

Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is `yes`, if 6 is a decimal number and 110 is a binary number.

Now for any pair of positive integers *N*1 and *N*2, your task is to find the radix of one number while that of the other is given.

### Input Specification:

Each input file contains one test case. Each case occupies a line which contains 4 positive integers:

```
N1 N2 tag radix
```

Here `N1` and `N2` each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, `a`-`z` } where 0-9 represent the decimal numbers 0-9, and `a`-`z` represent the decimal numbers 10-35. The last number `radix` is the radix of `N1` if `tag` is 1, or of `N2` if `tag` is 2.

### Output Specification:

For each test case, print in one line the radix of the other number so that the equation `N1` = `N2` is true. If the equation is impossible, print `Impossible`. If the solution is not unique, output the smallest possible radix.

### Sample Input 1:

```in
6 110 1 10
```

### Sample Output 1:

```out
2
```

### Sample Input 2:

```in
1 ab 1 2
```

### Sample Output 2:

```out
Impossible
```

## 基本思路

PAT题目都很迷，很多地方都不说清楚输入范围。。。

这道题输入数据不会超过`long long`，所以可以放心的使用基本思路计算不同进制下的值

```c++
ll getRes(string &tar, int radix) {
    ll res = 0;
    int len = tar.length();
    for(int i = 0;i < tar.length();i++) {
        res = res*radix + getNum(tar[i]);
        if(res < 0) {
            return -1;
        }
    }
    return res;
}
```

如果每次都从进制2开始递增进制，直到一种不可能的情况出现，但这种方法对大小差距极大的两个数特别耗时，对于这种**在一个序列中寻找一个正确解**的过程，显然是用二分法解决。

但是二分法需要一个范围，那么这道题的进制范围是在哪一个范围。首先对于R进制的串，对于数串内的数必须小于R，所以获取此串的最小进制（下界）就显而易见了

```c++
int getNum(char tar) {
    if(tar >= '0' && tar <= '9') {
        return tar - '0';
    }
    else {
        return tar - 'a' + 10;
    }
}

int getMinRadix(string &tar) {
    // 也可以使用C++的max_element函数
    char c = '0';
    for(int i = 0;i < tar.length();i++) {
        if(tar[i] > c) {
            c = tar[i];
        }
    }
    return  max(getNum(c) + 1, 2);
}
```

上界即为`max(minRadix,  num)` num为已知进制的数的值，因为题目中只涉及到0-35的值，所以num作为上届已经足够，因为个位是不可能达到num值的最高就是35，那么在2位数字的情况下最小也是10，此时10在num进制下就是num，所以num进制的最小值就是num，在往上就会大于num就没有必要了

所有在上下界进行二分法查找即可

**代码如下：**

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
//#define LOCAL

using namespace std;

typedef long long ll;

int getNum(char tar) {
    if(tar >= '0' && tar <= '9') {
        return tar - '0';
    }
    else {
        return tar - 'a' + 10;
    }
}

int getMinRadix(string &tar) {
    char c = '0';
    for(int i = 0;i < tar.length();i++) {
        if(tar[i] > c) {
            c = tar[i];
        }
    }
    return  max(getNum(c) + 1, 2);
}

ll getRes(string &tar, int radix) {
    ll res = 0;
    int len = tar.length();
    for(int i = 0;i < tar.length();i++) {
        res = res*radix + getNum(tar[i]);
        if(res < 0) {
            return -1;
        }
    }
    return res;
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    string A, B;
    int tag, radix;
    cin >> A >> B >> tag >> radix;
    if(tag == 2) {
        swap(A, B);
    }
    // B 是 要计算的
    ll tar = getRes(A, radix);
    //  二分
    ll left = getMinRadix(B);
    ll right = max(left, tar);
    while (left <= right) {
        ll mid = (left + right) >> 1;
        ll temp = getRes(B, mid);
        if(temp == tar) {
            printf("%lld", mid);
            return 0;
        }
        if(temp < 0 || temp > tar) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    printf("Impossible");
    return 0;
}
```

