---
title: PAT Advanced 1049 Counting Ones（动态规划？数学问题）
date: 2020-05-02
tags:
- C/C++
categories:
- OJ
- PAT

---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805430595731456)

给定n，给出[1,n]范围内所有数字含有的1的个数

<!-- more -->

## 简单思路

### 规律

[刘婼巨佬的方法](https://www.liuchuo.net/archives/2305)，网上很多都是如此的算法，这道题是《编程之美》中的一道例题，简单来说只需要按以下规律计算即可：

![](/assets/ArticleImg/2020/pat1049.png)

### 动态规划（有点那么意思）

这道题还是想了好久，用了种类似动态规划的方法（或者说动归的思想）。题目求的是1的数目，那么就简单的想就需要知道包含1个1的数字有多少，包含2个1的数字有多少……

所以有什么非暴力的方法获取这些数据，是否可以根据带判断数字的前N位，推出N+1位的数据。比如求123以内的1的个数，如果知道12的相关数据，是否可以推导出123的。

例如，12有下表，纵为1的个数：（包含0）

|      | 0    | 1              | 2       | 3    |
| ---- | ---- | -------------- | ------- | ---- |
| 12   | 9    | 3（1，10，12） | 1（11） | 0    |

根据上表便可以推导出123的相关数据：

比如，求123中只含有1个1的数字的数量。**含有1个1可以从12中的（0，1）两列数据导出，因为含有1个1，可以是不包含1的情况后面添加一个1，如XX1的形式，或者是12中含有1个1的情况添加非1的数如1X[~1]**，还需要注意的一点，**在12中，12这个数是在1列中（表示含有1个1），所以给他添加第三个数的时候需要分类讨论了**，比如10，它的第三位就有9种可能，0，2，3...9，但对于12就只有3种可能，0，2，3（因为目标是123，第三位是3）。还需要注意N+1位为0的情况。

所以获得123的数据表如下：

|      | 0    | 1              | 2       | 3    |
| ---- | ---- | -------------- | ------- | ---- |
| 12   | 9    | 3（1，10，12） | 1（11） | 0    |
| 123  | 81   | 9+2\*9+1\*3    | 3+1\*9  | 1    |

大致思路如上，总结来说，求N+1为的j个数1的数量需要N位j-1，j两列的数据，需要对N位数做单独讨论，因为对XXY，如果前两位是XX那么N+1位就只有Y+1中可能的选择，否则有10种。其次还需要注意对0的讨论。

参考代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;
typedef long long ll;

// 获取某个数1个个数
int calOnes(int num) {
    int res = 0;
    while(num) {
        if(num % 10 == 1) {
            res++;
        }
        num = num/10;
    }
    return res;
}

ll getOnes(int num) {
    if(num < 10) {
        return 1;
    }
    char num_str[30];
    sprintf(num_str, "%d", num);
    ll table[30]; // 存储信息表 位数-数量表
    memset(table, 0, sizeof(table));
    // 初始化1位的情况
    table[0] = num_str[0]-'0', table[1] = 1;
    int lens = strlen(num_str);
    int up_pos = calOnes(table[0]); // 记录N位的1的个数，以获取其在哪一列
    int temp_sum = table[0];    // N位对应的值
    for(int i = 2;i <= lens;i++) {  // 位数遍历
        int cur_num = num_str[i-1] - '0';   // 当前的对应位的值
        temp_sum = temp_sum*10 + cur_num;
        int temp = 0;   // 保存含有1的数字总和
        // 从后往前压缩数组（滚动数组）
        for(int cur = i;cur >= 1;cur--) {   // 获取对应1的个数的数量
            int prev = cur-1;
            // 对应prev，cur两列的数值
            int a = up_pos == prev ? table[prev] - (cur_num == 0) : table[prev];
            int b = up_pos == cur ? (table[cur] - 1)*9 + (cur_num == 0 ? 1 : cur_num) : table[cur]*9;
            table[cur] = a+b;
            temp += table[cur];
        }
        table[0] = temp_sum - temp + 1; // 不包含1 的数量
        up_pos = calOnes(temp_sum);
    }
    ll res = 0;
    for(int i = 1;i <= lens;i++) {
        res += i*table[i];
    }
    return res;
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    int n; 
    scanf("%d", &n);
    printf("%d", getOnes(n));
    return 0;
}
```

