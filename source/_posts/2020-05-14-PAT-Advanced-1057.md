---
title: PAT Advanced 1057 Stack （树状数组）
date: 2020-05-14
tags:
- C/C++
categories:
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805417945710592)

给定栈的一系列POP，PUSH操作，求执行这些操作后的栈中从小到大排序的中位数（询问中位数的操作是多次的）

<!-- more -->

## 基本思路

栈的模拟并不难处理，主要是对中位数的判断。在不断的更改之中还需要寻找一组数的中位数（范围特征），并且修改每次修改一个具体的数（单点修改），这两个特征符合[树状数组](https://joke-lin.top/2020/05/13/2020-05-13-Binary-Index-Tree/)的特征。但还是很难将题目与树状数组联系起来（是真的想不到）。

数组数组的最大特征就是**区间和的计算（前缀和）和高效率的单点修改**，这如何与题目的中位数联系起来，中位数即中间位置的数，也就说明从开始到该数的个数为总数的一半。所以我们使用树状数组维护X这个数的个数，求中位数也就是求目标X，满足1-X范围内的前缀和为总数的一半。这就与树状数组相联系了。

题目给定的条件N为正数，并且小于$10^5$满足使用树状数组的条件。

代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
#include <stack>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;
#define LOWBIT(x) ((x)&(-(x)))

using namespace std;

const int maxn = 1e5+10;

int nums[maxn];

// 表示值x的数量加1
void add(int x, int v) {
    while(x < maxn) {
        nums[x] += v;   
        x += LOWBIT(x);
    }
}

// 获取<x的所有个数
int getsum(int x) {
    int res = 0;
    while(x >= 1) {
        res += nums[x];
        x -= LOWBIT(x);
    }
    return res;
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    memset(nums, 0, sizeof(nums));
    stack<int> s;
    int n; scanf("%d", &n);
    char cmd[15];
    while(n--) {
        scanf("%s", cmd);
        if(cmd[1] == 'o') {
            if(s.empty()) {
                printf("Invalid\n");
            }
            else {
                int x = s.top(); s.pop();
                add(x, -1); // 减少一个了
                printf("%d\n", x);
            }
        }
        else if(cmd[1] == 'e') {
            if(s.empty()) {
                printf("Invalid\n");
            }
            else {
                int tar = (s.size() + 1) >> 1;
                int left = 1, right = maxn-1, mid;
                while(left < right) {
                    mid = (left + right) >> 1;
                    if(getsum(mid) < tar) {
                        left = mid+1;
                    }
                    else {
                        right = mid;
                    }
                }
                printf("%d\n", right);
            }
        }
        else if(cmd[1] == 'u') {
            int x; scanf("%d", &x);
            s.push(x);
            add(x, 1);
        }
    }
    return 0;
}
```

