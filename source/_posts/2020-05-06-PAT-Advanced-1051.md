---
title: PAT Advanced 1051 Pop Sequence（栈）
date: 2020-05-06
tags:
- C/C++
categories:
- Computer Science
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944)

给定栈的最大容量，按照1\~N的顺序入栈，但可以随时出栈，判断给出的pop序列是否是可能的情况

<!-- more -->

## 基本思路

这里主要是运用栈这种数据结构先进后出的特点，假如当前pop出来的值为a，那么1\~a之间的值，必定是被push过了，所以我们从左到右遍历pop序列并且维护一个栈，而且记录当前已pop的最大值maxn，如果当前pop值t大于他，说明有新的值push到栈中，这些值即为a+1\~t，如果小于maxn，说明现在的值是已经被push到栈中了的，所以直接查看它与当前栈顶的值是否一致，是的话则将栈pop，否则说明非法序列，在push到栈的过程中要检查栈大小，不能超过限定值

参考代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
#include <stack>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    int m, n, k; scanf("%d %d %d", &m, &n, &k);
    while(k--) {
        stack<int> s;
        int maxn = 0;
        bool flag = true;
        for(int i = 0;i < n;i++) {
            int v; scanf("%d", &v);
            if(!flag) {
                continue;
            }
            if(v > maxn) {
                for(int j = maxn+1;j <= v;j++) {
                    s.push(j);
                }
                if(s.size() > m) {
                    flag = false;
                }
                maxn = v;
                s.pop();
            }
            else {
                if(v != s.top()) {
                    flag = false;
                }
                else {
                    s.pop();
                }
            }
        }
        if(flag) {
            printf("YES\n");
        }
        else {
            printf("NO\n");
        }
    }
    return 0;
}
```

