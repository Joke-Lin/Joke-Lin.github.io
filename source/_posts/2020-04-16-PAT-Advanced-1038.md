---
title: PAT Advanced 1038 Recover the Smallest Number （贪心）
date: 2020-04-16
tags:
- C/C++
- PAT
- 贪心
categories:
- OJ
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704)

给定一系列数字串，使用他们组成一个最小的数字

<!-- more -->

## 基础思路

似乎或者应该有那么点贪心的思路，重载一个排序函数，每次选取保证可以最小整个数字串的值。

重载`string`比较函数：

```cpp
bool cmp(string &a, string &b) {
    int i = 0;
    while(i != a.size() && i != b.size()) {
        if(a[i] < b[i]) {
            return true;
        }
        else if(a[i] > b[i]) {
            return false;
        }
        i++;
    }
    string c = a+b, d = b+a;
    i = 0;
    while(i != c.size()) {
        if(c[i] < d[i]) {
            return true;
        }
        else if(c[i] > d[i]) {
            return false;
        }
        i++;
    }
    return true;
}
```

比较的思路大概就是对于两个串，从开始遍历，优先选择数字小的，如果两个串前缀完全相同比如A：321，B：32，那么就比较，AB和BA的数字大小情况。

因为无论什么样的顺序，最终的数字位数是确定的，所以确定取那个串作为下一部分，只要选取前缀最小的就可以了。

注意00000的情况，需要打印一个0

代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
//#define LOCAL

using namespace std;
typedef long long ll;

bool cmp(string &a, string &b) {
    int i = 0;
    while(i != a.size() && i != b.size()) {
        if(a[i] < b[i]) {
            return true;
        }
        else if(a[i] > b[i]) {
            return false;
        }
        i++;
    }
    string c = a+b, d = b+a;
    i = 0;
    while(i != c.size()) {
        if(c[i] < d[i]) {
            return true;
        }
        else if(c[i] > d[i]) {
            return false;
        }
        i++;
    }
    return true;
}


int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    int n; scanf("%d", &n);
    string num_str;
    vector<string> seq;
    for(int i = 0;i < n;i++) {
        cin >> num_str;
        seq.push_back(num_str);
    }
    sort(seq.begin(), seq.end(), cmp);
    bool flag = false;
    for(auto i : seq) {
        if(!flag) {
            for(int j = 0;j < i.length();j++) {
                if(i[j] != '0') {
                    flag = true;
                    cout << i[j];
                }
                else {
                    if(flag) {
                        cout << i[j];
                    }
                }
            }
        }
        else {
            cout << i;
        }
    }
    if(!flag) {
        cout << "0";
    }
    return 0;
}
```

