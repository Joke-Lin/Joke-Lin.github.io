---
title: PAT Advanced 1026 Table Tennis （模拟）
date: 2020-04-09
tags:
- C/C++
- PAT
categories:
- OJ
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560)

给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：

- 当一个VIP球台空的时候，排队中的第一个VIP可以优先使用
- 如果当前没有VIP用户等待，普通用户也可以使用VIP球台
- 如果VIP用户没有VIP球台可以使用，就使用普通球台

存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。

<!-- more -->

## 基础思路

其实有很多种处理的方式，我采取的策略为：

1. 用户按时间排序，将每个球台开放时间保存为数组
2. 分别获取球台的最早的普通球台和VIP球台开放时间
3. 如果是普通先开放，意味着没有VIP球台多余，直接给下一个等待用户即可，另外处理没有任何等待用户的情况
4. 如果是VIP球台先开放（包含和普通同时开放的情况），查找顾客数组是否有VIP在等待，有的话给此VIP用户，否则给等待的第一个普通用户，如果没有人等待，进入处理无人等待的情况
5. 无人等待的情况处理：没人等意味着下一个来的可以马上处理，如果来的是VIP查看是否有VIP球台，有给他，没有则给普通，普通用户则直接给空闲的编号最小的球台（此时没VIP等待）

可参考：[PAT 甲级 1026 Table Tennis (30 分)（坑点很多，逻辑较复杂，做了1天）](https://www.cnblogs.com/caiyishuai/p/11372153.html)其中的测试样例

**在`测试点8`错误了，原因为：在检查是否有VIP在排队的时候，忽略了此VIP用户可能在之前以及被处理（VIP有时候可以优先）**

代码实现还是有些细节的，代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <iostream>
#include <cstring>
//#define LOCAL

using namespace std;
typedef pair<int, int> P;

struct Player {
    int arrival;
    int served;
    int isvip;
    bool operator < (const Player& another) {
        return arrival < another.arrival;
    }
};

const int maxn = 110, INF = 0x3f3f3f3f;
vector<Player> players; // 存储玩家
P tables[maxn]; // 桌子 first：释放时间 second：是否VIP
const int clock_8 = 8*3600, clock_21 = 21*3600;
int table_count[maxn];  // 计数
bool is_served[10001];  // 玩家是否被服务 针对VIP优先处理
int k, m, n;

void print_time(int sec) {
    int h = sec/3600;
    int m = (sec%3600)/60;
    int s = sec%60;
    printf("%02d:%02d:%02d", h, m, s);
}
// 打印 以及更新对应的数据
void push_serverd_player(int index, int table_pos, int served_time) {
    print_time(players[index].arrival); cout << " "; print_time(served_time); cout << " ";
    int wait = (served_time - players[index].arrival + 30)/60;
    printf("%d\n", wait);
    is_served[index] = true;
    table_count[table_pos]++;
    tables[table_pos].first = served_time + players[index].served;
}

// 返回VIP和非VIP的最小下标
P getMinTableIndex() {
    int index1 = -1, index2 = -1;
    for(int i = 0;i < k;i++) {
        if(tables[i].second) {
            if(index2 == -1 || tables[i].first < tables[index2].first) {
                index2 = i;
            }
        }
        else {
            if(index1 == -1 || tables[i].first < tables[index1].first) {
                index1 = i;
            }
        }
    }
    return {index1, index2};
}

// 处理没有人等待的情况 VIP的话要先看是否有空闲的VIP
void no_wait(int index) {
    // 获取空闲VIP和普通的最小下标
    int index1 = INF, index2 = INF;
    for(int i = 0;i < k;i++) {
        if(tables[i].second) {
            if(index2 == INF && tables[i].first < players[index].arrival) {
                index2 = i;
            }
        }
        else {
            if(index1 == INF && tables[i].first < players[index].arrival) {
                index1 = i;
            }
        }
    }
    int tar;
    if(players[index].isvip) {
        tar = index2 == INF ? index1 : index2;
    }
    else {
        tar = min(index1, index2);
    }
    push_serverd_player(index, tar, players[index].arrival);
}

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    memset(table_count, 0, sizeof(table_count));
    memset(is_served, 0, sizeof(is_served));
    scanf("%d", &n);
    for(int i = 0;i < n;i++) {
        int hh, mm, ss, p, tag;
        scanf("%d:%d:%d %d %d", &hh, &mm, &ss, &p, &tag);
        int sec = hh*3600 + mm*60 + ss;
        p = p > 120 ? 120*60 : p*60;
        if(sec >= clock_21) {
            continue;
        }
        players.push_back({sec, p, tag});
    }
    sort(players.begin(), players.end());
    scanf("%d %d", &k, &m);
    for(int i = 0;i < k;i++) {
        tables[i] = {clock_8, 0};
    }
    // 防止全部都是普通或者VIP 导致获取下标函数返回没有意义的值
    tables[k++] = {clock_21, 0};
    tables[k++] = {clock_21, 1};
    for(int i = 0;i < m;i++) {
        int vip_pos; scanf("%d", &vip_pos);
        tables[vip_pos-1].second = 1;
    }
    int index = 0, len = players.size();
    while(index < len) {
        if(is_served[index]) {
            index++;
            continue;
        }
        Player p = players[index];
        P min_index = getMinTableIndex();
        // 后面的都不用处理了
        if(tables[min_index.first].first >= clock_21 && tables[min_index.second].first >= clock_21) {
            break;
        }
        int table_empty_time;
        // 普通的先空 意味着没有VIP位置 那么直接给等待的下一个
        if(tables[min_index.first].first < tables[min_index.second].first) {
            table_empty_time = tables[min_index.first].first;
            // 有人在等待
            if(p.arrival <= table_empty_time) {
                push_serverd_player(index, min_index.first, table_empty_time);
            }
            // 没人等
            else {
                no_wait(index);
            }
            index++;
        }
        // 存在空的VIP 位置 注意VIP普通同时为空
        else {
            table_empty_time = tables[min_index.second].first;
            // 寻找是否有等待的VIP 有则先给他位置 否则给下一个人
            int vip_pos = -1;
            for(int i = index;i < len;i++) {
                // Error 8:最后一个测试点卡。。已经处理的VIP 跳过
                if(is_served[i]) {
                    continue;
                }
                if(players[i].arrival <= table_empty_time) {
                    if(players[i].isvip) {
                        vip_pos = i;
                        break;
                    }
                }
                else {
                    break;
                }
            }
            // 有VIP在等
            if(vip_pos != -1) {
                // printf("index:%d vip:%d\n", index, vip_pos);
                push_serverd_player(vip_pos, min_index.second, table_empty_time);
            }
            // 没有VIP在等
            else {
                // 但有普通人等
                if(p.arrival <= table_empty_time) {
                    // 普通人也可以选择VIP的位置 看哪个小选哪个
                    int tar_pos = tables[min_index.first].first == tables[min_index.second].first ? min(min_index.second, min_index.first) : min_index.second;
                    push_serverd_player(index, tar_pos, table_empty_time);
                }
                // 没人等
                else {
                    no_wait(index);
                }
                index++;
            }
        }
    }
    for(int i = 0;i < k-2;i++) {
        printf("%d",table_count[i]);
        if(i != k-3) {
            printf(" ");
        }
    }
    return 0;
}
```





