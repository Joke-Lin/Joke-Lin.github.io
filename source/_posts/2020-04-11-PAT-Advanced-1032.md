---
title: PAT Advanced 1032 Sharing（链表）
date: 2020-04-11
tags:
- C/C++
categories:
- Computer Science
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920)

简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。

<!-- more -->

## 思路

200ms的限制时间暴力是不可能暴力的，必须是线性时间的算法。

我的思路比较繁琐，首先获取两个字符串的完整路径，并分别记录他们的前置结点，和结尾结点位置。如果两个结尾不一样则输出-1，否则从末尾开始向前寻找第一个分支即可（两个字符串第一个路径前驱不同的位置）。

在生成路径的时候注意**不要以是否为-1作为结束判断**，有些字符串可能他只给出一部分，并没有-1结束标志。其次，采取这种思路在寻找前驱分支的时候，注意当两个字符串为同一个的情况（可能会出现）。可以实现将起始点的前驱结点赋值为不同的值，如-1，-2即可。

网上一种很简便的方法就是遍历字符串1，将遍历到的点记录，然后遍历字符串2，遇到的第一个字符串1中遍历过的，就是公共后缀的开始位置了。

代码如下:

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
//#define LOCAL

using namespace std;

map<int, int> link;
const int maxn = 1e5;
int st_1, st_2, ed_1, ed_2, n;
map<int, int> prev_1, prev_2;

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    scanf("%d %d %d", &st_1, &st_2, &n);
    // 防止有两个字符串完全一样的情况。。
    prev_1[st_1] = -1;
    prev_2[st_2] = -2;
    for(int i = 0;i < n;i++) {
        int cur, next;
        char v;
        scanf("%d %c %d", &cur, &v, &next);
        link[cur] = next;
    }
    int cur = st_1;
    // 条件为link[cur].next != -1会TE 可能不会有-1结尾
    while(link.count(link[cur])) {
        prev_1[link[cur]] = cur;
        cur = link[cur];
    }
    ed_1 = cur;
    cur = st_2;
    while(link.count(link[cur])) {
        prev_2[link[cur]] = cur;
        cur = link[cur];
    }
    ed_2 = cur;
    if(ed_1 != ed_2) {
        printf("-1");
    } else {
        while(true) {
            if(prev_1[cur] != prev_2[cur]) {
                break;
            }
            cur = prev_1[cur];
        }
        printf("%05d", cur);
    }
    return 0;
}
```

