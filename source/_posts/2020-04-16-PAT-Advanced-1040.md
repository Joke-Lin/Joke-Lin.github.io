---
title: PAT Advanced 1040 Longest Symmetric String（动态规划）
date: 2020-04-16
tags:
- C/C++
- 动态规划
categories:
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344)

求最长回文子串的长度

<!-- more -->

## 基本思路

这里使用动态规划求解
$$
dp[i][j]=
\begin{cases}
true & & dp[i-1][j+1] == true \&\& str[i]==str[j] \\
false & &\text{else}
\end{cases}
$$
dp\[i\][j] 表示substr(j, i) 是否是回文串

这里动态规划遍历的顺序可以有多种，我是以下标为遍历顺序，也可以以回文串长度作为遍历顺序。

还有一种算法为马拉车算法，实现了复杂度$O(n)$。可参考[最长回文子串算法](https://joke-lin.top/2018/10/01/2018-10-01-manacher/)

参考代码：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;

const int maxn = 1001;
bool dp[maxn][maxn];


int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    memset(dp, 0, sizeof(dp));
    char s[maxn];
    fgets(s, maxn, stdin);
    int len = strlen(s);
    for(int i = 0;i < len;i++) {
        dp[i][i] = true;
    }
    int res = 1;
    for(int i = 1;i < len;i++) {
        if(s[i] == s[i-1]) {
            dp[i][i-1] = true;
            res = max(res, 2);
        }
        for(int j = i-2;j >= 0;j--) {
            if(dp[i-1][j+1] && s[i] == s[j]) {
                dp[i][j] = true;
                res = max(res, i - j + 1);
            }
        }
    }
    printf("%d", res);
    return 0;
}
```

