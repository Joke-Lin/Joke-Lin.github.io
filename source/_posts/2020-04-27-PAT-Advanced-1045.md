---
title: PAT Advanced 1045 Favorite Color Stripe（动态规划）
date: 2020-04-21
tags:
- C/C++
- 动态规划
categories:
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805437411475456)

和最长公共子序列很相似，不同的是这里是求串B中符合串A的数字顺序的最长串的大小（即可重复）。比如：

给定顺序A为：1、2、3，待匹配串B为：1、1、2、4、3、2

其中符合条件的串有：

1. 1、1、2、2
2. 1、2、2
3. 2、3
4. ...

<!-- more-->

## 基本思路

题目和最长公共子序列几乎是一样的，都是动态规划的思路。既然是动态规划那么就涉及到状态转移方程了。类比最长公共子序列，这里使用`dp[i][j]`表示A串第i位和B串第j位可以构成满足条件的最长串大小。

构成的状态转移方程为：
$$
dp[i][j] = 
\begin{cases}
dp[i][j-1]& \text{A[i-1]==B[j-1]} \\
max(dp[i][j-1], dp[j-1][i]& \text{else}
\end{cases}
$$
可以看出和最长公共子序列仅仅在A[i-1] == B[j-1]（注意dp是从1开始的，表示第i位）时不一样，由$dp[i-1][j-1] + 1$变成了$dp[i][j-1]+1$，就是**因为此题目允许相对顺序的重复**。

这里还可以进行状态压缩，注意到此时位二维DP数组，观察其状态转移方程，可以将其压缩为一维数组（也叫做滚动数组）

参考代码如下：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <queue>
#include <functional>
#include <cmath>
#include <map>
#include <set>
//#define LOCAL
#define SEE(x) cout << #x << ":" << x << endl;

using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 10001;
int nums[maxn];
int order[201];
int dp[maxn];

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    int n, m, k;
    scanf("%d", &n);
    scanf("%d", &m);
    for(int i = 0;i < m;i++) {
        scanf("%d", order+i);
    }
    scanf("%d", &k);
    for(int i = 0;i < k;i++) {
        scanf("%d", nums+i);
    }
    memset(dp, 0, sizeof(dp));
    int res = 0;
    for(int i = 1;i <= m;i++) {
        for(int j = 1;j <= k;j++) {
            if(nums[j-1] == order[i-1]) {
                dp[j] = dp[j-1] + 1;
            }
            else {
                dp[j] = max(dp[j-1], dp[j]);
            }
            res = max(res, dp[j]);
        }
    }
    printf("%d", res);
    return 0;
}
```

