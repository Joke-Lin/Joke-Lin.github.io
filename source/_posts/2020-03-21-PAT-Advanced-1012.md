---
title: 'PAT Advanced 1012 The Best Rank（排序）'
date: 2020-03-21
tags:
- C/C++
categories:
- OJ
- PAT
---

## 题目描述

[题目地址](https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480)

<!-- more -->

To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: `C` - C Programming Language, `M` - Mathematics (Calculus or Linear Algrbra), and `E` - English. At the mean time, we encourage students by emphasizing on their best ranks -- that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.

For example, The grades of `C`, `M`, `E` and `A` - Average of 4 students are given as the following:

```
StudentID  C  M  E  A
310101     98 85 88 90
310102     70 95 88 84
310103     82 87 94 88
310104     91 91 91 91
```

Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.

### Input Specification:

Each input file contains one test case. Each case starts with a line containing 2 numbers *N* and *M* (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then *N* lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of `C`, `M` and `E`. Then there are *M* lines, each containing a student ID.

### Output Specification:

For each of the *M* students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.

The priorities of the ranking methods are ordered as `A` > `C` > `M` > `E`. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.

If a student is not on the grading list, simply output `N/A`.

### Sample Input:

```in
5 6
310101 98 85 88
310102 70 95 88
310103 82 87 94
310104 91 91 91
310105 85 90 90
310101
310102
310103
310104
310105
999999
```

### Sample Output:

```out
1 C
1 M
1 E
1 A
3 A
N/A 
```

## 基本思路

题目本身没什么，就是PAT题目条件给的**太隐晦**了。。。很多条件都不明说

对于平均分是否四舍五入，并列的处理都不明说，全部藏在例子里面

是需要**四舍五入**的对于**并列是 1 1 3 4 5**这种（没有第二名了就）

所以只要把握这两点，这题目就很水了

首先按*ACME*的顺序对学生成绩排序，然后更新每个学生最好成绩就可以了，按*ACME*的顺序也是根据优先级安排的，在相同名次下，后排序更新的不做处理

这题目还可以使用**空间换时间的思路**，稍微加快一点处理，比如判断是否存在学生，因为学生的学号是个整数，所以直接开辟那么大的数组记录即可，对每个学生的分数排名都可以这么处理

**代码如下：**

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <cstdlib>
//#define LOCAL

using namespace std;

const int maxn = 2001;

struct Stu {
    int id;
    int score[4]; // A C M E 对应的分数
}stu[maxn];

const int maxn_ = 1e6;

bool is_exist[maxn_];   // 判断是否存在
int best_rank[maxn_];   // 记录对应的最好成绩
int best_rank_type[maxn_];  // 记录最好成绩对应的学科

int main() {
#ifdef LOCAL
    freopen("./in.txt", "r", stdin);
#endif
    // 初始化
    memset(is_exist, 0, sizeof(is_exist));
    memset(best_rank, 0x3f, sizeof(best_rank));

    int n, m; scanf("%d %d", &n, &m);
    for(int i = 0;i < n;i++) {
        scanf("%d %d %d %d",&stu[i].id, &stu[i].score[1], &stu[i].score[2], &stu[i].score[3]);
        stu[i].score[0] = (stu[i].score[1]+stu[i].score[2]+stu[i].score[3])/3 + 0.5; // 四舍五入
        is_exist[stu[i].id] = true; // 标记为存在
    }
    // 四个分数排序 按 A C M E 的顺序
    // 相同的情况后不能覆盖前（优先级）
    for(int i = 0;i < 4;i++) {
        sort(stu, stu+n, [i](Stu &a, Stu &b){ return a.score[i] > b.score[i]; });
        if(best_rank[stu[0].id] != 0) {
            best_rank[stu[0].id] = 0;
            best_rank_type[stu[0].id] = i;
        }
        int last_rank = 0;
        // 注意处理并列。。
        for(int j = 1;j < n;j++) {
            if(stu[j-1].score[i] != stu[j].score[i]) {
                last_rank = j;
            }
            if(best_rank[stu[j].id] > last_rank) {
                best_rank[stu[j].id] = last_rank;
                best_rank_type[stu[j].id] = i;
            }
        }
    }
    const char type[] = {'A', 'C', 'M', 'E'};
    for(int i = 0;i < m;i++) {
        int id; scanf("%d", &id);
        if(is_exist[id]) {
            printf("%d %c\n", best_rank[id] + 1, type[best_rank_type[id]]);
        }
        else {
            printf("N/A\n");
        }
    }
    return 0;
}
```

