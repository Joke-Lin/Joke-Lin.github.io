<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joke-Lin | BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joke-lin.top/"/>
  <updated>2020-04-21T09:07:27.283Z</updated>
  <id>https://joke-lin.top/</id>
  
  <author>
    <name>Joke-Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT Advanced 1043 Is It a Binary Search Tree（树）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-21-PAT-Advanced-1043/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-21-PAT-Advanced-1043/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:07:27.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDA5NzY2MzM4NTY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856">题目地址<i class="fa fa-external-link"></i></span></p><p>给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印词树的后续遍历结果</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>前序遍历：<span class="math inline">\(根节点 \rightarrow 左子树 \rightarrow 右子树\)</span>，对于根结点root，只需要将其之后的结点分为两部分（左小于，右大于等于），分别为左子树和右子树，然后对两部分继续递归分解。递归的结构恰好实现了后序遍历<span class="math inline">\(左子树 \rightarrow 右子树 \rightarrow 根节点\)</span>，只要在递归返回的时候记录当前节点值，就可以了。</p><p>对于非法搜索树的判断，即在切分子树的阶段，从序列的首尾向中心查找，如果存在没有被归入左子树或者右子树的，则为非法搜索树。</p><p>代码如下（参考了<span class="exturl" data-url="aHR0cHM6Ly93d3cubGl1Y2h1by5uZXQvYXJjaGl2ZXMvMjE1Mw==" title="https://www.liuchuo.net/archives/2153">刘婼<i class="fa fa-external-link"></i></span>的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre_order[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> is_mirror = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post_order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免只有一半的树 比如5 4 3，此时的ed是大于st的</span></span><br><span class="line">    <span class="keyword">if</span>(st &gt; ed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = st+<span class="number">1</span>, l = ed;</span><br><span class="line">    <span class="keyword">if</span>(!is_mirror) &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &lt; pre_order[st]) r++; <span class="comment">// 最后的r是大于l的 因为++，真正的位置是循环结束的r-1</span></span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &gt;= pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &gt;= pre_order[st]) r++;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &lt; pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r - l != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刚刚好为后续遍历</span></span><br><span class="line">    getTree(st+<span class="number">1</span>, l);   <span class="comment">//  左边</span></span><br><span class="line">    getTree(r, ed);     <span class="comment">// 右边</span></span><br><span class="line">    post_order.push_back(pre_order[st]);    <span class="comment">// 根结点 此处即为后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, pre_order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        post_order.clear();</span><br><span class="line">        is_mirror = <span class="literal">true</span>;</span><br><span class="line">        getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; post_order.size();i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, post_order[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != post_order.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印词树的后续遍历结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1040 Longest Symmetric String（动态规划）</title>
    <link href="https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1040/"/>
    <id>https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1040/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:34.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDYxMDIwNzMzNDQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344">题目地址<i class="fa fa-external-link"></i></span></p><p>求最长回文子串的长度</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>这里使用动态规划求解 <span class="math display">\[dp[i][j]=\begin{cases}true &amp; &amp; dp[i-1][j+1] == true \&amp;\&amp; str[i]==str[j] \\false &amp; &amp;\text{else}\end{cases}\]</span> dp[i][j] 表示substr(j, i) 是否是回文串</p><p>这里动态规划遍历的顺序可以有多种，我是以下标为遍历顺序，也可以以回文串长度作为遍历顺序。</p><p>还有一种算法为马拉车算法，实现了复杂度<span class="math inline">\(O(n)\)</span>。可参考<a href="https://joke-lin.top/2018/10/01/2018-10-01-manacher/">最长回文子串算法</a></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    fgets(s, maxn, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i][i<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            res = max(res, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求最长回文子串的长度&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="动态规划" scheme="https://joke-lin.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1038 Recover the Smallest Number （贪心）</title>
    <link href="https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1038/"/>
    <id>https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1038/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:41.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDk2MjUyODg3MDQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704">题目地址<i class="fa fa-external-link"></i></span></p><p>给定一系列数字串，使用他们组成一个最小的数字</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>似乎或者应该有那么点贪心的思路，重载一个排序函数，每次选取保证可以最小整个数字串的值。</p><p>重载<code>string</code>比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较的思路大概就是对于两个串，从开始遍历，优先选择数字小的，如果两个串前缀完全相同比如A：321，B：32，那么就比较，AB和BA的数字大小情况。</p><p>因为无论什么样的顺序，最终的数字位数是确定的，所以确定取那个串作为下一部分，只要选取前缀最小的就可以了。</p><p>注意00000的情况，需要打印一个0</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> num_str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; seq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num_str;</span><br><span class="line">        seq.push_back(num_str);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(seq.begin(), seq.end(), cmp);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : seq) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i[j] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一系列数字串，使用他们组成一个最小的数字&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="贪心" scheme="https://joke-lin.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1033 To Fill or Not to Fill （贪心）</title>
    <link href="https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1033/"/>
    <id>https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1033/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:47.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NTg3MjI3MzQwODA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080">题目地址<i class="fa fa-external-link"></i></span></p><p>给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。</p><a id="more"></a><h2 id="思路">思路</h2><p>思路清楚的话便十分简单了，大体思想就是贪心。贪心策略如下：</p><p>当到达一个加油站的时候，获取其满油状态下可以到达的最远距离，然后<strong>在当前和最远距离之间</strong>选取一个合适的加油站，作为下一次加油的站点。通过下面的方式获取合适站点：</p><ol type="1"><li>如果存在<strong>油价比当前所在加油站价格低</strong>的，则在当前加油站加油到恰好可以到达第一个油价低于它的</li><li>否则直接在当前加油站加满油，然后下一个加油站为满油状态下可到达的最远加油站</li></ol><p>如果到不了下一个油站则直接输出最大可到达距离即可。</p><p>需要特判一下开始位置没有加油站的情况，直接输出最大距离0.00。</p><p>此贪心策略画个图便很容易想到并证明了。如果在当前加油站可开到一个比他油价低的加油站则在低油价站点补充油一定比直接开要开销小。相反如果不能开到油价低的，则说明途径的油站价格都比原油站价格高，则在途中补充不如直接开到最后一个在补充。<strong>此正确性来自，每个加油站最多且保证可加到满油状态。</strong></p><p>注意在考虑的时候，要注意到此油站可能还剩余一些油。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">float</span> tank, dis, avg, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f %f %f %f"</span>, &amp;tank, &amp;dis, &amp;avg, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; &gt; gas_stations;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> v, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f %f"</span>, &amp;v, &amp;d);</span><br><span class="line">        gas_stations.push_back(&#123;d, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    gas_stations.push_back(&#123;dis, <span class="number">0</span>&#125;);   <span class="comment">// 将最后一个站设为免费加油站 便于后面处理</span></span><br><span class="line">    sort(gas_stations.begin(), gas_stations.end()); <span class="comment">// 按距离排序</span></span><br><span class="line">    <span class="comment">// 起始位置没有加油站</span></span><br><span class="line">    <span class="keyword">if</span>(gas_stations[<span class="number">0</span>].first != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> cost = <span class="number">0</span>, last_gas = <span class="number">0</span>;  <span class="comment">// 开销 &amp; 到此加油站剩余油</span></span><br><span class="line">    <span class="keyword">int</span> cur_pos = <span class="number">0</span>, stations_size = gas_stations.size();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> next_dis = gas_stations[cur_pos].first + tank*avg;  <span class="comment">// 在这个站满油情况下的可以开到的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> tar_pos = <span class="number">-1</span>;   <span class="comment">// 获取开销最小的下一个加油站</span></span><br><span class="line">        <span class="comment">// 从这段距离中获取合适的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_pos+<span class="number">1</span>;i &lt; stations_size;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].first &gt; next_dis) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tar_pos = i;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能到达到下一个站</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f"</span>, next_dis);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> gas_need; <span class="comment">// 需要购买的油</span></span><br><span class="line">        <span class="comment">// 有价格更小的站</span></span><br><span class="line">        <span class="keyword">if</span>(gas_stations[tar_pos].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">            gas_need = (gas_stations[tar_pos].first-gas_stations[cur_pos].first)/avg - last_gas;</span><br><span class="line">            last_gas = <span class="number">0</span>;   <span class="comment">// 直接买足够到下一个站的油即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 价格都比它大</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            gas_need = tank - last_gas;   <span class="comment">// 直接加满</span></span><br><span class="line">            last_gas = (next_dis - gas_stations[tar_pos].first)/avg; <span class="comment">// 更新到下一个站的油量</span></span><br><span class="line">        &#125;</span><br><span class="line">        cost += gas_need*gas_stations[cur_pos].second;</span><br><span class="line">        <span class="comment">// 到达目标地</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == stations_size<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_pos = tar_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="贪心" scheme="https://joke-lin.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1032 Sharing（链表）</title>
    <link href="https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1032/"/>
    <id>https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1032/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:53.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NjA2NTIxMTM5MjA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920">题目地址<i class="fa fa-external-link"></i></span></p><p>简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。</p><a id="more"></a><h2 id="思路">思路</h2><p>200ms的限制时间暴力是不可能暴力的，必须是线性时间的算法。</p><p>我的思路比较繁琐，首先获取两个字符串的完整路径，并分别记录他们的前置结点，和结尾结点位置。如果两个结尾不一样则输出-1，否则从末尾开始向前寻找第一个分支即可（两个字符串第一个路径前驱不同的位置）。</p><p>在生成路径的时候注意<strong>不要以是否为-1作为结束判断</strong>，有些字符串可能他只给出一部分，并没有-1结束标志。其次，采取这种思路在寻找前驱分支的时候，注意当两个字符串为同一个的情况（可能会出现）。可以实现将起始点的前驱结点赋值为不同的值，如-1，-2即可。</p><p>网上一种很简便的方法就是遍历字符串1，将遍历到的点记录，然后遍历字符串2，遇到的第一个字符串1中遍历过的，就是公共后缀的开始位置了。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; link;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> st_1, st_2, ed_1, ed_2, n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prev_1, prev_2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;st_1, &amp;st_2, &amp;n);</span><br><span class="line">    <span class="comment">// 防止有两个字符串完全一样的情况。。</span></span><br><span class="line">    prev_1[st_1] = <span class="number">-1</span>;</span><br><span class="line">    prev_2[st_2] = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur, next;</span><br><span class="line">        <span class="keyword">char</span> v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>, &amp;cur, &amp;v, &amp;next);</span><br><span class="line">        link[cur] = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = st_1;</span><br><span class="line">    <span class="comment">// 条件为link[cur].next != -1会TE 可能不会有-1结尾</span></span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_1[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_1 = cur;</span><br><span class="line">    cur = st_2;</span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_2[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_2 = cur;</span><br><span class="line">    <span class="keyword">if</span>(ed_1 != ed_2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev_1[cur] != prev_2[cur]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = prev_1[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1026 Table Tennis （模拟）</title>
    <link href="https://joke-lin.top/2020/04/09/2020-04-09-PAT-Advanced-1026/"/>
    <id>https://joke-lin.top/2020/04/09/2020-04-09-PAT-Advanced-1026/</id>
    <published>2020-04-08T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:59.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NzIzMzMyNTA1NjA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560">题目地址<i class="fa fa-external-link"></i></span></p><p>给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：</p><ul><li>当一个VIP球台空的时候，排队中的第一个VIP可以优先使用</li><li>如果当前没有VIP用户等待，普通用户也可以使用VIP球台</li><li>如果VIP用户没有VIP球台可以使用，就使用普通球台</li></ul><p>存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>其实有很多种处理的方式，我采取的策略为：</p><ol type="1"><li>用户按时间排序，将每个球台开放时间保存为数组</li><li>分别获取球台的最早的普通球台和VIP球台开放时间</li><li>如果是普通先开放，意味着没有VIP球台多余，直接给下一个等待用户即可，另外处理没有任何等待用户的情况</li><li>如果是VIP球台先开放（包含和普通同时开放的情况），查找顾客数组是否有VIP在等待，有的话给此VIP用户，否则给等待的第一个普通用户，如果没有人等待，进入处理无人等待的情况</li><li>无人等待的情况处理：没人等意味着下一个来的可以马上处理，如果来的是VIP查看是否有VIP球台，有给他，没有则给普通，普通用户则直接给空闲的编号最小的球台（此时没VIP等待）</li></ol><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FpeWlzaHVhaS9wLzExMzcyMTUzLmh0bWw=" title="https://www.cnblogs.com/caiyishuai/p/11372153.html">PAT 甲级 1026 Table Tennis (30 分)（坑点很多，逻辑较复杂，做了1天）<i class="fa fa-external-link"></i></span>其中的测试样例</p><p><strong>在<code>测试点8</code>错误了，原因为：在检查是否有VIP在排队的时候，忽略了此VIP用户可能在之前以及被处理（VIP有时候可以优先）</strong></p><p>代码实现还是有些细节的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrival;</span><br><span class="line">    <span class="keyword">int</span> served;</span><br><span class="line">    <span class="keyword">int</span> isvip;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Player&amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrival &lt; another.arrival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt; players; <span class="comment">// 存储玩家</span></span><br><span class="line">P tables[maxn]; <span class="comment">// 桌子 first：释放时间 second：是否VIP</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>, clock_21 = <span class="number">21</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">int</span> table_count[maxn];  <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">bool</span> is_served[<span class="number">10001</span>];  <span class="comment">// 玩家是否被服务 针对VIP优先处理</span></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = sec/<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (sec%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> s = sec%<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, h, m, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 以及更新对应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_serverd_player</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> table_pos, <span class="keyword">int</span> served_time)</span> </span>&#123;</span><br><span class="line">    print_time(players[index].arrival); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>; print_time(served_time); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">int</span> wait = (served_time - players[index].arrival + <span class="number">30</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, wait);</span><br><span class="line">    is_served[index] = <span class="literal">true</span>;</span><br><span class="line">    table_count[table_pos]++;</span><br><span class="line">    tables[table_pos].first = served_time + players[index].served;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回VIP和非VIP的最小下标</span></span><br><span class="line"><span class="function">P <span class="title">getMinTableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == <span class="number">-1</span> || tables[i].first &lt; tables[index2].first) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == <span class="number">-1</span> || tables[i].first &lt; tables[index1].first) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;index1, index2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有人等待的情况 VIP的话要先看是否有空闲的VIP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_wait</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取空闲VIP和普通的最小下标</span></span><br><span class="line">    <span class="keyword">int</span> index1 = INF, index2 = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">if</span>(players[index].isvip) &#123;</span><br><span class="line">        tar = index2 == INF ? index1 : index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tar = min(index1, index2);</span><br><span class="line">    &#125;</span><br><span class="line">    push_serverd_player(index, tar, players[index].arrival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(table_count, <span class="number">0</span>, <span class="keyword">sizeof</span>(table_count));</span><br><span class="line">    <span class="built_in">memset</span>(is_served, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_served));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> hh, mm, ss, p, tag;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d %d"</span>, &amp;hh, &amp;mm, &amp;ss, &amp;p, &amp;tag);</span><br><span class="line">        <span class="keyword">int</span> sec = hh*<span class="number">3600</span> + mm*<span class="number">60</span> + ss;</span><br><span class="line">        p = p &gt; <span class="number">120</span> ? <span class="number">120</span>*<span class="number">60</span> : p*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(sec &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        players.push_back(&#123;sec, p, tag&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(players.begin(), players.end());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        tables[i] = &#123;clock_8, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止全部都是普通或者VIP 导致获取下标函数返回没有意义的值</span></span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">0</span>&#125;;</span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> vip_pos; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vip_pos);</span><br><span class="line">        tables[vip_pos<span class="number">-1</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = players.size();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_served[index]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Player p = players[index];</span><br><span class="line">        P min_index = getMinTableIndex();</span><br><span class="line">        <span class="comment">// 后面的都不用处理了</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &gt;= clock_21 &amp;&amp; tables[min_index.second].first &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> table_empty_time;</span><br><span class="line">        <span class="comment">// 普通的先空 意味着没有VIP位置 那么直接给等待的下一个</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &lt; tables[min_index.second].first) &#123;</span><br><span class="line">            table_empty_time = tables[min_index.first].first;</span><br><span class="line">            <span class="comment">// 有人在等待</span></span><br><span class="line">            <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                push_serverd_player(index, min_index.first, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没人等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                no_wait(index);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在空的VIP 位置 注意VIP普通同时为空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table_empty_time = tables[min_index.second].first;</span><br><span class="line">            <span class="comment">// 寻找是否有等待的VIP 有则先给他位置 否则给下一个人</span></span><br><span class="line">            <span class="keyword">int</span> vip_pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; len;i++) &#123;</span><br><span class="line">                <span class="comment">// Error 8:最后一个测试点卡。。已经处理的VIP 跳过</span></span><br><span class="line">                <span class="keyword">if</span>(is_served[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(players[i].arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(players[i].isvip) &#123;</span><br><span class="line">                        vip_pos = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有VIP在等</span></span><br><span class="line">            <span class="keyword">if</span>(vip_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// printf("index:%d vip:%d\n", index, vip_pos);</span></span><br><span class="line">                push_serverd_player(vip_pos, min_index.second, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有VIP在等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 但有普通人等</span></span><br><span class="line">                <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="comment">// 普通人也可以选择VIP的位置 看哪个小选哪个</span></span><br><span class="line">                    <span class="keyword">int</span> tar_pos = tables[min_index.first].first == tables[min_index.second].first ? min(min_index.second, min_index.first) : min_index.second;</span><br><span class="line">                    push_serverd_player(index, tar_pos, table_empty_time);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没人等</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    no_wait(index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,table_count[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != k<span class="number">-3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个VIP球台空的时候，排队中的第一个VIP可以优先使用&lt;/li&gt;
&lt;li&gt;如果当前没有VIP用户等待，普通用户也可以使用VIP球台&lt;/li&gt;
&lt;li&gt;如果VIP用户没有VIP球台可以使用，就使用普通球台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>求解图的连通分量</title>
    <link href="https://joke-lin.top/2020/04/06/2020-04-06-connected-components/"/>
    <id>https://joke-lin.top/2020/04/06/2020-04-06-connected-components/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-04-06T14:42:33.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单定义">简单定义</h2><p>有向图中称为，强连通分量。连通图和连通分量都是针对无向图。</p><p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p><a id="more"></a><h2 id="无向图">无向图</h2><p>对于无向图而言，只要从一个点开始使用DFS或者BFS遍历所有可以遍历的边，这些遍历到的点集就构成了一个连通分量。然后寻找下一个之前没有遍历的点作为下一个连通分量的根结点，继续进行遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 连通分量的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num_nodes;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有向图">有向图</h2><p>下面两个算法都是<span class="math inline">\(O(N+E)\)</span>的复杂度</p><h3 id="tarjan算法">Tarjan算法</h3><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnl2b2lkLmNvbS96aHMvYmxvZy9zY2MtdGFyamFu" title="https://www.byvoid.com/zhs/blog/scc-tarjan">有向图强连通分量的Tarjan算法<i class="fa fa-external-link"></i></span></p><p>算法的基本思想如下：任选一节点开始进行深度优先搜索（<strong>若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行</strong>）。搜索过程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。</p><p>节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。</p><p>算法代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      <span class="comment">// 为节点u设定次序编号和Low初值</span></span><br><span class="line">    Stack.push(u)                              <span class="comment">// 将节点u压入栈中 其实就是保存拓扑序</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E                       <span class="comment">// 枚举每一条边</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)                   <span class="comment">// 如果节点v未被访问过</span></span><br><span class="line">            tarjan(v)                          <span class="comment">// 继续向下找</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)                       <span class="comment">// 如果节点v还在栈内</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])                      <span class="comment">// 如果节点u是强连通分量的根</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                          <span class="comment">// 将v退栈，为该强连通分量中一个顶点</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>DFN[u]：为结点u的搜索编号（时间次序）</li><li>Low[u]：为结点u和与结点u相连的子树的最小搜索序（最早出现时间）</li></ul><p>此算法其中判断强连通分量的思路就是，在以u为根节点进行DFS的过程中如果出现一个结点v指向了之前遍历过的点t，即<span class="math inline">\(u \rightarrow t \rightarrow v \rightarrow t\)</span>也就表明出现了一个环，其中<span class="math inline">\(t,v,t\)</span>就构成了环，即连通分量。</p><p>其中的DFN就保存每个结点的访问顺序，Low保存相关子树的最早访问时间，在算法回溯的时候更新，可保证一个强连通分量的Low都是一致的，栈保存的是拓扑序，即遍历的次序，不断出栈获取连通分量。</p><h3 id="kosaraju算法">Kosaraju算法</h3><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNjQzNzkyNi5odG1s" title="https://www.cnblogs.com/nullzx/p/6437926.html">Kosaraju算法解析: 求解图的强连通分量<i class="fa fa-external-link"></i></span></p><p>Kosaraju算法比Tarjan算法看似要简单一些，但效率没有Tarjan算法高，Kosaraju算法依靠DFS遍历获取极大连通子图。但存在一点问题。</p><p><img src="\assets\ArticleImg\2020\connected-components-1.png" /></p><p>对于上图，从A0开始遍历和B4开始遍历是不一样的结果。如果从B开始遍历，需要2次DFS便可以遍历完整个图，而A0只需要一次。<strong>所以Kosaraju算法的第一个DFS需要获取正确的遍历顺序，</strong>然后第二次DFS的次数便是连通分量的个数了。</p><p>上图的反图为：</p><p><img src="\assets\ArticleImg\2020\connected-components-2.jpg" /></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) dfs1(v);</span><br><span class="line">  s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      dfs2(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是两点：</p><ol type="1"><li>后序遍历获取拓扑序，保证BA的相对顺序不会改变</li><li>反向原图根据上面获取的遍历顺序，重新DFS</li></ol><h4 id="反图的作用">反图的作用</h4><p>其中的反图很有意思，对于强连通子图，反图和原图并无区别。但对于非强连通的则会有很大的影响。例如<span class="math inline">\(A \rightarrow B \rightarrow C\)</span>反图为<span class="math inline">\(A \leftarrow B \leftarrow C\)</span> 从A开始遍历一次便遍历完，但反图后从A开始便需要3次，也就是强连通分量的个数（单个结点也是强连通）。</p><p><strong>所以通过后续遍历获取遍历结点的顺序，然后通过反图获取强连通分量的个数。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单定义&quot;&gt;简单定义&lt;/h2&gt;
&lt;p&gt;有向图中称为，强连通分量。连通图和连通分量都是针对无向图。&lt;/p&gt;
&lt;p&gt;在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点&lt;strong&gt;强连通&lt;/strong&gt;(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个&lt;strong&gt;强连通图&lt;/strong&gt;。非强连通图有向图的极大强连通子图，称为&lt;strong&gt;强连通分量&lt;/strong&gt;(strongly connected components)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1021 Deepest Root （连通分量+树的直径）</title>
    <link href="https://joke-lin.top/2020/04/03/2020-04-03-PAT-Advanced-1021/"/>
    <id>https://joke-lin.top/2020/04/03/2020-04-03-PAT-Advanced-1021/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:12.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODI5MTk2NzM4NTY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856">题目地址<i class="fa fa-external-link"></i></span></p><p>一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。</p><a id="more"></a><h2 id="思路">思路</h2><p>掌握了基础的<a href="/2020/04/06/2020-04-06-connected-components/">连通分量的求法</a>以及<a href="/2020/04/02/2020-04-02-tree-diameter/">树的直径的算法</a>便很简单了</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"><span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDeepest</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;height_set, <span class="keyword">int</span> heights = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            getDeepest(G[root][i], height_set, heights+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_height == heights) &#123;</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_height &lt; heights) &#123;</span><br><span class="line">            height_set.clear();</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">            max_height = heights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            components++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(components &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>, components);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st_points, ed_points;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(<span class="number">1</span>, st_points);</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(*st_points.begin(), ed_points);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ed_points) &#123;</span><br><span class="line">            st_points.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : st_points) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>树的直径</title>
    <link href="https://joke-lin.top/2020/04/02/2020-04-02-tree-diameter/"/>
    <id>https://joke-lin.top/2020/04/02/2020-04-02-tree-diameter/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-04-07T02:33:17.439Z</updated>
    
    <content type="html"><![CDATA[<p>树的直径，即<strong>树中距离最远的两个节点的距离</strong>。</p><h2 id="求解方法">求解方法</h2><p>选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。</p><a id="more"></a><h2 id="简单证明">简单证明</h2><p>其实只要证明：<strong>以任意点为根节点，距离此根节点最远的节点必定是树的直径中的一个端点。</strong></p><p>证明了这个，那么上面提到的算法就很容易证明了，获取第一个端点，然后以此端点为根的最远端点就是另外一个端点。</p><p>首先规定从<em>r</em>开始的最远距离节点为<em>u</em>，证明<em>u</em>为树的直径的一个端点，可以使用反证法证明，假设存在另外两个节点<em>s,t</em>，构成了树的直径。</p><ol type="1"><li><p><strong><em>st</em>的路径和<em>ru</em>不相交</strong>：</p><p>在这种情况下，存在<span class="math inline">\(dis(u,s)+dis(s,t) &gt; dis(s,t)\)</span>，所以<em>st</em>并不是最长的，和假设相矛盾，<em>st</em>这种情况下不存在</p></li><li><p><strong><em>st</em>的路径和<em>ru</em>相交于点<em>v</em>：</strong></p><p>此时<em>s,u</em>都是以<em>a</em>为根的子树上的节点，因为u为距离a最远的结点所以可得： <span class="math display">\[ dis(a,y)+dis(y,u) &gt; dis(a,y)+dis(y,s) \\ 即：dis(u,y) &lt; dis(s,y) \]</span> 同样表示<em>s,t</em>并不是最长的，而是<em>u,t</em></p></li></ol><p>综上，<em>u</em>必定为树的直径的一个端点。</p><p>关于树的直径的更多性质可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2hhZGEtSmhpbi9wLzEwMTk1Mjg3Lmh0bWw=" title="https://www.cnblogs.com/Khada-Jhin/p/10195287.html">博客园 树的直径及其性质与证明<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树的直径，即&lt;strong&gt;树中距离最远的两个节点的距离&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;求解方法&quot;&gt;求解方法&lt;/h2&gt;
&lt;p&gt;选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1020 Tree Traversals （二叉树）</title>
    <link href="https://joke-lin.top/2020/04/01/2020-04-01-PAT-Advanced-1020/"/>
    <id>https://joke-lin.top/2020/04/01/2020-04-01-PAT-Advanced-1020/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:17.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODUwMzM2MDMwNzI=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072">题目地址<i class="fa fa-external-link"></i></span></p><p>给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了</p><a id="more"></a><h2 id="解决思路">解决思路</h2><p>这是一个很经典的重构二叉树的问题了，只要清楚每种遍历的规则和规律即可。</p><p>后序遍历：左子树，右子树，根节点</p><p>中序遍历：左子树，根节点，右子树</p><p>所以对后序遍历而言，后面的节点是前面节点构成的树的根节点，前面节点构成左子树和右子树，所以我们可以采取以下方案获取整棵树的结构。</p><p>从后序遍历数组<code>postorder</code>的末尾开始，从<code>inorder</code>数组中寻找和<code>postorder</code>相同值的，<strong>这样就可以分为两边，分别是左子树和右子树</strong>。然后将<code>postorder</code>末尾向前移动一步，对应的就是右子树的根节点。然后在<code>inorder</code>刚刚分开的右半边继续寻找即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> postorder[maxn];</span><br><span class="line"><span class="keyword">int</span> inorder[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left = <span class="literal">NULL</span>, *right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一棵树 根据根节点的值（这里提供postorder的下标），以及inorder的左右边界</span></span><br><span class="line"><span class="function">Node* <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> post_i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *t_root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 分开左右子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == postorder[post_i]) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_root-&gt;val = inorder[mid];</span><br><span class="line">    <span class="comment">// 递归左右子数</span></span><br><span class="line">    t_root-&gt;right = getTree(post_i<span class="number">-1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    t_root-&gt;left = getTree(post_i - (r - mid) - <span class="number">1</span>, l, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, postorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, inorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getTree(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">    que.push(root-&gt;left);</span><br><span class="line">    que.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        Node *t = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,t-&gt;val);</span><br><span class="line">        que.push(t-&gt;left);</span><br><span class="line">        que.push(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1018 Public Bike Management（Dijkstra + DFS）</title>
    <link href="https://joke-lin.top/2020/03/31/2020-03-31-PAT-Advanced-1018/"/>
    <id>https://joke-lin.top/2020/03/31/2020-03-31-PAT-Advanced-1018/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:23.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODkyODI0MzMwMjQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024">题目地址<i class="fa fa-external-link"></i></span></p><p>一眼看去便是最短路问题，和<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003<i class="fa fa-external-link"></i></span>，有点类似，但又不同。</p><p>题目就是求最短路，多条最短路取从基地携带数量最少了，如果有一样的携带数量，就取带回数量最少的，确保这样的路径唯一。</p><a id="more"></a><h2 id="解决思路">解决思路</h2><p>开始以为与<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003<i class="fa fa-external-link"></i></span>一样，但是还是不一样的，因为最短路的子路并不是最优子结构，也就是满足当前的最优条件不一定会满足整体的。这里就必须先将所有的最短路找出，然后计算每一条路的携带数量和带回数量，来选取最优的路径。</p><p>有一个一不注意就中招的坑：在计算携带数量和带回数量的时候需要考虑先后关系，即后面多余的车不能补充前面的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;    <span class="comment">// P.first 为 起始点到 P.second 的最短路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, cost;&#125;;<span class="comment">// 边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];       <span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn];           <span class="comment">// 每个站点的权值</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];                <span class="comment">// 对应点的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev_node[maxn];        <span class="comment">// 最短路的树结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; shortest_paths; <span class="comment">// 起始点到问题点的所有最短路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 获取路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    temp.push_back(root);</span><br><span class="line">    <span class="keyword">if</span>(prev_node[root].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        shortest_paths.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prev_node[root].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        dfs(prev_node[root][i], temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">int</span> c_max, n, problem, m; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;c_max, &amp;n, &amp;problem, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        weight[i] = c_max/<span class="number">2</span> - temp; <span class="comment">// 正 表示carry 负 表示 back</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st, ed, cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;st, &amp;ed, &amp;cost);</span><br><span class="line">        G[st].push_back(&#123;ed, cost&#125;);</span><br><span class="line">        G[ed].push_back(&#123;st, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt;&gt; que;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        P t = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(d[t.second] &lt; t.first) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[t.second].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            edge e = G[t.second][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to] = &#123;t.second&#125;;</span><br><span class="line">                d[e.to] = d[t.second] + e.cost;</span><br><span class="line">                que.push(make_pair(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[e.to] == d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to].push_back(t.second);    <span class="comment">// 添加前置节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(problem);</span><br><span class="line">    <span class="keyword">int</span> min_carry = INF, min_back = INF, min_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; shortest_paths.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, back = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = shortest_paths[i].<span class="built_in">size</span>() - <span class="number">2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="comment">// 坑点 必须按照路径的前进 方向改变对于数值，即后面节点的多余不能给前面节点使用</span></span><br><span class="line">            <span class="keyword">int</span> need = weight[shortest_paths[i][j]];</span><br><span class="line">            <span class="keyword">if</span>(need &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                carry += back - need &gt; <span class="number">0</span> ? <span class="number">0</span> : need - back;</span><br><span class="line">                back = back - need &gt; <span class="number">0</span> ? back - need : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                back += -need;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &lt; min_carry) &#123;</span><br><span class="line">            min_carry = carry;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(carry == min_carry &amp;&amp; back &lt; min_back) &#123;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, min_carry);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = shortest_paths[min_index].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, shortest_paths[min_index][i]);</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, min_back);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一眼看去便是最短路问题，和&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1003&lt;/a&gt;，有点类似，但又不同。&lt;/p&gt;
&lt;p&gt;题目就是求最短路，多条最短路取从基地携带数量最少了，如果有一样的携带数量，就取带回数量最少的，确保这样的路径唯一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>画个简陋樱花树（简单递归）</title>
    <link href="https://joke-lin.top/2020/03/31/2020-03-31-Draw-CherryTree/"/>
    <id>https://joke-lin.top/2020/03/31/2020-03-31-Draw-CherryTree/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-03-31T13:22:36.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到网上很多代码绘制的樱花树，参见<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0Mzk3Ny9hcnRpY2xlL2RldGFpbHMvMTAyNjkxMzky" title="https://blog.csdn.net/weixin_43943977/article/details/102691392">CSDN<i class="fa fa-external-link"></i></span>，便想自己试试，但是画的有点丑</p></blockquote><a id="more"></a><h2 id="基本思路">基本思路</h2><p>其实就是一个“二叉树的遍历”的思路，使用递归不断的二叉，就可以了，这也算是分形图案了。但是简单的递归二叉，不掌握好长度、角度、粗细以及主干和枝干的变化就会很规整。所以慢慢调参吧。</p><p>这里采用的是给出每个参数的最大取值范围，然后设置一个缩小的函数，随着递归层数的提高，对应的参数越来越小，这个小的程度和范围就要自己把握了。</p><p>缩小函数可以参考：<span class="math inline">\(\frac{1}{n},\frac{1}{\sqrt{n}}\)</span></p><h2 id="依赖">依赖</h2><p>这里的樱花树使用的是一个简单的<span class="exturl" data-url="aHR0cHM6Ly9lYXN5eC5jbi8=" title="https://easyx.cn/">C++图形库 easyx<i class="fa fa-external-link"></i></span>，简单容易上手。</p><h2 id="演示">演示</h2><video src="/assets/ArticleVideo/2020/draw-cherrytree.mp4" preload="metadata" controls playsinline poster="">Sorry, your browser does not support the video tag.</video><h2 id="基础代码">基础代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED (RGB(240, 128, 128))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE (RGB(255, 255, 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROWN (RGB(160, 82, 45))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与主干角度的偏移角度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_min = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_max = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_min = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_max = <span class="number">90</span>;</span><br><span class="line"><span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> thick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区大小</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = <span class="number">800</span>, <span class="built_in">height</span> = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一条线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawline</span><span class="params">(Point st, Point ed)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">line</span>(st.first, st.second, ed.first, ed.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生范围内的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_range</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st + rand() % (ed - st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给点原点 相对于水平的角度 长度 返回处理后的节点</span></span><br><span class="line"><span class="function">Point <span class="title">getPointFromAngle</span><span class="params">(Point src, <span class="keyword">float</span> angle, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    angle = <span class="number">3.14</span>/<span class="number">180.0</span> * angle;</span><br><span class="line">    <span class="keyword">return</span> &#123; src.first+length*<span class="built_in">cos</span>(angle), src.second-length*<span class="built_in">sin</span>(angle) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归画叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_bifurcation</span><span class="params">(Point p, <span class="keyword">float</span> angle, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束层</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 偏移角</span></span><br><span class="line">    <span class="keyword">float</span> delta = rand_range(angle_min, angle_max);</span><br><span class="line">    <span class="comment">// 收缩 使用根号</span></span><br><span class="line">    <span class="keyword">float</span> shrink = <span class="built_in">pow</span>(layer, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 便宜的角度越来越小</span></span><br><span class="line">    <span class="keyword">float</span> left_angle = angle + delta/shrink;</span><br><span class="line">    <span class="comment">// 右分支的角度确定</span></span><br><span class="line">    <span class="keyword">float</span> right_angle = left_angle - <span class="number">2.4</span>*delta/shrink;</span><br><span class="line">    <span class="comment">// 随机长度</span></span><br><span class="line">    <span class="keyword">int</span> length_left = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="keyword">int</span> length_right = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="comment">// 获取下一个分支点</span></span><br><span class="line">    Point left = getPointFromAngle(p, left_angle, length_left);</span><br><span class="line">    Point right = getPointFromAngle(p, right_angle, length_right);</span><br><span class="line">    <span class="comment">// 末端绘制红白相间的花瓣</span></span><br><span class="line">    <span class="keyword">int</span> type = rand() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置厚度</span></span><br><span class="line">    setlinestyle(PS_SOLID , thick/layer);</span><br><span class="line">    drawline(p, left);</span><br><span class="line">    <span class="comment">// 递归左分支</span></span><br><span class="line">    draw_bifurcation(left, left_angle, layer + <span class="number">1</span>);</span><br><span class="line">    setlinestyle(PS_SOLID, thick / layer);</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态效果</span></span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    drawline(p, right);</span><br><span class="line">    <span class="comment">// 递归右分支</span></span><br><span class="line">    draw_bifurcation(right, right_angle, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机绘制地面的花瓣</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_ground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">width</span> * <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">width</span> * <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="built_in">height</span> - <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line">    setlinecolor(RED);</span><br><span class="line">    setlinestyle(PS_SOLID, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y, angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        x = rand_range(left, right);</span><br><span class="line">        y = rand_range(up, down);</span><br><span class="line">        angle = rand_range(<span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line">        Point ed = getPointFromAngle(&#123; x, y &#125;, angle, length);</span><br><span class="line">        Sleep(<span class="number">5</span>);</span><br><span class="line">        drawline(&#123; x, y &#125;, ed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initgraph(<span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    <span class="comment">// 设置背景色</span></span><br><span class="line">    setbkcolor(RGB(<span class="number">241</span>, <span class="number">215</span>, <span class="number">118</span>));</span><br><span class="line">    cleardevice();</span><br><span class="line">    <span class="comment">// 绘制主干</span></span><br><span class="line">    setlinecolor(BROWN);</span><br><span class="line">    setlinestyle(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">line</span>(<span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-110</span>, <span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-20</span>);</span><br><span class="line">    <span class="comment">// 递归绘制</span></span><br><span class="line">    draw_bifurcation(&#123; <span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-110</span> &#125;, <span class="number">90.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 绘制掉落花瓣的地面</span></span><br><span class="line">    draw_ground();</span><br><span class="line">    _getch();</span><br><span class="line">    closegraph();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看到网上很多代码绘制的樱花树，参见&lt;a href=&quot;https://blog.csdn.net/weixin_43943977/article/details/102691392&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;，便想自己试试，但是画的有点丑&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ELSE" scheme="https://joke-lin.top/categories/ELSE/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1017 Queueing at Bank（优先队列）</title>
    <link href="https://joke-lin.top/2020/03/29/2020-03-29-PAT-Advanced-1017/"/>
    <id>https://joke-lin.top/2020/03/29/2020-03-29-PAT-Advanced-1017/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:42.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTE1MzA1Nzk5Njg=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968">题目地址<i class="fa fa-external-link"></i></span></p><p>和 1014 很相似的题目，同样使用优先队列解决，容易的一道题。</p><p>题目的意思是真的难懂，17：00之后不能被服务，17：00 是到达时间。。不是服务时间，服务时间不能超过1小时是指大于1小时的按一小时处理，而不是不处理</p><a id="more"></a><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrive;</span><br><span class="line">    <span class="keyword">int</span> leave;</span><br><span class="line">    <span class="keyword">int</span> serve_secs;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer &amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrive &lt; another.arrive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_17 = <span class="number">17</span>*<span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> whole_wait_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> legal_nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h, m, s, t; <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d"</span>, &amp;h, &amp;m, &amp;s, &amp;t);</span><br><span class="line">        <span class="keyword">int</span> arrive = h*<span class="number">60</span>*<span class="number">60</span> + m*<span class="number">60</span> + s;</span><br><span class="line">        <span class="keyword">if</span>(arrive &gt; clock_17) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        customers[legal_nums].arrive = arrive;</span><br><span class="line">        customers[legal_nums++].serve_secs = t &gt; <span class="number">60</span> ? <span class="number">3600</span> : t*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(customers, customers + legal_nums);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; leave_que;</span><br><span class="line">    <span class="comment">// 先push M 个 8：00 全在8点离开</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        leave_que.push(clock_8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; legal_nums;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> serve_time = <span class="built_in">max</span>(leave_que.top(), customers[i].arrive); leave_que.pop();</span><br><span class="line">        leave_que.push(serve_time + customers[i].serve_secs);</span><br><span class="line">        whole_wait_sec += serve_time - customers[i].arrive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, legal_nums == <span class="number">0</span> ? <span class="number">0.0</span> : whole_wait_sec/<span class="number">60.0</span>/legal_nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和 1014 很相似的题目，同样使用优先队列解决，容易的一道题。&lt;/p&gt;
&lt;p&gt;题目的意思是真的难懂，17：00之后不能被服务，17：00 是到达时间。。不是服务时间，服务时间不能超过1小时是指大于1小时的按一小时处理，而不是不处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1016 Phone Bills（排序）</title>
    <link href="https://joke-lin.top/2020/03/27/2020-03-27-PAT-Advanced-1016/"/>
    <id>https://joke-lin.top/2020/03/27/2020-03-27-PAT-Advanced-1016/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:55.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTM2NDg3MDM0ODg=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488">题目地址<i class="fa fa-external-link"></i></span></p><p>提交了整整一个下午。。。</p><p>再次吐槽PAT的题目描述，很多时候都是迷迷糊糊的，很多地方没有说清楚。</p><p>这道题一个巨大的坑：<strong>没有符合条件的时间对时，不输出该用户信息</strong></p><p>太坑了。。</p><a id="more"></a><h2 id="题目思路">题目思路</h2><p>题目还是比较简单的，简单的排序即可，可以全部存为一个数组，然后先按名字排序，在名字相同时按时间排序即可。此处采用 C++ Map 分类。对每一个顾客的时间进行排序。然后仅当 当前时间为 <code>on-line</code>紧跟着的下一个时间为<code>off-line</code> 为有效时间对。</p><p>仅当存在有效时间对时才有对应的输出。</p><p>对于一段时间的计费，可以分别计算单独时间到<code>00:00:00</code>的费用，然后相减即可，一个很好的思路。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, mon, day, hour, mins;</span><br><span class="line">    <span class="keyword">bool</span> type;  <span class="comment">// 1: on-line 0: off-line</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Record&amp; another) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; another.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;Record&gt;&gt; calls;</span><br><span class="line"><span class="keyword">int</span> price_table[<span class="number">24</span>], price_day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCost</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = tar.day, h = tar.hour, m = tar.mins;</span><br><span class="line">    ll cost = d * price_day;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++) &#123;</span><br><span class="line">        cost += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cost += price_table[h]*m;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, tar.day, tar.hour, tar.mins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">24</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, price_table+i);</span><br><span class="line">        price_day += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> customer, t, <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; customer;</span><br><span class="line">        Record temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d:%d"</span>, &amp;temp.mon, &amp;temp.day, &amp;temp.hour, &amp;temp.mins);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">line</span>;</span><br><span class="line">        temp.type = <span class="built_in">line</span> == <span class="string">"on-line"</span>;</span><br><span class="line">        temp.t = <span class="number">24</span>*<span class="number">60</span>*temp.day + <span class="number">60</span>*temp.hour + temp.mins; <span class="comment">// 获取从00:00:00到此的分钟数</span></span><br><span class="line">        calls[customer].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : calls) &#123;</span><br><span class="line">        sort(i.second.<span class="built_in">begin</span>(), i.second.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = i.second.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">float</span> cost_all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 判断是否存在有效时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">size</span> - <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second[j].type == <span class="literal">true</span> &amp;&amp; i.second[j+<span class="number">1</span>].type == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i.first &lt;&lt; <span class="string">" "</span>; <span class="built_in">printf</span>(<span class="string">"%02d\n"</span>, i.second[<span class="number">0</span>].mon);</span><br><span class="line">                &#125;</span><br><span class="line">                printTime(i.second[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                printTime(i.second[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> temp_cost = (getCost(i.second[j+<span class="number">1</span>]) - getCost(i.second[j]))/<span class="number">100.0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d $%.2f\n"</span>, i.second[j+<span class="number">1</span>].t - i.second[j].t, temp_cost);</span><br><span class="line">                cost_all += temp_cost;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Total amount: $%.2f\n"</span>, cost_all);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提交了整整一个下午。。。&lt;/p&gt;
&lt;p&gt;再次吐槽PAT的题目描述，很多时候都是迷迷糊糊的，很多地方没有说清楚。&lt;/p&gt;
&lt;p&gt;这道题一个巨大的坑：&lt;strong&gt;没有符合条件的时间对时，不输出该用户信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;太坑了。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>埃氏筛 &amp; 欧拉筛</title>
    <link href="https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/"/>
    <id>https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-26T15:14:03.571Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。</p></blockquote><a id="more"></a><h2 id="试除法">试除法</h2><p>直接使用定义解决的方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从2遍历到<span class="math inline">\(\sqrt n\)</span> 因为之后的就没有必要了，一个和数拆分成两个因子必定是在<span class="math inline">\(\sqrt n\)</span>的两侧，是对称的，所以只需要遍历一边就可以了。</p><h2 id="埃氏筛">埃氏筛</h2><p>上面的算法是判断一个数是否是素数，但是对获取某个范围的素数开销非常大。埃氏筛（素数筛）就是求某个范围素数的算法。</p><p>原理很简单，合数必定可以拆分为一系列素数的积，即<strong>某个素数的任意倍数都是合数</strong>。</p><p>代码也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxn 为范围的上届</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; maxn;j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度为：<span class="math inline">\(n\log \log n\)</span></p><h2 id="欧拉筛">欧拉筛</h2><p>埃氏筛很明显的一个缺点就是一个合数会被重复筛掉（被每一个素数因子筛一次），增加复杂度。欧拉筛就是在其上的改进，使每一个合数只被它的最小因子筛掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;i*prime_numbers[j] &lt; maxn;j++) &#123;</span><br><span class="line">        is_prime[i*prime_numbers[j]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime_numbers[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧拉筛复杂度为n（将空循环不视作开销），每个合数仅被筛一次。</p><p>核心就在于<code>i % prime_numbers[j] == 0</code>，当这个条件成立的时候跳出循环，不继续往下筛，下面的都是已经或者未来要被筛掉的。</p><p>条件成立时意味着 <span class="math inline">\(i = prime\_numbers[j] \times K\)</span>，而继续循环下去回得到<span class="math inline">\(i*prime\_numbers[j+1]\)</span>也就是,<span class="math inline">\(prime\_numbers[j]\times prime\_numbers[j+1] \times K = prime\_numbers[j] \times Q\)</span>，也就是说它会被<span class="math inline">\(prime\_numbers[j]\)</span>乘以另外一个数给筛掉，之后的循环也就没必要进行了。也保证了，每个合数都只被它的最小因子筛掉。</p><p>令<span class="math inline">\(N = K \times Q \times ...\)</span> K Q为两个素数且<span class="math inline">\(Q \gt K\)</span>，假设N可以被Q筛掉，也就是$N = Q M， M= K... $这里的M就是上面循环中的i，它是不可能使用QM筛掉的，因为<code>M%K == 0</code>，就跳出循环之外了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1014 Waiting in Line（优先队列）</title>
    <link href="https://joke-lin.top/2020/03/21/2020-03-24-PAT-Advanced-1014/"/>
    <id>https://joke-lin.top/2020/03/21/2020-03-24-PAT-Advanced-1014/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:35.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTgyMDc5MTE5MzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936">题目地址<i class="fa fa-external-link"></i></span></p><p>之前一直错还是题目看错，英文题目还是要注意啊。</p><p>17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>题目本身不难，理清楚过程即可。（他题目有些也迷）</p><p>给出了N个窗口以及最大等待区M，K个顾客。相当于本来就有K个人在排队，然后每个人依次选窗口当等待区有空位的适合。等待区总共可以容纳NM个人，所以最前面的NM个人依次排满等待区即可（按照题目定的规则），当等待区满的时候，只要有一个人结束服务，那在等待区外排队的人就马上可以塞进去一个。</p><p>所以我们需要知道的就是最早结束服务的人，这就可以用到优先队列了，维护结束服务的时间。时间越早优先级越高。每当他进入等待区，就push到优先队列中。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> win_index;</span><br><span class="line">    <span class="keyword">int</span> end_time;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer&amp; other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 同时离开 选择编号小的</span></span><br><span class="line">        <span class="keyword">return</span> end_time != other.end_time ? end_time &gt; other.end_time : win_index &gt; other.win_index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost_time[maxn];    <span class="comment">// 用户的花费时间</span></span><br><span class="line"><span class="keyword">int</span> end_time[maxn];     <span class="comment">// 每个用户的结束时间</span></span><br><span class="line"><span class="keyword">int</span> win_cur_time[<span class="number">21</span>];   <span class="comment">// 当前窗口等待区清空的最晚时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(win_cur_time, <span class="number">0</span>, <span class="keyword">sizeof</span>(win_cur_time));</span><br><span class="line">    <span class="built_in">memset</span>(end_time, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(end_time));</span><br><span class="line">    <span class="keyword">int</span> n, m, k, q; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, cost_time+i);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;Customer&gt; que;</span><br><span class="line">    <span class="comment">// 前NM个直接加入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k &amp;&amp; i &lt; n*m;i++) &#123;</span><br><span class="line">        win_cur_time[i%n] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[i%n];</span><br><span class="line">        que.push(&#123;i%n, end_time[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n*m;i &lt; k;i++) &#123;</span><br><span class="line">        Customer temp = que.top(); que.pop();   <span class="comment">// 获取最早离开的</span></span><br><span class="line">        win_cur_time[temp.win_index] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[temp.win_index];</span><br><span class="line">        temp.end_time = end_time[i];</span><br><span class="line">        que.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tar);</span><br><span class="line">        <span class="keyword">int</span> mins = end_time[tar<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// 开始服务的时间不能晚于17:00</span></span><br><span class="line">        <span class="keyword">if</span>(mins - cost_time[tar<span class="number">-1</span>] &gt;= <span class="number">540</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorry\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:%02d\n"</span>, <span class="number">8</span>+mins/<span class="number">60</span>, mins%<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前一直错还是题目看错，英文题目还是要注意啊。&lt;/p&gt;
&lt;p&gt;17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1012 The Best Rank（排序）</title>
    <link href="https://joke-lin.top/2020/03/21/2020-03-21-PAT-Advanced-1012/"/>
    <id>https://joke-lin.top/2020/03/21/2020-03-21-PAT-Advanced-1012/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:50.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDI2NTgwNjg0ODA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480">题目地址<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks -- that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 2 numbers <em>N</em> and <em>M</em> (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then <em>N</em> lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are <em>M</em> lines, each containing a student ID.</p><h3 id="output-specification">Output Specification:</h3><p>For each of the <em>M</em> students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output <code>N/A</code>.</p><h3 id="sample-input">Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure><h3 id="sample-output">Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N&#x2F;A</span><br></pre></td></tr></table></figure><h2 id="基本思路">基本思路</h2><p>题目本身没什么，就是PAT题目条件给的<strong>太隐晦</strong>了。。。很多条件都不明说</p><p>对于平均分是否四舍五入，并列的处理都不明说，全部藏在例子里面</p><p>是需要<strong>四舍五入</strong>的对于<strong>并列是 1 1 3 4 5</strong>这种（没有第二名了就）</p><p>所以只要把握这两点，这题目就很水了</p><p>首先按<em>ACME</em>的顺序对学生成绩排序，然后更新每个学生最好成绩就可以了，按<em>ACME</em>的顺序也是根据优先级安排的，在相同名次下，后排序更新的不做处理</p><p>这题目还可以使用<strong>空间换时间的思路</strong>，稍微加快一点处理，比如判断是否存在学生，因为学生的学号是个整数，所以直接开辟那么大的数组记录即可，对每个学生的分数排名都可以这么处理</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>]; <span class="comment">// A C M E 对应的分数</span></span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn_ = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_exist[maxn_];   <span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">int</span> best_rank[maxn_];   <span class="comment">// 记录对应的最好成绩</span></span><br><span class="line"><span class="keyword">int</span> best_rank_type[maxn_];  <span class="comment">// 记录最好成绩对应的学科</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(is_exist, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_exist));</span><br><span class="line">    <span class="built_in">memset</span>(best_rank, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(best_rank));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;stu[i].id, &amp;stu[i].score[<span class="number">1</span>], &amp;stu[i].score[<span class="number">2</span>], &amp;stu[i].score[<span class="number">3</span>]);</span><br><span class="line">        stu[i].score[<span class="number">0</span>] = (stu[i].score[<span class="number">1</span>]+stu[i].score[<span class="number">2</span>]+stu[i].score[<span class="number">3</span>])/<span class="number">3</span> + <span class="number">0.5</span>; <span class="comment">// 四舍五入</span></span><br><span class="line">        is_exist[stu[i].id] = <span class="literal">true</span>; <span class="comment">// 标记为存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四个分数排序 按 A C M E 的顺序</span></span><br><span class="line">    <span class="comment">// 相同的情况后不能覆盖前（优先级）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        sort(stu, stu+n, [i](Stu &amp;a, Stu &amp;b)&#123; <span class="keyword">return</span> a.score[i] &gt; b.score[i]; &#125;);</span><br><span class="line">        <span class="keyword">if</span>(best_rank[stu[<span class="number">0</span>].id] != <span class="number">0</span>) &#123;</span><br><span class="line">            best_rank[stu[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">            best_rank_type[stu[<span class="number">0</span>].id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last_rank = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意处理并列。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j<span class="number">-1</span>].score[i] != stu[j].score[i]) &#123;</span><br><span class="line">                last_rank = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(best_rank[stu[j].id] &gt; last_rank) &#123;</span><br><span class="line">                best_rank[stu[j].id] = last_rank;</span><br><span class="line">                best_rank_type[stu[j].id] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> type[] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span>(is_exist[id]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %c\n"</span>, best_rank[id] + <span class="number">1</span>, type[best_rank_type[id]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N/A\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1010 Radix（二分法）</title>
    <link href="https://joke-lin.top/2020/03/19/2020-03-19-PAT-Advanced-1010/"/>
    <id>https://joke-lin.top/2020/03/19/2020-03-19-PAT-Advanced-1010/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-04-21T09:07:13.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDcyMjU2NjU1MzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536">题目地址<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p><p>Now for any pair of positive integers <em>N</em>1 and <em>N</em>2, your task is to find the radix of one number while that of the other is given.</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N1 N2 tag radix</span><br></pre></td></tr></table></figure><p>Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p><h3 id="output-specification">Output Specification:</h3><p>For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p><h3 id="sample-input-1">Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure><h3 id="sample-output-1">Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="sample-input-2">Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure><h3 id="sample-output-2">Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><h2 id="基本思路">基本思路</h2><p>PAT题目都很迷，很多地方都不说清楚输入范围。。。</p><p>这道题输入数据不会超过<code>long long</code>，所以可以放心的使用基本思路计算不同进制下的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每次都从进制2开始递增进制，直到一种不可能的情况出现，但这种方法对大小差距极大的两个数特别耗时，对于这种<strong>在一个序列中寻找一个正确解</strong>的过程，显然是用二分法解决。</p><p>但是二分法需要一个范围，那么这道题的进制范围是在哪一个范围。首先对于R进制的串，对于数串内的数必须小于R，所以获取此串的最小进制（下界）就显而易见了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">'0'</span> &amp;&amp; tar &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以使用C++的max_element函数</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">max</span>(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上界即为<code>max(minRadix,  num)</code> num为已知进制的数的值，因为题目中只涉及到0-35的值，所以num作为上届已经足够，因为个位是不可能达到num值的最高就是35，那么在2位数字的情况下最小也是10，此时10在num进制下就是num，所以num进制的最小值就是num，在往上就会大于num就没有必要了</p><p>所有在上下界进行二分法查找即可</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">'0'</span> &amp;&amp; tar &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">max</span>(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">if</span>(tag == <span class="number">2</span>) &#123;</span><br><span class="line">        swap(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// B 是 要计算的</span></span><br><span class="line">    ll tar = getRes(A, radix);</span><br><span class="line">    <span class="comment">//  二分</span></span><br><span class="line">    ll left = getMinRadix(B);</span><br><span class="line">    ll right = <span class="built_in">max</span>(left, tar);</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        ll mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll temp = getRes(B, mid);</span><br><span class="line">        <span class="keyword">if</span>(temp == tar) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, mid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; <span class="number">0</span> || temp &gt; tar) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="二分" scheme="https://joke-lin.top/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib 图像直接导出为 ndarray</title>
    <link href="https://joke-lin.top/2020/03/12/2020-03-12-Matplotlib-DirectlyOutput-Img/"/>
    <id>https://joke-lin.top/2020/03/12/2020-03-12-Matplotlib-DirectlyOutput-Img/</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2020-03-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导出为ndarray格式图片">导出为ndarray格式图片</h2><p><em>matplotlib</em> 绘制的图线有自己的显示窗口，有时候希望在其他的<em>UI</em>设计中使用其绘制的图，比如<em>PyQt</em>，官方有一个支持QT的显示窗口类，但配置很麻烦，在这里记录一种简便的导出方式</p><p>主要思路为使用<em>matplotlib</em>的<code>print_png</code>函数将其图片数据导出到二进制流中，然后<em>numpy</em>从此二进制流中取出数据即可</p><a id="more"></a><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># matplotlib 绘制区</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">1.2</span>, <span class="number">2.5</span>, <span class="number">4.5</span>, <span class="number">7.3</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure(<span class="string">"Image"</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">canvas = fig.canvas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取二进制流</span></span><br><span class="line">buffer = io.BytesIO()</span><br><span class="line">canvas.print_png(buffer)</span><br><span class="line">data = buffer.getvalue()</span><br><span class="line">buffer.write(data)</span><br><span class="line">buffer.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 获取数据</span></span><br><span class="line">file_bytes = np.asarray(bytearray(buffer.read()), dtype=np.uint8)</span><br><span class="line"><span class="comment"># opencv 读取</span></span><br><span class="line">img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">buffer.close()</span><br></pre></td></tr></table></figure><h2 id="设置matplotlib-borders便于鼠标信息处理坐标">设置matplotlib borders便于鼠标信息处理（坐标）</h2><p>有时候仅导出为图片还不够，还需要实现用户的交互操作，在原生<em>matplotlib</em>中可以绑定事件以实现用户交互，但导出为图片时，就不得行了，但只需要获取坐标和图片宽高之间的关系，就可以简单的坐标转换一下就可以实现了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置显示的图像（不包括坐标轴，仅绘图区）显示在figure的位置</span></span><br><span class="line">left, bottom, right, top = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0</span>,<span class="number">9</span></span><br><span class="line">plt.subplots_adjust(left=left, bottom=bottom, right=right, top=top)</span><br></pre></td></tr></table></figure><h3 id="坐标转换">坐标转换</h3><p>因为知道绘图区在整个图的相对位置，所以可以很好的处理</p><p>下面例子为<em>PyQt5</em>使用<em>widget</em>显示图片，<em>widget</em>到曲线坐标系的转换（曲线坐标系x,y均在[0,1]之间）</p><p><strong>即左上角为原点的屏幕坐标系到[0,1]坐标范围的图表坐标系的转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w, h = width(), height() <span class="comment"># 即为显示图片的容器大小</span></span><br><span class="line">plot_w, plot_h = (right - left)*w, (top - bottom)*h <span class="comment"># 绘图区大小</span></span><br><span class="line"><span class="comment"># 图标坐标到全图的像素坐标转换</span></span><br><span class="line">coord2bk = <span class="keyword">lambda</span> coord: [coord[<span class="number">0</span>]*plot_w + w*left, h*(<span class="number">1</span>-bottom) - coord[<span class="number">1</span>]*plot_h]</span><br><span class="line"><span class="comment"># 全图坐标到像素坐标的转换</span></span><br><span class="line">bk2coord = <span class="keyword">lambda</span> coord: [(coord[<span class="number">0</span>] - w*left) / plot_w ,<span class="number">1</span> - (coord[<span class="number">1</span>] - h*(<span class="number">1</span>-top)) / plot_h]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导出为ndarray格式图片&quot;&gt;导出为ndarray格式图片&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;matplotlib&lt;/em&gt; 绘制的图线有自己的显示窗口，有时候希望在其他的&lt;em&gt;UI&lt;/em&gt;设计中使用其绘制的图，比如&lt;em&gt;PyQt&lt;/em&gt;，官方有一个支持QT的显示窗口类，但配置很麻烦，在这里记录一种简便的导出方式&lt;/p&gt;
&lt;p&gt;主要思路为使用&lt;em&gt;matplotlib&lt;/em&gt;的&lt;code&gt;print_png&lt;/code&gt;函数将其图片数据导出到二进制流中，然后&lt;em&gt;numpy&lt;/em&gt;从此二进制流中取出数据即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="ELSE" scheme="https://joke-lin.top/categories/ELSE/"/>
    
    
      <category term="Python" scheme="https://joke-lin.top/tags/Python/"/>
    
      <category term="Matplotlib" scheme="https://joke-lin.top/tags/Matplotlib/"/>
    
      <category term="PyQT" scheme="https://joke-lin.top/tags/PyQT/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络自顶向下 第6版 阅读笔记</title>
    <link href="https://joke-lin.top/2020/03/02/2020-03-02-Compute-Networking-A-Top-Down-Approach-6th/"/>
    <id>https://joke-lin.top/2020/03/02/2020-03-02-Compute-Networking-A-Top-Down-Approach-6th/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-25T10:59:02.506Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Ryb3k5MjIvQ29tcHV0ZXItTmV0d29yay9ibG9iL21hc3Rlci/orqHnrpfmnLrnvZHnu5zoh6rpobblkJHkuIvmlrnms5XnrZTmoYgo6Iux5paH56ys5YWt54mIKS5wZGY=" title="https://github.com/Troy922/Computer-Network/blob/master/计算机网络自顶向下方法答案(英文第六版).pdf">书本配套答案<i class="fa fa-external-link"></i></span></p><blockquote><p>2020-01-07 Joke-Lin</p></blockquote><a id="more"></a><h2 id="chapter-1-计算机网络和因特网">Chapter 1 计算机网络和因特网</h2><h3 id="网络边缘">1. 网络边缘</h3><h4 id="物理媒介">物理媒介</h4><p>分为两类：导引型（guided media），非导引型（unguided media）</p><ul><li>双绞铜线（Twisted-Pair Copper Wire）</li><li>同轴电缆（Coaxial Cable）</li><li>光纤（Fiber Optics）</li><li>陆地无线电信道（Terrestrial Radio Channels）</li><li>卫星无线电信道（Satellite Radio Channel）</li></ul><h3 id="网络核心">*2. 网络核心</h3><blockquote><p>the mesh of packet switches and links that interconnects the Internet’s end systems</p></blockquote><h4 id="i.-packet-switching-分组交换">i. Packet Switching 分组交换</h4><blockquote><p>breaks <strong>long messages</strong> into smaller chunks of data known as <strong>packets</strong>. Between source and destination, each packet travels through <strong>communication links</strong> and <strong>packet switches</strong> (for which there are two predominant types, routers and linklayer switches)</p><p>Packets are transmitted over each communication link at a rate equal to the <strong>full transmission rate of the link.</strong></p></blockquote><h5 id="a.-store-and-forward-transmission-存储转发传输">a. Store-and-Forward Transmission 存储转发传输</h5><p>Store-and-forward transmission means that the packet switch <strong>must receive the entire packet before it can begin to transmit the first bit of the packet</strong> onto the outbound link.</p><p>P个分组经过N条链路，每一个分组大小是L，速率为R</p><p>端到端的时延是：<span class="math inline">\((N+P-1)\frac{L}{R}\)</span></p><h5 id="b.-queuing-delays-and-packet-loss">b. Queuing Delays and Packet Loss</h5><p>Packet Swith have a <strong>output buffer(output queue),</strong> which stores packets that the router is about to send into that link. In addition to the <strong>store-and-forward delays</strong>, packets suffer output buffer <strong>queuing delays</strong>. When the output buffer is full, <strong>packet loss</strong> will occur.</p><h5 id="c.-forwarding-tables-and-routing-protocols">c. Forwarding Tables and Routing Protocols</h5><p>each router has a <strong>forwarding table</strong> （转发表）that maps destination addresses (or portions of the destination addresses) to that router’s outbound links.</p><h4 id="ii.-circuit-switching-电路交换">ii. Circuit Switching 电路交换</h4><blockquote><p>the resources needed along <strong>a path (buffers, link transmission rate) to provide for communication between the end systems are reserved</strong> for the duration of the communication session between the end systems</p><p><strong>end-to-end</strong> connection</p></blockquote><h5 id="multiplexing-in-circuit-switched-networks">Multiplexing in Circuit-Switched Networks</h5><ul><li>frequency-division multiplexing (FDM) 频分复用 ：</li></ul><p>The width of the range of frequency is called, not surprisingly, the <strong>bandwidth</strong>.</p><ul><li><p>time-division multiplexing (TDM) 时分复用:</p><p>circuit switching is <strong>wasteful</strong> because the dedicated circuits are idle during <strong>silent periods</strong>(静默期)</p></li></ul><h4 id="iii.-packet-switching-versus-circuit-switching">iii. Packet Switching Versus Circuit Switching</h4><h5 id="packet-switching">Packet Switching</h5><ul><li>it offers better sharing of transmission capacity</li><li>it is simpler, more efficient, and less costly to implement</li><li>great for bursty data</li><li>but excessive congestion possible</li></ul><h5 id="circuit-switching">Circuit Switching</h5><ul><li>good for real-time serives</li><li>silent periods would cause time waste</li></ul><h4 id="iv.-a-network-of-networks">IV. A Network of Networks</h4><ul><li>ISP: 互联网服务提供商</li><li>IXP： Internet Exchange Point 因特网交换点 保证同级ISP对等（peering）</li><li>content provider networks：内容提供商网络</li></ul><h3 id="delay-loss-and-throughput">3. *Delay, Loss, and Throughput</h3><blockquote><p>in Packet-Switched Networks</p></blockquote><h4 id="types-of-delay">Types Of Delay</h4><ul><li><strong>nodal processing delay</strong>（节点处理时延）:</li></ul><p>The time required to <strong>examine the packet’s header</strong> and <strong>determine where to direct the packet</strong> is part of the processing delay.</p><ul><li><p><strong>Queuing Delay</strong>（排队时延）：</p><p>At the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link.</p></li><li><p><strong>Transmission Delay</strong>（传输时延）：</p><p>Denote the length of the packet by L bits, and denote the transmission rate of the link from router A to router B by R bits/sec. The transmission delay is L/R</p></li><li><p><strong>Propagation Delay</strong>（传播时延）：</p><p>Once a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from the beginning of the link to router B is the propagation delay</p></li></ul><h4 id="queuing-delay-and-packet-loss">Queuing Delay and Packet Loss</h4><ul><li><strong>traffic intensity</strong>（流量强度）： let <em>a</em> denote the <strong>average rate at which packets</strong> arrive at the queue (<em>a</em> is in units of packets/sec)（包到达平均速度）Recall that R is the transmission rate（传输速度）; Also suppose, for simplicity, that all packets consist of L bits. Then the average rate at which bits arrive at the queue is <em>La</em> bits/sec（包到达路由平均速度） The ratio <em>La/R</em>, called the traffic intensity. 保证流量强度&lt;=1才能正常工作</li><li><strong>Packet Loss</strong>（丢包）：With no place to store such a packet, a router will drop that packet; that is, the packet will be lost.</li></ul><h4 id="end-to-end-delay">End-to-End Delay</h4><p>suppose there are <strong>N - 1</strong> routers between the source host and the destination host</p><p>$ d_{end-end} = N(d_{proc}+d_{trans}+d_{prop})$</p><h4 id="throughput-in-computer-networks">Throughput in Computer Networks</h4><ul><li><strong>instantaneous throughput</strong>:at any instant of time is the rate (in bits/sec) at which Host B is receiving the file</li><li><strong>average throughput</strong>: For all file</li><li>the <strong>throughput</strong> depends not only on the transmission rates of the links along the path, but also on the intervening traffic</li></ul><h3 id="protocol-layers-and-their-service-models">4. Protocol Layers and Their Service Models</h3><h4 id="layered-architecture">Layered Architecture</h4><blockquote><p>Protocol layering has conceptual and structural advantages</p><p>the protocols of the various layers are called the <strong>protocol stack</strong></p></blockquote><p>Five-layer Internet protocol stack:</p><ol type="1"><li><p><strong>Application Layer</strong>: HTTP</p><p>The application layer is where <strong>network applications and their application-layer protocols</strong> reside. this packet of information at the application layer as a <strong>message</strong>（报文）.</p></li><li><p><strong>Transport Layer</strong>：TCP UDP</p><p>The Internet’s transport layer transports application-layer messages between application endpoints. Transport-layer packet as a <strong>segment</strong>(报文段).</p><p>TCP guaranteed delivery of application-layer messages to the destination and flow control (that is, sender/receiver speed matching) But UDP not.</p></li><li><p><strong>Network Layer</strong>：IP</p><p>The Internet’s network layer is responsible for moving network-layer packets known as <strong>datagrams</strong> (数据报)from one host to another.</p></li><li><p><strong>Link Layer</strong>:</p><p>To move a packet from one node (host or router) to the next node in the route, the network layer relies on the services of the link layer. The services provided by the link layer depend on the <strong>specific link-layer protocol</strong>(特定链路层协议) that is employed over the link. refer to the linklayer packets as <strong>frames.</strong>（帧）</p></li><li><p><strong>Physical Layer</strong>：</p><p>the job of the physical layer is to <strong>move the individual bits</strong> within the frame from one node to the next.</p></li></ol><p><strong>OSI Model</strong>：</p><blockquote><p>There are application layer, presentation layer, session layer, transport layer, network layer, data link layer, and physical layer from up to down.</p></blockquote><ul><li><strong>presentation layer</strong> is to provide services that allow communicating applications to interpret the meaning of data exchanged. These services include <strong>data compression</strong> and <strong>data encryption</strong> as well as <strong>data description</strong>.</li><li><strong>The session layer</strong> provides for <strong>delimiting and synchronization of data exchange</strong>(数据交换和定界), including the means to build a checkpointing and recovery scheme.</li></ul><h4 id="encapsulation">Encapsulation</h4><p>we see that at each layer, a packet has two types of fields: <strong>header fields</strong>（首部字段） and a <strong>payload field</strong>（有效载荷字段）. The payload is typically a packet from the layer above.</p><p>In every layer, the layer encapsulates the data from last layer as payload field, then add its own header information, to build whole information.</p><h2 id="chapter-2-application-layer">Chapter 2 Application Layer</h2><blockquote><p>2.2 2.5 2.6 are important</p><p>DNS protocol not important</p><p>2.3 2.4-</p></blockquote><h3 id="principles-of-network-applications">1. Principles of Network Applications</h3><h4 id="i.-network-application-architectures">i. Network Application Architectures</h4><blockquote><p>two predominant（主要的） architectural paradigms used in modern network applications: the client-server architecture or the peer-to-peer (P2P) architecture</p></blockquote><ul><li><p><strong>the client-server architecture：</strong></p><p>client and server are separate and fixed, and they perform they own functions</p></li><li><p><strong>P2P architecture:</strong></p><p>Because the peers（对等方） communicate without passing through a dedicated（专用的） server, the architecture is called peer-to-peer. These peers can be server also can be clientz.</p><p>P2P is <strong>self-scalability and cost effective</strong>. And have three <strong>challenges</strong>: ISP Friendly, Security, Incentives（激励）.</p></li></ul><h4 id="ii.-processes-communicating">ii. Processes Communicating</h4><blockquote><p>In truth, server and client are just two process</p></blockquote><p>A process sends messages into, and receives messages from, the network through a software interface called a socket（套接字）. It is also referred to as the Application Programming Interface (API) between the application and the network</p><p>We use <strong>IP address and port number</strong> to do addressing process.</p><h4 id="iii.-transport-services-available-to-applications">iii. Transport Services Available to Applications</h4><ul><li>Reliable Data Transfer</li><li>Throughput</li><li>Timing</li><li>Security</li></ul><h4 id="iv.-transport-services-provided-by-the-internet">IV. Transport Services Provided by the Internet</h4><ul><li><p>TCP Servies</p><p>Connection-oriented service and Reliable data transfer service</p></li><li><p>UDP</p><p>UDP is a no-frills, lightweight transport protocol, providing minimal services. UDP is <strong>connectionless, unreliable</strong>. UDP provides <strong>no guarantee</strong> that the message will ever reach the receiving process. Furthermore, messages that do arrive at the receiving process may arrive <strong>out of order</strong>. And no congestion-control mechanism（拥塞机制）.</p></li></ul><h4 id="v.-services-not-provided-by-internet-transport-protocols">V. Services Not Provided by Internet Transport Protocols</h4><p>But in our brief description of TCP and UDP, conspicuously（明显的） missing was any mention of throughput or timing guarantees—services not provided by today’s Internet transport protocols.</p><h3 id="the-web-and-http">*2. The Web and HTTP</h3><h4 id="i.-overview-of-http">i. Overview of HTTP</h4><p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web’s application-layer protocol, is at the heart of the Web. . Because an HTTP server maintains no information about the clients, HTTP is said to be a <strong>stateless protocol</strong>（无状态协议）. We also remark that the <strong>Web uses the client-server application architecture,</strong></p><h4 id="ii.-non-persistent-and-persistent-connections">ii. Non-Persistent and Persistent Connections</h4><blockquote><p>Attention: 对多并发的例子中，线程之间对其他线程的连接一般是不可见的</p><p>流水线式不一定是绝对好的，本质是提高链路的利用率（充分利用带宽时延积）</p><p>先获取HTML然后在获取其它对象</p><ol type="1"><li>可能会因为头包过大造成链路阻塞</li><li>返回必须按照接收顺序，已处理好的必须等前一个发送后才可以发送</li></ol></blockquote><ul><li><strong>non-persistent connections</strong>: each request/response pair be sent over a separate TCP connection</li><li><strong>persistent connections</strong>: all of the requests and their corresponding responses be sent over the same TCP connection，注意持久化一般是流水线</li></ul><p><strong>round-trip time (RTT 往返时延)</strong>：the time it takes for a small packet to travel from client to server and then back to the client</p><p><strong>the total response time:(总响应时间)</strong> two RTTs plus the transmission time at the server of the HTML file.</p><p>Non-persistent connections have some <strong>shortcomings</strong>.</p><ul><li>a brand-new connection must be established and maintained for each requested object.</li><li>each object suffers a delivery delay of two RTTs</li></ul><h4 id="iii.-http-message-format">iii. HTTP Message Format</h4><ol type="1"><li>HTTP Request Message</li></ol><ul><li>request line（请求行）: first line<ul><li>method field: <strong>GET, POST</strong>, HEAD, PUT, and DELETE</li><li>URL field</li><li>HTTP Version field</li></ul></li><li>header line（首部行）: subsequent line<ul><li>Host : specifies the host on which the object resides</li><li>Connection : whether use persistent connections</li><li>User-agent : specifies the user agent , that is, the browser type. This header line is useful because the server can actually send different versions of the same object to different types of user agents.</li><li>Accept-language: indicates that the user prefers language version</li><li>POST method: has an entity body for post data, but get also can do use work with saving data in URLs.</li></ul></li></ul><ol start="2" type="1"><li>HTTP Request Message</li></ol><ul><li>status line : first line</li></ul><pre><code> version + status code + phrase - 200 OK :  succeeded  - 301 Moved Permanently : Requested object has been permanently moved and new URL will be returned - 400 Bad Request :   the request could not be understood by the server.  - 404 Not Found : The requested document does not exist on this server  -  505 HTTP Version Not Supported : ~~~</code></pre><ul><li><p>header line: subsequent line :</p><ul><li>Connection : tell the client that whether close the TCP connection after sending the message</li><li>Date : <strong>indicates the time and date when the HTTP response was created and sent by the server</strong>. Note that this is not the time when the object was created or last modified; it is the time when the server retrieves the object from its file system, inserts the object into the response message, and sends the response message.</li><li>Server : analogous to the User-agent</li><li>Last-Modified : the time and date when the object was created or last modified</li><li>Content-Length : data size</li><li>Content-Type : data type such as HTML</li></ul></li><li><p>entity body : save data</p></li></ul><h4 id="iv.-user-server-interaction-cookies">iv. User-Server Interaction: Cookies</h4><blockquote><p>cookies allow sites to keep track of users</p></blockquote><p>Cookie has four components:</p><ol type="1"><li>a cookie header line in the HTTP <strong>response</strong> message</li><li>a cookie header line in the HTTP <strong>request</strong> message</li><li>a cookie file kept on the user’s end system and managed by the user’s <strong>browser</strong></li><li>a back-end database at <strong>the Web site</strong></li></ol><p>Although cookies often simplify the Internet shopping experience for the user, they are controversial because they can also be considered as an invasion of privacy</p><h4 id="v.-web-caching">V. Web Caching</h4><blockquote><p>A Web cache—also called a proxy server（代理服务器）—is a network entity that satisfies HTTP requests on the behalf of an origin Web server</p></blockquote><p>It works like this:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/web_cache_1.png" /></p><p>Note that a cache is <strong><em>both a server and a client</em></strong> at the same time.</p><p>Advantages:</p><ul><li><strong><em>A Web cache can substantially reduce the response time for a client request</em></strong>, particularly if the bottleneck bandwidth between the client and the origin server is much less than the bottleneck bandwidth between the client and the cache （加速）</li><li>Web caches can substantially reduce traffic on an institution’s access link to the Internet. So they does not have to upgrade bandwidth as quickly, thereby reducing costs. （减少通信量降低带宽不耗钱）</li><li>Web caches can substantially reduce Web traffic in the Internet as a whole, thereby improving performance for all applications. （降低网络流量，提高性能）</li></ul><p><strong>Content Distribution Networks (CDNs)</strong> （内容分发网络）: A CDN company installs many geographically distributed caches throughout the Internet, thereby localizing much of the traffic.</p><h4 id="vi.-the-conditional-get">VI. The Conditional GET</h4><blockquote><ul><li>the request message uses the GET method</li><li>the request message includes an <strong>If-ModifiedSince</strong>: header line</li></ul></blockquote><p>Use the conditional get to guarantee the file in proxy server is up to date.</p><h3 id="dnsthe-internets-directory-service">5. DNS—The Internet’s Directory Service</h3><blockquote><p>domain name system: a directory service that translates hostnames to IP addresses 53端口</p></blockquote><p>Definition:</p><ol type="1"><li>a distributed database implemented in a hierarchy of DNS servers</li><li>an application-layer protocol that allows hosts to query the distributed database</li></ol><h4 id="i.-services-provided-by-dns">i. Services Provided by DNS</h4><ul><li>Host aliasing</li><li>Mail server aliasing</li><li>Load distribution（负载分配）（一个域名对应多个服务器IP）</li></ul><h4 id="ii.-overview-of-how-dns-works">ii. Overview of How DNS Works</h4><ul><li>centralized design: A simple design for DNS would have one DNS server that contains all the mappings<ul><li>A single point of failure</li><li>Traffic volume</li><li>Distant centralized database</li><li>Maintenance</li></ul></li><li>distributed hierarchical design: uses a large number of servers, organized in a hierarchical fashion and distributed around the world<ul><li>root DNS servers : In the Internet there are 13 root DNS servers</li><li>top-level domain (TLD) servers</li><li>authoritative DNS servers（权威域名服务器）: Every organization with publicly accessible hosts (such as Web servers and mail servers) on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses</li><li>local DNS server : A local DNS server does not strictly belong to the hierarchy of servers but is nevertheless central to the DNS architecture; When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy.<ul><li>recursive：如果全部采用这种方式会给更服务器极大的压力</li><li>iterative</li></ul></li></ul></li></ul><h4 id="iv.-dns-records-and-messages">iv. DNS Records and Messages</h4><p>resource records (RRs): provide hostname-to-IP address mappings</p><p><strong>format : (Name, Value, Type, TTL)</strong></p><ul><li>Type = A : Name is a hostname and Value is the IP address for the hostname.</li><li>Type = NS : Name is a domain (such as foo.com) and Value is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain</li><li>Type = CNAME : Value is a canonical hostname for the alias hostname Name</li><li>Type = MX : Value is the canonical name of a mail server that has an alias hostname Name</li></ul><h3 id="电子邮件">电子邮件</h3><p>3个组成部分：用户代理，邮件服务器，SMTP</p><h4 id="smtp保存状态">SMTP(保存状态)</h4><p>25 号端口，简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。</p><h4 id="pop3">POP3</h4><p>Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议</p><h4 id="imap保存状态">IMAP（保存状态）</h4><p>Internet Mail Access Protocol，即交互式邮件存取协议</p><p>开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上</p><h3 id="ftp保存状态">FTP（保存状态）</h3><p>两个TCP连接，一个控制连接，一个控制数据连接（20，21端口）</p><h2 id="chapter-3-transport-layer">Chapter 3 Transport Layer</h2><blockquote><p>A transport-layer protocol provides for <strong>logical communication</strong> between application <strong><em>processes</em></strong> running on different hosts.</p><p>3.6 不做要求</p></blockquote><p>###　3.1 Introduction and Transport-Layer Services</p><h4 id="relationship-between-transport-and-network-layers">Relationship Between Transport and Network Layers</h4><p>transport layer lies just above the network layer in the protocol stack. Whereas a transport-layer protocol provides logical communication between <strong><em>processes</em></strong> running on different hosts, a network-layer protocol provides logical communication between <em>hosts</em>.</p><h4 id="overview-of-the-transport-layer-in-the-internet">Overview of the Transport Layer in the Internet</h4><ul><li><p>IP service model —— <strong>best-effort delivery service</strong></p><p>IP makes its “best effort” to deliver segments between communicating hosts, but it makes no guarantees. So IP is unreliable service.</p></li><li><p>multiplexing &amp; demultiplexing</p><p>Extending <strong>host-to-host</strong> delivery to <strong>process-to-process</strong> delivery</p></li><li><p>TCP</p><p><strong>reliable data transfer and provides congestion control</strong>. TCP congestion control prevents any one TCP connection from swamping the links and routers between communicating hosts with an excessive amount of traffic.</p></li></ul><h3 id="multiplexing-and-demultiplexing">3.2 Multiplexing and Demultiplexing</h3><p>a process can have one or more <strong><em>sockets</em></strong>, doors through which data passes from <strong>the network to the process</strong> and through which data passes from the process to the network.</p><ul><li><p>demultiplexing: delivering the data in a transport-layer segment to the correct socket</p></li><li><p>multiplexing:</p><p>gathering data chunks at the source host from <strong>different sockets</strong>, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer</p></li></ul><p>Socket:</p><ol type="1"><li>unique identifiers to identify UDP, TCP sockets</li><li>the <strong>source port number field</strong> and the <strong>destination port number field</strong></li></ol><p>the port number ranges from 0 to 65535 (16 bits to express), [0, 1024) is well-known port numbers</p><h4 id="connectionless-multiplexing-and-demultiplexing">Connectionless Multiplexing and Demultiplexing</h4><p>可能是因为UDP是无连接，而TCP是有连接的协议的区分</p><p>UDP socket is fully identified by a <strong>two-tuple</strong> consisting of a <strong>destination IP address and a destination port number</strong>.</p><h4 id="connection-oriented-multiplexing-and-demultiplexing">Connection-Oriented Multiplexing and Demultiplexing</h4><p>identified by four values:</p><ol type="1"><li>the source port number in the segment</li><li>the IP address of the source host</li><li>the destination port number in the segment</li><li>its own IP address</li></ol><p>当一个UDP服务器接收到一个UDP报文段时，它会根据收到的UDP报文段的源IP和源端口号，把数据发送回客户端，它并不需要创建一个新的套接字来处理该报文段；</p><p>而对于一个TCP服务器，当它接受一个连接时，它会产生一个新的套接字，然后通过新的套接字来与客户端通信，也就是通过新的套接字来把数据发送回给客户端。由于每一个连接都会产生一个新的套接字，所以具有不同的源IP或源端口号的连接就是一个不同的连接，对应着产生的新的不同的套接字 原文链接：https://blog.csdn.net/ljianhui/article/details/21660629</p><h3 id="connectionless-transport-udp">3.3 Connectionless Transport: UDP</h3><ul><li><p><em>No connection state.</em> TCP maintains connection state in the end systems.</p></li><li><em>Small packet header overhead.</em> The TCP segment has 20 bytes of header over head in every segment, whereas UDP has only 8 bytes of overhead.</li><li><p>we mention that it is possible for an application to have reliable data transfer when using UDP. This can be done if reliability is built into the application itself</p></li></ul><h4 id="udp-segment-structure">UDP Segment Structure</h4><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_7.png" style="zoom:50%;" /></p><h4 id="udp-checksum">UDP Checksum</h4><p>UDP at the sender side performs the 1s complement of the sum of all the 16-bit words in the segment, with any overflow encountered during the sum being wrapped around(<strong>add the overflow bits with the sum</strong>)</p><h3 id="principles-of-reliable-data-transfer">3.4 Principles of Reliable Data Transfer</h3><h4 id="building-a-reliable-data-transfer-protocol">Building a Reliable Data Transfer Protocol</h4><ol type="1"><li><p><strong>rdt1.0</strong></p><p>the underlying channel is completely reliable</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_9.png" style="zoom:50%;" /></p></li><li><p><strong>rdt2.0</strong>: Reliable Data Transfer over a Channel with Bit Errors</p></li></ol><p>an ARQ (Automatic Repeat reQuest) protocols</p><p>include RDT2.0-3, gbn, sr, tcp</p><ul><li><p>checksum</p></li><li><p>feedback (ACK,NAK)</p></li><li><p>resend</p></li></ul><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_10.png" style="zoom:50%;" /></p><ol start="3" type="1"><li><p><strong>rdt2.1</strong>: can detect ACK or NAK errors based on 2.0</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_11.png" style="zoom:50%;" /> <img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_12.png" style="zoom:50%;" /></p></li><li><p><strong>rdt2.2</strong>: implement without NAK based on 2.1</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_13.png" style="zoom:50%;" /> <img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_14.png" style="zoom:50%;" /></p></li><li><p><strong>rdt3.0</strong>: Reliable Data Transfer over a Lossy Channel with Bit Errors</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_15.png" style="zoom:50%;" /></p></li></ol><h4 id="pipelined-reliable-data-transfer-protocols">Pipelined Reliable Data Transfer Protocols</h4><ol type="1"><li><p>Stop&amp;Wait: rdt</p></li><li><p>PipeLine: gbn, sr, tcp in order.</p></li></ol><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_19.png" style="zoom:50%;" /></p><p>Example:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_22.png" style="zoom:50%;" /></p><p>The window size will move as long as getting the ACK.</p><p><strong>only a single timer</strong>, which can be thought of as a timer for the oldest transmitted but not yet acknowledged packet. If an ACK is received but there are still additional transmitted but not yet acknowledged packets, the timer is restarted. If there are no outstanding, unacknowledged packets, the timer is stopped.</p><ul><li><p><strong>Selective Repeat (SR)</strong></p><p>sequence-number space format:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_23.png" style="zoom:50%;" /></p><p>Actions in sender:</p><ol type="1"><li>Data received from above</li><li>Timeout: <strong>each packet must now have its own logical timer</strong>, since only a single packet will be transmitted on timeout</li><li>ACK received: <strong>the windows will move right to the unacknowledged packet with the smallest sequence number</strong> when received the most left ACK</li></ol><p>The SR receiver will acknowledge a correctly received packet whether or not it is in order. Out-of-order packets are buffered until any missing packets (that is, packets with lower sequence numbers) are received, at which point a batch of packets can be delivered in order to the upper layer.</p><p>Actions in receiver:</p><ol type="1"><li>Packet with sequence number in [rcv_base, rcv_base+N-1] is correctly received. In this case, the received packet falls within the receiver’s window and a selective ACK packet is returned to the sender. If the packet was not previously received, it is buffered. If this packet has a sequence number <strong>equal to the base of the receive window (rcv_base in Figure 3.22), then this packet, and any previously buffered and consecutively numbered (beginning with rcv_base)</strong> packets are delivered to the upper layer. The receive window is then moved forward by the number of packets delivered to the upper layer.</li><li>Packet with sequence number in [rcv_base-N, rcv_base-1] is correctly received. return an ACK</li></ol><p><strong>SR’s problem</strong>: can’t know <strong><em>a new packet or a retransmission?</em></strong></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_27.png" style="zoom:70%;" /></p><p>The solution of this problem: <strong><em>the window size must be less than or equal to half the</em></strong> <strong><em>size of the sequence number space for SR protocols.</em></strong></p></li></ul><p><strong>Summary:</strong></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/T3_1.png" style="zoom:70%;" /></p><h3 id="connection-oriented-transport-tcp">3.5 Connection-Oriented Transport: TCP</h3><p>GBN-SR 窗口不变, TCP 窗口可以变</p><h4 id="the-tcp-connection">The TCP Connection</h4><ul><li>connection-oriented</li><li>full-duplex service（全双工）</li><li>point-to-point</li><li>three-way handshake</li><li><strong>maximum segment size (MSS):</strong> The maximum amount of data that can be grabbed and placed in a segment</li><li><strong>maximum transmission unit (MTU):</strong> the length of the largest link-layer frame that can be sent by the local sending host</li></ul><h4 id="tcp-segment-structure">TCP Segment Structure</h4><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_29.png" style="zoom:50%;" /></p><ul><li><strong>Sequence Numbers(SEQ)</strong>: the byte-stream number of the first byte in the segment</li><li><strong>Acknowledgment Numbers(ACK)</strong>: Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B（想要的下一个序号）TCP is said to provide <strong>cumulative acknowledgments</strong></li></ul><p>Example：</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_31.png" style="zoom:50%;" /></p><h4 id="round-trip-time-estimation-and-timeout">Round-Trip Time Estimation and Timeout</h4><p>The sample RTT, denoted SampleRTT, for a segment is the amount of time between when the segment is sent (that is, passed to IP) and when an acknowledgment for the segment is received.</p><p>TCP never computes a SampleRTT for a segment that has been retransmitted; it only measures SampleRTT for segments that have been transmitted once.</p><ul><li>use <strong>exponential weighted moving average (EWMA)</strong> to estimate RTT</li></ul><p><span class="math inline">\(EstimatedRTT = (1 – \alpha) • EstimatedRTT + \alpha • SampleRTT\)</span></p><ul><li>In addition to having an estimate of the RTT, it is also valuable to have a measure of the variability of the RTT.</li></ul><p>$ DevRTT = (1 – ) • DevRTT + •┃ SampleRTT – EstimatedRTT ┃$</p><ul><li>use this formula the get RTT time</li></ul><p>$ TimeoutInterval = EstimatedRTT + 4 • DevRTT$</p><h4 id="reliable-data-transfer">Reliable Data Transfer</h4><ul><li><strong>Doubling the Timeout Interval</strong></li><li><strong>Fast Retransmit</strong>:In the case that three duplicate ACKs are received (except the first ACK)</li></ul><h4 id="flow-control">Flow Control</h4><p>TCP流控是因为应用层处理速度太慢了, 发送者和接收者的协调,拥塞是路由器和发送者</p><p>eliminate the possibility of the sender overflowing the receiver’s buffer. Flow control is thus a speed-matching service—matching the rate at which the sender is sending against the rate at which the receiving application is reading</p><p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制</p><p>A通过TCP连接向B发送一个大文件</p><ul><li>LastByteRead: 主机B上的应用程序进程从缓存独出的数据流的最后一个字节的编号</li><li>LastByteRevd: 网络到达已放入接收缓存的最后一个字节编号</li></ul><p>保持下式成立</p><p>$ LastByteRcvd-LastByteRead RevBuffer $</p><p>接收窗口用rwnd表示，可得 <span class="math inline">\(rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]\)</span></p><p>在发送方有 <span class="math inline">\(LastByteSent-LastByteAcked \le rwnd\)</span></p><p><strong>当主机B接收窗口为空时，主机A继续发送只有一个字节数据的报文段，避免A被阻塞的情况</strong></p><h4 id="tcp-connection-management">TCP Connection Management</h4><p>MSS在传输SYN时传输确定, TCP可以将包合并发就合并发, SYN 包要独占一个序列号 SYN：1.同步网络参数 2.同步序列号 FIN：表示不发了，但可以接收</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_39.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_40.png" style="zoom:50%;" /></p><h3 id="tcp-congestion-control">3.7 TCP Congestion Control</h3><p><strong>each side of a TCP connection</strong> consists of a <strong>receive buffer, a send buffer, and several variables</strong> (LastByteRead, rwnd, and so on). The TCP congestion-control mechanism operating at the sender keeps track of an additional variable, the congestion window. <strong>The congestion window</strong>, denoted cwnd, imposes a constraint on the rate at which a TCP sender can send traffic into the network.</p><p>TCP uses acknowledgments to trigger (or clock) its increase in congestion window size, TCP is said to be <strong>self-clocking</strong>.</p><p><strong>书本中的TCP标准遵循单一重传定时器的推荐</strong></p><p><strong>FSM</strong>：</p><p>对快速重传的快速恢复的cwnd有减半加三（考虑重传时没有拥塞）和不加三两种操作，这里采用不加三</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_52.png" style="zoom:70%;" /></p><p><strong>TCP congestion-control algorithm</strong>:</p><ol type="1"><li><p>Slow Start</p><p><strong>begin with 1 MSS</strong> then <strong>doubling</strong> of the last sending rate every RTT until meets ssthresh or a loss, then enter congestion avoidance</p></li><li><p>congestion avoidance</p><p><strong>linear increase</strong> (of 1 MSS per RTT) until meet a loss, then <strong>set the ssthresh to half</strong> and enter fast recovery</p></li><li><p>fast recovery</p><p>两个版本在超时后都置为1, 丢包（快速重传）处理不一样</p><ul><li>Tahoe: set cwnd to 1 MSS</li><li>Reno: set the rate to the half of the last rate (real fast recovery)</li></ul></li></ol><p>Example:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_53.png" /></p><p>TCP is <strong>fair</strong></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/3_56.png" style="zoom:50%;" /></p><p>these two connection will infinitely approach <em>the equal bandwidth share line</em>.</p><h2 id="chapter-4-the-network-layer">Chapter 4 The Network Layer</h2><h3 id="introduction">4.1 Introduction</h3><ul><li><strong>Forwarding（转发）</strong>: When a packet arrives at a router’s input link, the router must move the packet to the appropriate output link</li><li><strong>Routing</strong>: The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as routing algorithms</li></ul><p>Every router has a <strong>forwarding table</strong>.</p><p>ATM services models:</p><ul><li>CBR: <strong>Constant bit rate (CBR) ATM network service.</strong></li><li>ABR: <strong>Available bit rate (ABR) ATM network service</strong></li></ul><h3 id="virtual-circuit-and-datagram-networks">4.2 Virtual Circuit and Datagram Networks</h3><h4 id="virtual-circuit-networks">Virtual-Circuit Networks</h4><p>consists of:</p><ul><li>a <strong>path</strong> (that is, a series of links and routers) between the source and destination hosts</li><li><strong>VC numbers</strong>, one number for each link along the path</li><li>entries in the <strong>forwarding table</strong> in each router along the path</li></ul><p>Whenever a new VC is established across a router, an entry is added to the forwarding table. Similarly, whenever a VC terminates, the appropriate entries in each table along its path are removed.</p><p><strong>three identifiable phases in a virtual circuit</strong>:</p><ol type="1"><li>VC setup</li><li>Data transfer</li><li>VC teardown</li></ol><h4 id="datagram-networks">Datagram Networks</h4><p>the router uses <strong><em>the longest prefix matching rule</em></strong> in datagram networks.</p><p>Because forwarding tables in datagram networks <strong>can be modified at any time</strong>, a series of packets sent from one end system to another may follow different paths through the network and may arrive <strong>out of order</strong>.</p><h3 id="whats-inside-a-router">4.3 What’s Inside a Router?</h3><h4 id="architecture">Architecture</h4><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_6.png" style="zoom:50%;" /></p><h4 id="switching">Switching</h4><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_8.png" style="zoom:50%;" /></p><h4 id="where-does-queueing-occur">Where Does Queueing Occur?</h4><p>the router’s memory can eventually be exhausted and packet loss will occur when no memory is available to store arriving packets.</p><p><strong>packet scheduler（分组调度）</strong>:</p><p><strong>active queue management（AQM 主动队列管理）</strong></p><ul><li>drop-tail（弃尾）</li><li>Random Early Detection (RED随机早期检测)</li></ul><p><strong>head-of-the-line (HOL) blocking（线路前部阻塞）</strong>: 前一个分组和其他的输入端口竞争，阻塞了后面没有冲突的分组的发送</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_11.png" style="zoom:50%;" /></p><h4 id="the-routing-control-plane">The Routing Control Plane</h4><p>software pass....</p><h3 id="ip">4.4 IP</h3><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_12.png" style="zoom:60%;" /></p><h4 id="datagram-format">Datagram Format</h4><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_13.png" style="zoom:50%;" /></p><p>此处校验和计算方法和UDP处出现的校验和计算方法一致</p><p><strong>IP Datagram Fragmentation</strong></p><p>datagram: 4000 bytes</p><p>MTU: 1500 bytes</p><p>IP header: 20 bytes</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/T4_2.png" style="zoom:50%;" /></p><h4 id="ipv4-addressing">IPv4 Addressing</h4><p>The boundary between the host and the physical link is called an <strong>interface</strong>.</p><p>To determine the subnets, detach each interface from its host or router, creating islands of isolated networks, with interfaces terminating the end points of the isolated networks. Each of these isolated networks is called a subnet. 没有穿越路由器属于一个子网</p><p>子网可用IP地址需要减2，一个是主机位全0的子网地址和主机位全1的子网广播地址</p><p>子网本身IP地址：前缀+全零</p><p>子网本身IP地址：前缀+全1(直接广播地址)（对目标子网广播）</p><p>255.255.255.255 子网广播地址（受限广播地址）（广播本子网）</p><p>0.0.0.0 网卡本身地址</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_17.png" style="zoom:50%;" /></p><ul><li><p><strong>Classless Interdomain Routing (CIDR 无类别区域间路由选择)</strong></p><p>a.b.c.d/x ; use prefix can reduce the size of the forwarding table</p></li><li><p><strong>classful addressing 分类编址</strong></p><p>A：8 bits ；B：16 bits；C：24bits</p></li></ul><h4 id="dhcp-the-dynamic-host-configuration-protocol">DHCP: the Dynamic Host Configuration Protocol</h4><p>a <strong>plug-and-play protocol</strong>(即插即用协议)</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_21.png" style="zoom:50%;" /></p><p>因为可能存在多个DHCP服务器所以需要二次确认，客户端选择一个IP并告知（一般都是第一个）</p><h4 id="network-address-translation-nat">Network Address Translation (NAT)</h4><p>use a <strong>NAT translation table</strong> at the NAT router, and to include port numbers as well as IP addresses in the table entries</p><p>NAT interferes with P2P applications.</p><p>可以采用第三方来通信 （Skype）</p><p><strong>NAT traversal</strong>（NAT穿越）克服两台主机同属于不同NAT之后的通信，使用UPnP(Universal Plug and Play)协议</p><h4 id="internet-control-message-protocol-icmp">Internet Control Message Protocol (ICMP)</h4><p>The most typical use of ICMP is for error reporting</p><p>使用IP协议的网络层协议</p><h4 id="ipv6">IPv6</h4><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_24.png" style="zoom:50%;" /></p><ul><li>Next hdr:交付到哪一个协议（TCP/UDP）和v4的协议字段相同</li><li>IPv6不允许在路由器上分片和组装</li><li>IPv6没有选项字段，使得其为定长40字节</li><li>首部校验和消失，完全交付给上层协议处理</li><li>payload length: 数据长度</li></ul><p><strong>Transitioning from IPv4 to IPv6</strong></p><ul><li><p><strong>dual-stack</strong>：使用既可以处理v4也可以处理v6的路由器，但可能丢失流标签（或者其他v6特有标签）</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_25.png" style="zoom:50%;" /></p></li><li><p><strong>tunneling</strong>（建隧道）：将v6整体作为v4的数据段传递</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_26.png" style="zoom:50%;" /></p></li></ul><h3 id="routing-algorithms">4.5 Routing Algorithms</h3><p>classification</p><ol type="1"><li><strong>global routing algorithm(LS)</strong> &amp; <strong>decentralized routing algorithm(DV)</strong></li><li><strong>static routing algorithms</strong> &amp; <strong>Dynamic routing algorithms</strong></li><li><strong>load-sensitive algorithm</strong> &amp; <strong>load-insensitive(RIP, OSPF, BGP)</strong></li></ol><h4 id="link-state-algorithm-ls">Link-State Algorithm (LS)</h4><ul><li>D(v): cost of the least-cost path from the source node to destination v as of this iteration of the algorithm.</li><li>p(v): previous node (neighbor of v) along the current least-cost path from the source to v.</li><li>N' : subset of nodes; v is in N’ if the least-cost path from the source to v is definitively known.</li></ul><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/LS.png" style="zoom:50%;" /></p><p>Example:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/T4_3.png" style="zoom:50%;" /></p><p>Then we can get the forward table of u:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_28.png" style="zoom:50%;" /></p><p>oscillations occur in any algorithm, not just an LS algorithm, that uses a congestion or delay-based link metric</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_29.png" style="zoom:60%;" /></p><p>One way to avoid such self synchronization is for each router to randomize the time it sends out a link advertisement.</p><h4 id="the-distance-vector-dv-routing-algorithm">The Distance-Vector (DV) Routing Algorithm</h4><ul><li>For each neighbor v, the cost <strong><em>c(x,v)</em></strong> from x to directly attached neighbor,</li><li>Node x’s distance vector, that is, <strong>Dx</strong> = [Dx (y): y in N], containing x’s estimate of its cost to all destinations, y, in N</li><li>The distance vectors of each of its neighbors, that is, <strong>Dv</strong> = [Dv (y): y in N] for each neighbor v of x</li></ul><p>use this formula to update forwarding table:</p><p>$D_x(y)=min_v{c(x,v)+D_v(y) } $</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/DV.png" style="zoom:50%;" /></p><p>Examlpe:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_30.png" style="zoom:65%;" /></p><h4 id="distance-vector-algorithm-adding-poisoned-reverse">Distance-Vector Algorithm: Adding Poisoned Reverse</h4><p>好消息: 链路开销减小, 迭代次数少便收敛</p><p>坏消息 链路开销增加, 可能陷入无穷迭代（原因在于消息的虚假，增加的这条链路被其他节点引用但无法更新）</p><p>https://blog.csdn.net/tianlongtc/article/details/80261581</p><p>毒性逆转：The idea is simple—if z routes through y to get to destination x, then z will advertise to y that its distance to x is infinity</p><h4 id="a-comparison-of-ls-and-dv-routing-algorithms">A Comparison of LS and DV Routing Algorithms</h4><ul><li>Message complexity：</li><li>Speed of convergence（收敛速度）：DV收敛慢，可能遇到环路和无穷计数，LS较快</li><li>Robustness（健壮性）：LS更健壮，路由器故障时，DV会无穷欺骗</li></ul><h4 id="hierarchical-routing">Hierarchical Routing</h4><ul><li><p><strong>autonomous systems (ASs)</strong>: consisting of a group of routers that are typically under the same administrative control</p></li><li><p><strong>intra autonomous system routing protocol</strong>: The routing algorithm running within an autonomous system</p></li><li><strong>gateway routers</strong>: forwarding packets to destinations outside the AS</li><li><strong>inter-AS routing protocol</strong>: obtaining reachability information from neighboring ASs and propagating the reachability information to all routers internal to the AS</li><li><p><strong>hot-potato routing</strong>: 如果有两个网关都可以通向到另外一个AS那么简单的选择最近的那一个就可以</p></li></ul><h3 id="routing-in-the-internet">4.6 Routing in the Internet</h3><p><strong>intra autonomous system routing protocol</strong> also named <strong>interior gateway protocols</strong></p><ol type="1"><li>Routing Information Protocol (RIP) DV(下层ISP或企业)</li><li>Open Shortest Path First (OSPF) LS (上层ISP)</li></ol><h4 id="intra-as-routing-in-the-internet-rip">Intra-AS Routing in the Internet: RIP</h4><p><strong>hop</strong>: the number of subnets traversed along the shortest path from source router to destination subnet, including the destination subnet</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_34.png" style="zoom:50%;" /></p><p>The maximum cost of a path is limited to 15 in RIP.</p><p>In RIP, routing updates are exchanged between neighbors approximately every 30 seconds using a <strong>RIP response message</strong>(RIP advertisements)</p><p>Example:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_35.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_36.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_37.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/4_38.png" style="zoom:50%;" /></p><h4 id="intra-as-routing-in-the-internet-ospf">Intra-AS Routing in the Internet: OSPF</h4><p>OSPF broadcasts routing information to <strong>all</strong> other routers in the autonomous system</p><p>Some of the advances embodied in OSPF：</p><ol type="1"><li><em>Security</em></li><li><em>Multiple same-cost paths</em>（允许使用多条路径发送）</li><li><em>Integrated support for unicast and multicast routing</em></li><li><em>Support for hierarchy within a single routing domain</em></li></ol><p>OSPF可以配置为多个区域，每个区域都有区域边界路由器（<strong>area border routers</strong>）负责向流域以外的分组提供路由选择。AS内只有一个主干区域（backbone），主干的主要作用是为AS内其他区域之间的流量提供路由选择，包括了所有区域边界路由器和一些非边界路由器。在AS内区域间的路由选择要求分组首先路由到一个区域边界路由去，然后听过主干路由到位于母的区域的边界路由器</p><h4 id="inter-as-routing-bgpborder-gateway-protocol">Inter-AS Routing: BGP（Border Gateway Protocol）</h4><p>*<strong>BGP转发的对象是前缀（子网）</strong></p><p>BGP provides each AS a means to</p><ol type="1"><li>Obtain subnet reachability information from neighboring ASs.</li><li>Propagate the reachability information to all routers internal to the AS</li><li>Determine “good” routes to subnets based on the reachability information and on AS policy</li></ol><p>Most importantly, BGP allows each subnet to advertise its existence to the rest of the Internet.</p><ul><li><strong>BGP peers</strong>：TCP连接的两个端点</li><li><strong>BGP session</strong>：发送BGP报文的TCP连接</li><li><strong>external BGP</strong> (<strong>eBGP</strong>) <strong>session</strong>：跨越AS</li><li><strong>internal BGP</strong> (<strong>iBGP</strong>) <strong>session</strong>：内部</li></ul><p>每一个AS都有一个ASN（autonomous system number），但是桩（stub）AS没有，这种AS只承担目的地址为本AS的流量。AS号是ICANN 分配的</p><p>When a router advertises a prefix across a BGP session, it includes with the prefix a number of BGP attributes. In BGP jargon, a prefix along with its attributes is called a route</p><ul><li><em>AS-PATH</em>:包含了前缀的通告已经听过的那些AS</li><li>Providing the critical link between the inter-AS and intra-AS routing protocols, the NEXT-HOP attribute has a subtle but important use. <strong>The NEXT-HOP is the router interface that begins the AS-PATH.</strong></li></ul><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/BGP_routing.png" style="zoom:50%;" /></p><h2 id="chapter-5-the-link-layer-links-access-networks-and-lans">Chapter 5 The Link Layer: Links, Access Networks, and LANs</h2><h3 id="introduction-to-the-link-layer">5.1 Introduction to the Link Layer</h3><ul><li><strong>node</strong>: any device that runs a link-layer protocol</li><li><strong>links:</strong>the communication channels that connect adjacent nodes along the communication path</li><li><strong>link-layer frame</strong>: link-layer data transmission format</li></ul><p>####　The Services Provided by the Link Layer</p><ol type="1"><li><em>Framing</em>(成帧)</li><li><em>Link access</em>(链路接入)</li><li><em>Reliable delivery.</em></li><li><em>Error detection and correction</em></li></ol><h4 id="where-is-the-link-layer-implemented">Where Is the Link Layer Implemented?</h4><p><strong>network adapter</strong> also named <strong>network interface card (NIC)</strong></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_2.png" style="zoom:50%;" /></p><h3 id="error-detection-and--correction-techniques">5.2 Error-Detection and -Correction Techniques</h3><p>use <strong>error-detection and -correction bits(EDC)</strong> to detect and correct error bits</p><p>Even with the use of error-detection bits there still may be <strong>undetected bit errors</strong></p><h4 id="parity-checks">Parity Checks</h4><p>奇偶校验只需要查看加上检验比特(奇偶校验位)的1 是奇数还是偶数</p><p>二维奇偶校验:</p><p>对每一行每一列都进行奇偶校验,然后对列行奇偶校验位进行奇偶校验, 就校验可以检测和纠正单个比特错误,可以检测但是不能纠正两个比特的任意错误组合</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_5.png" style="zoom:50%;" /></p><p>The ability of the receiver to both detect and correct errors is known as <strong>forward error correction (FEC前向纠错)</strong>.</p><h4 id="checksumming-methods">Checksumming Methods</h4><p>和UDP/TCP中的类似</p><h4 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h4><p>also named <strong>polynomial codes</strong>(多项式编码)</p><ol type="1"><li><p>确定多项式 例如 x3+x2+1 = 1101</p></li><li><p>在目标码后加上多项式码长度-1 的0</p></li><li><p>做模2除法(除的过程不是减是异或)</p></li></ol><p>把最后的余数添加到原码的末尾,在接收端使用相同多项式除看余数是否是0</p><h3 id="multiple-access-links-and-protocols">5.3 Multiple Access Links and Protocols</h3><ul><li><strong>point-to-point link</strong>: consists of a single sender at one end of the link and a single receiver at the other end of the link</li><li><strong>broadcast link</strong>: enables a single source node to send a copy of a packet to a subset of the other network nodes</li></ul><ol type="1"><li>channel partitioning protocols 信道划分协议</li><li>random access protocols 随机访问协议</li><li>taking-turns protocols 轮流协议</li></ol><p>a multiple access protocol for a broadcast channel of rate R bits per second should have the following desirable characteristics:</p><ol type="1"><li><p>当仅有一个节点发送数据时,具有R bps的吞吐量</p></li><li><p>当M给节点发送时,每个结点吞吐量为 R/M bps的平均传输速率</p></li><li><p>协议是分散的,不会因为某个主节点故障而使整个系统崩溃</p><p>no special node to coordinate transmissions</p><p>no synchronization of clocks, slots</p></li><li><p>协议是简单的,使实现不昂贵</p></li></ol><h4 id="channel-partitioning-protocols">Channel Partitioning Protocols</h4><ul><li><p>time-division multiplexing (TDM): divides time into time frames and further divides each time frame into N time slots(时隙) 仅有一个节点他的速度任然是R/N的速度</p></li><li><p>frequency-division multiplexing (FDM): 将R bps 信道划分为不同的频段, 具有TDM的缺点</p></li></ul><h4 id="random-access-protocols">Random Access Protocols</h4><ul><li><p><strong>Slotted ALOHA (时隙 ALOHA)</strong>:</p><p>有如下假设:</p><ul><li>All frames consist of exactly L bits.</li><li>Time is divided into slots of size L/R seconds (that is, a slot equals the time to transmit one frame).</li><li>Nodes start to transmit frames only at the beginnings of slots.</li><li>The nodes are synchronized so that each node knows when the slots begin.</li><li>If two or more frames collide in a slot, then all the nodes detect the collision event before the slot ends.</li></ul><p>p 是一个0-1的概率, 有如下操作:</p><ul><li>当节点要发送一个新帧时,需要在下一个时隙开始并在该时隙传输整个帧</li><li>如果没有碰撞则成功传输,不需要考虑重传</li><li>如果有碰撞,该结点在时隙结束之前检测到碰撞,之后以p在之后的每一杠时隙重传,直到成功</li></ul><p>此协议需要时钟同步,但是当只有一个结点时,效率是R</p><p>此协议效率定义为:有大量活跃结点发送大量帧时,长期运行中成功时隙的份额</p><p>在p的概率下 N个结点的效率为<span class="math inline">\(Np(1-p)^{N-1}\)</span> N趋于无穷时有极限1/e = 0.37</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_10.png" style="zoom:50%;" /></p></li><li><p>ALOHA</p><p>时隙ALOHA的无时钟同步版本, 效率降低一半</p></li><li><p>Carrier Sense Multiple Access (CSMA 载波监听多路访问)</p><p>规则:</p><ol type="1"><li><em>Listen before speaking</em>, this is called <strong>carrier sensing</strong></li><li><em>If someone else begins talking at the same time, stop talking</em>, this is called <strong>collision detection</strong></li></ol><p>These two rules are embodied in the family of <strong>carrier sense multiple access(CSMA)</strong> and <strong>CSMA with collision detection (CSMA/CD)</strong> protocols</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_12.png" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_13.png" style="zoom:50%;" /></p><p>CSMA/CD 的运行</p><ol type="1"><li>The adapter obtains a datagram from the network layer, prepares a link-layer frame, and puts the frame adapter buffer.</li><li>If the adapter senses that the channel is idle (that is, there is no signal energy entering the adapter from the channel 即在96比特时间内没有检测到信道上有信号), it starts to transmit the frame. If, on the other hand, the adapter senses that the channel is busy, it waits until it senses no signal energy and then starts to transmit the frame.</li><li>While transmitting, the adapter monitors for the presence of signal energy coming from other adapters using the broadcast channel.</li><li>If the adapter transmits the entire frame without detecting signal energy from other adapters, the adapter is finished with the frame. If, on the other hand, the adapter detects signal energy from other adapters while transmitting, it aborts the transmission (that is, it stops transmitting its frame).</li><li>After aborting, the adapter waits a random amount of time and then returns to step 2.</li></ol><p>选择随机回退时间算法:</p><p><strong>binary exponential backoff(二进制指数后退)</strong>algorithm</p><p>经历n次碰撞之后,结点随机的从<span class="math inline">\(\{0,1,2,...,2^n-1\}\)</span>选择一个值作为回退时间</p></li></ul><h4 id="taking-turns-protocols">Taking-Turns Protocols</h4><p>Recall that two desirable properties of a multiple access protocol are (1) when only one node is active, the active node has a throughput of R bps, and (2) when M nodes are active, then each active node has a throughput of nearly R/M bps. The ALOHA and CSMA protocols have this first property but not the second.</p><ul><li><strong>polling protocol(轮询协议)</strong>: 在一个主结点的控制下轮询各个结点</li><li><strong>token-passing protocol(令牌传递协议)</strong>:结点构成一个环,将令牌传递,有令牌的发送,结束后传递给下一个</li></ul><p>具有单点失效性</p><h3 id="switched-local-area-networks">5.4 Switched Local Area Networks</h3><h4 id="link-layer-addressing-and-arp">Link-Layer Addressing and ARP</h4><ul><li><p><strong>MAC(LAN address, a physical address)</strong>: 48 bits, FF-FF-FF-FF-FF-FF <strong>broadcast address</strong></p></li><li><p><strong>Address Resolution Protocol (ARP)</strong>:</p><p>ARP 维护一个ARP表</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_18.png" style="zoom:50%;" /></p><p>表中没有所需要的项时,就会发送一个ARP分组并向子网广播获取对方的MAC地址,当需要发送到子网以外时,需要先获取网关路由器的MAC地址,然后一步步转发出去</p></li></ul><h4 id="ethernet">Ethernet</h4><ul><li>hub(集线器): 比特级复制数据,可以达到广播的目的</li><li>switch(交换机):存储转发功能,且无碰撞(因为有缓存)</li></ul><p>结构:</p><p><img src="https://raw.githubusercontent.com/Joke-Lin/Notes/master/Compute-Networking-A-Top-Down-Approach-6th/img/5_20.png" style="zoom:50%;" /></p><p>以太网技术提供不可靠服务,接收方会执行CRC校验,失败则丢弃,但不对发送方产生任何的反馈信息</p><h4 id="link-layer-switches">Link-Layer Switches</h4><ul><li><strong>Filtering</strong>: determines whether a frame should be forwarded to some interface or should just be dropped.</li><li><strong>Forwarding</strong>: determines the interfaces to which a frame should be directed, and then moves the frame to those interfaces.</li></ul><p>一个目的MAC通过一个接口x到达交换机有3种情况:</p><ol type="1"><li>没有此目的MAC的表项则广播</li><li>此表项和x已经关联,丢弃</li><li>不等于x的y接口是此目的MAC 则转发</li></ol><p>交换机是自学习的,即插即用,双工设备</p><ol type="1"><li>初始交换机为空</li><li>对每个接口接收到的帧,存储 MAC, 接口, 时间信息</li><li>在老化期(aging time)之后没有收到该地址作为源的帧删除</li></ol><p>交换机的优点:</p><ol type="1"><li><em>Elimination of collisions</em></li><li><em>Heterogeneous links</em>(异质的链路)</li><li><em>Management</em></li></ol><p>交换机和路由器比较:</p><ul><li><p>交换机: 即插即用、高转发过滤速率、没有提供广播风暴保护措施</p></li><li><p>路由器：一般不会死循环（TTL）、广播风暴有有防火墙保护，非即插即用，处理时间长</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Troy922/Computer-Network/blob/master/计算机网络自顶向下方法答案(英文第六版).pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书本配套答案&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2020-01-07 Joke-Lin&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Tutorial &amp; Note" scheme="https://joke-lin.top/categories/Tutorial-Note/"/>
    
      <category term="Computer Network" scheme="https://joke-lin.top/categories/Computer-Network/"/>
    
    
  </entry>
  
</feed>
