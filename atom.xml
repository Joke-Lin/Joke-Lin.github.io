<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joke-Lin | BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joke-lin.top/"/>
  <updated>2020-04-27T14:56:16.511Z</updated>
  <id>https://joke-lin.top/</id>
  
  <author>
    <name>Joke-Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT Advanced 1045 Favorite Color Stripe（动态规划）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-27-PAT-Advanced-1045/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-27-PAT-Advanced-1045/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-27T14:56:16.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0Mzc0MTE0NzU0NTY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805437411475456">题目地址<i class="fa fa-external-link"></i></span></p><p>和最长公共子序列很相似，不同的是这里是求串B中符合串A的数字顺序的最长串的大小（即可重复）。比如：</p><p>给定顺序A为：1、2、3，待匹配串B为：1、1、2、4、3、2</p><p>其中符合条件的串有：</p><ol type="1"><li>1、1、2、2</li><li>1、2、2</li><li>2、3</li><li>...</li></ol><a id="more"></a><h2 id="基本思路">基本思路</h2><p>题目和最长公共子序列几乎是一样的，都是动态规划的思路。既然是动态规划那么就涉及到状态转移方程了。类比最长公共子序列，这里使用<code>dp[i][j]</code>表示A串第i位和B串第j位可以构成满足条件的最长串大小。</p><p>构成的状态转移方程为： <span class="math display">\[dp[i][j] = \begin{cases}dp[i][j-1]&amp; \text{A[i-1]==B[j-1]} \\max(dp[i][j-1], dp[j-1][i]&amp; \text{else}\end{cases}\]</span> 可以看出和最长公共子序列仅仅在A[i-1] == B[j-1]（注意dp是从1开始的，表示第i位）时不一样，由<span class="math inline">\(dp[i-1][j-1] + 1\)</span>变成了<span class="math inline">\(dp[i][j-1]+1\)</span>，就是<strong>因为此题目允许相对顺序的重复</strong>。</p><p>这里还可以进行状态压缩，注意到此时位二维DP数组，观察其状态转移方程，可以将其压缩为一维数组（也叫做滚动数组）</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> nums[maxn];</span><br><span class="line"><span class="keyword">int</span> order[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nums+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] == order[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805437411475456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和最长公共子序列很相似，不同的是这里是求串B中符合串A的数字顺序的最长串的大小（即可重复）。比如：&lt;/p&gt;
&lt;p&gt;给定顺序A为：1、2、3，待匹配串B为：1、1、2、4、3、2&lt;/p&gt;
&lt;p&gt;其中符合条件的串有：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;1、1、2、2&lt;/li&gt;
&lt;li&gt;1、2、2&lt;/li&gt;
&lt;li&gt;2、3&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="动态规划" scheme="https://joke-lin.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1043 Is It a Binary Search Tree（树）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-21-PAT-Advanced-1043/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-21-PAT-Advanced-1043/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:09:44.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDA5NzY2MzM4NTY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856">题目地址<i class="fa fa-external-link"></i></span></p><p>给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印树的后续遍历结果</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>前序遍历：<span class="math inline">\(根节点 \rightarrow 左子树 \rightarrow 右子树\)</span>，对于根结点root，只需要将其之后的结点分为两部分（左小于，右大于等于），分别为左子树和右子树，然后对两部分继续递归分解。递归的结构恰好实现了后序遍历<span class="math inline">\(左子树 \rightarrow 右子树 \rightarrow 根节点\)</span>，只要在递归返回的时候记录当前节点值，就可以了。</p><p>对于非法搜索树的判断，即在切分子树的阶段，从序列的首尾向中心查找，如果存在没有被归入左子树或者右子树的，则为非法搜索树。</p><p>代码如下（参考了<span class="exturl" data-url="aHR0cHM6Ly93d3cubGl1Y2h1by5uZXQvYXJjaGl2ZXMvMjE1Mw==" title="https://www.liuchuo.net/archives/2153">刘婼<i class="fa fa-external-link"></i></span>的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre_order[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> is_mirror = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post_order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免只有一半的树 比如5 4 3，此时的ed是大于st的</span></span><br><span class="line">    <span class="keyword">if</span>(st &gt; ed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = st+<span class="number">1</span>, l = ed;</span><br><span class="line">    <span class="keyword">if</span>(!is_mirror) &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &lt; pre_order[st]) r++; <span class="comment">// 最后的r是大于l的 因为++，真正的位置是循环结束的r-1</span></span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &gt;= pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &gt;= pre_order[st]) r++;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &lt; pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r - l != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刚刚好为后续遍历</span></span><br><span class="line">    getTree(st+<span class="number">1</span>, l);   <span class="comment">//  左边</span></span><br><span class="line">    getTree(r, ed);     <span class="comment">// 右边</span></span><br><span class="line">    post_order.push_back(pre_order[st]);    <span class="comment">// 根结点 此处即为后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, pre_order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        post_order.clear();</span><br><span class="line">        is_mirror = <span class="literal">true</span>;</span><br><span class="line">        getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; post_order.size();i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, post_order[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != post_order.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印树的后续遍历结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1044 Shopping in Mars（二分）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-25-PAT-Advanced-1044/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-25-PAT-Advanced-1044/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-25T14:17:32.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MzkyMDI0NDMyNjQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264">题目地址<i class="fa fa-external-link"></i></span></p><p>简单来说，即给定一串数字序列，以及目标值M，找出一段和为M的子串，若不存在找出大于M的最小子串</p><a id="more"></a><h2 id="简单思路">简单思路</h2><p>这是一道二分法的题目，开始很难看出来，因为二分意味着有序，这里并没有什么有序。唯一可能有序的就是和了，如果让一个数组sums保存从开始到此位置的和，那这个数组就是递增的了，也就可以使用二分法了。</p><p>从位置i开始（左界）寻找符合条件的右界，也就是找前缀和为sums[i-1]+M的下标，这就可以使用二分查找了</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> sums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ed = n, mid, tar = m+sums[st<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(st &lt; ed) &#123;</span><br><span class="line">        mid = (st + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sums[mid] &gt;= tar) &#123;</span><br><span class="line">            ed = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mid);</span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>] + mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min_m = sums[n];</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tar_pos = divide(i);</span><br><span class="line">        <span class="keyword">int</span> temp = sums[tar_pos]-sums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; min_m) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; min_m) &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                min_m = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(&#123;i, tar_pos&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : res) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-%d\n"</span>, v.first, v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说，即给定一串数字序列，以及目标值M，找出一段和为M的子串，若不存在找出大于M的最小子串&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="二分" scheme="https://joke-lin.top/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1040 Longest Symmetric String（动态规划）</title>
    <link href="https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1040/"/>
    <id>https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1040/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:34.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDYxMDIwNzMzNDQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344">题目地址<i class="fa fa-external-link"></i></span></p><p>求最长回文子串的长度</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>这里使用动态规划求解 <span class="math display">\[dp[i][j]=\begin{cases}true &amp; &amp; dp[i-1][j+1] == true \&amp;\&amp; str[i]==str[j] \\false &amp; &amp;\text{else}\end{cases}\]</span> dp[i][j] 表示substr(j, i) 是否是回文串</p><p>这里动态规划遍历的顺序可以有多种，我是以下标为遍历顺序，也可以以回文串长度作为遍历顺序。</p><p>还有一种算法为马拉车算法，实现了复杂度<span class="math inline">\(O(n)\)</span>。可参考<a href="https://joke-lin.top/2018/10/01/2018-10-01-manacher/">最长回文子串算法</a></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    fgets(s, maxn, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i][i<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            res = max(res, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求最长回文子串的长度&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="动态规划" scheme="https://joke-lin.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1038 Recover the Smallest Number （贪心）</title>
    <link href="https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1038/"/>
    <id>https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1038/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:41.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDk2MjUyODg3MDQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704">题目地址<i class="fa fa-external-link"></i></span></p><p>给定一系列数字串，使用他们组成一个最小的数字</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>似乎或者应该有那么点贪心的思路，重载一个排序函数，每次选取保证可以最小整个数字串的值。</p><p>重载<code>string</code>比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较的思路大概就是对于两个串，从开始遍历，优先选择数字小的，如果两个串前缀完全相同比如A：321，B：32，那么就比较，AB和BA的数字大小情况。</p><p>因为无论什么样的顺序，最终的数字位数是确定的，所以确定取那个串作为下一部分，只要选取前缀最小的就可以了。</p><p>注意00000的情况，需要打印一个0</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> num_str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; seq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num_str;</span><br><span class="line">        seq.push_back(num_str);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(seq.begin(), seq.end(), cmp);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : seq) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i[j] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一系列数字串，使用他们组成一个最小的数字&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="贪心" scheme="https://joke-lin.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1033 To Fill or Not to Fill （贪心）</title>
    <link href="https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1033/"/>
    <id>https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1033/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:47.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NTg3MjI3MzQwODA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080">题目地址<i class="fa fa-external-link"></i></span></p><p>给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。</p><a id="more"></a><h2 id="思路">思路</h2><p>思路清楚的话便十分简单了，大体思想就是贪心。贪心策略如下：</p><p>当到达一个加油站的时候，获取其满油状态下可以到达的最远距离，然后<strong>在当前和最远距离之间</strong>选取一个合适的加油站，作为下一次加油的站点。通过下面的方式获取合适站点：</p><ol type="1"><li>如果存在<strong>油价比当前所在加油站价格低</strong>的，则在当前加油站加油到恰好可以到达第一个油价低于它的</li><li>否则直接在当前加油站加满油，然后下一个加油站为满油状态下可到达的最远加油站</li></ol><p>如果到不了下一个油站则直接输出最大可到达距离即可。</p><p>需要特判一下开始位置没有加油站的情况，直接输出最大距离0.00。</p><p>此贪心策略画个图便很容易想到并证明了。如果在当前加油站可开到一个比他油价低的加油站则在低油价站点补充油一定比直接开要开销小。相反如果不能开到油价低的，则说明途径的油站价格都比原油站价格高，则在途中补充不如直接开到最后一个在补充。<strong>此正确性来自，每个加油站最多且保证可加到满油状态。</strong></p><p>注意在考虑的时候，要注意到此油站可能还剩余一些油。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">float</span> tank, dis, avg, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f %f %f %f"</span>, &amp;tank, &amp;dis, &amp;avg, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; &gt; gas_stations;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> v, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f %f"</span>, &amp;v, &amp;d);</span><br><span class="line">        gas_stations.push_back(&#123;d, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    gas_stations.push_back(&#123;dis, <span class="number">0</span>&#125;);   <span class="comment">// 将最后一个站设为免费加油站 便于后面处理</span></span><br><span class="line">    sort(gas_stations.begin(), gas_stations.end()); <span class="comment">// 按距离排序</span></span><br><span class="line">    <span class="comment">// 起始位置没有加油站</span></span><br><span class="line">    <span class="keyword">if</span>(gas_stations[<span class="number">0</span>].first != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> cost = <span class="number">0</span>, last_gas = <span class="number">0</span>;  <span class="comment">// 开销 &amp; 到此加油站剩余油</span></span><br><span class="line">    <span class="keyword">int</span> cur_pos = <span class="number">0</span>, stations_size = gas_stations.size();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> next_dis = gas_stations[cur_pos].first + tank*avg;  <span class="comment">// 在这个站满油情况下的可以开到的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> tar_pos = <span class="number">-1</span>;   <span class="comment">// 获取开销最小的下一个加油站</span></span><br><span class="line">        <span class="comment">// 从这段距离中获取合适的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_pos+<span class="number">1</span>;i &lt; stations_size;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].first &gt; next_dis) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tar_pos = i;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能到达到下一个站</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f"</span>, next_dis);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> gas_need; <span class="comment">// 需要购买的油</span></span><br><span class="line">        <span class="comment">// 有价格更小的站</span></span><br><span class="line">        <span class="keyword">if</span>(gas_stations[tar_pos].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">            gas_need = (gas_stations[tar_pos].first-gas_stations[cur_pos].first)/avg - last_gas;</span><br><span class="line">            last_gas = <span class="number">0</span>;   <span class="comment">// 直接买足够到下一个站的油即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 价格都比它大</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            gas_need = tank - last_gas;   <span class="comment">// 直接加满</span></span><br><span class="line">            last_gas = (next_dis - gas_stations[tar_pos].first)/avg; <span class="comment">// 更新到下一个站的油量</span></span><br><span class="line">        &#125;</span><br><span class="line">        cost += gas_need*gas_stations[cur_pos].second;</span><br><span class="line">        <span class="comment">// 到达目标地</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == stations_size<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_pos = tar_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="贪心" scheme="https://joke-lin.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1032 Sharing（链表）</title>
    <link href="https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1032/"/>
    <id>https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1032/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:53.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NjA2NTIxMTM5MjA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920">题目地址<i class="fa fa-external-link"></i></span></p><p>简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。</p><a id="more"></a><h2 id="思路">思路</h2><p>200ms的限制时间暴力是不可能暴力的，必须是线性时间的算法。</p><p>我的思路比较繁琐，首先获取两个字符串的完整路径，并分别记录他们的前置结点，和结尾结点位置。如果两个结尾不一样则输出-1，否则从末尾开始向前寻找第一个分支即可（两个字符串第一个路径前驱不同的位置）。</p><p>在生成路径的时候注意<strong>不要以是否为-1作为结束判断</strong>，有些字符串可能他只给出一部分，并没有-1结束标志。其次，采取这种思路在寻找前驱分支的时候，注意当两个字符串为同一个的情况（可能会出现）。可以实现将起始点的前驱结点赋值为不同的值，如-1，-2即可。</p><p>网上一种很简便的方法就是遍历字符串1，将遍历到的点记录，然后遍历字符串2，遇到的第一个字符串1中遍历过的，就是公共后缀的开始位置了。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; link;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> st_1, st_2, ed_1, ed_2, n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prev_1, prev_2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;st_1, &amp;st_2, &amp;n);</span><br><span class="line">    <span class="comment">// 防止有两个字符串完全一样的情况。。</span></span><br><span class="line">    prev_1[st_1] = <span class="number">-1</span>;</span><br><span class="line">    prev_2[st_2] = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur, next;</span><br><span class="line">        <span class="keyword">char</span> v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>, &amp;cur, &amp;v, &amp;next);</span><br><span class="line">        link[cur] = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = st_1;</span><br><span class="line">    <span class="comment">// 条件为link[cur].next != -1会TE 可能不会有-1结尾</span></span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_1[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_1 = cur;</span><br><span class="line">    cur = st_2;</span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_2[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_2 = cur;</span><br><span class="line">    <span class="keyword">if</span>(ed_1 != ed_2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev_1[cur] != prev_2[cur]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = prev_1[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1026 Table Tennis （模拟）</title>
    <link href="https://joke-lin.top/2020/04/09/2020-04-09-PAT-Advanced-1026/"/>
    <id>https://joke-lin.top/2020/04/09/2020-04-09-PAT-Advanced-1026/</id>
    <published>2020-04-08T16:00:00.000Z</published>
    <updated>2020-04-21T08:34:59.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NzIzMzMyNTA1NjA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560">题目地址<i class="fa fa-external-link"></i></span></p><p>给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：</p><ul><li>当一个VIP球台空的时候，排队中的第一个VIP可以优先使用</li><li>如果当前没有VIP用户等待，普通用户也可以使用VIP球台</li><li>如果VIP用户没有VIP球台可以使用，就使用普通球台</li></ul><p>存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>其实有很多种处理的方式，我采取的策略为：</p><ol type="1"><li>用户按时间排序，将每个球台开放时间保存为数组</li><li>分别获取球台的最早的普通球台和VIP球台开放时间</li><li>如果是普通先开放，意味着没有VIP球台多余，直接给下一个等待用户即可，另外处理没有任何等待用户的情况</li><li>如果是VIP球台先开放（包含和普通同时开放的情况），查找顾客数组是否有VIP在等待，有的话给此VIP用户，否则给等待的第一个普通用户，如果没有人等待，进入处理无人等待的情况</li><li>无人等待的情况处理：没人等意味着下一个来的可以马上处理，如果来的是VIP查看是否有VIP球台，有给他，没有则给普通，普通用户则直接给空闲的编号最小的球台（此时没VIP等待）</li></ol><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FpeWlzaHVhaS9wLzExMzcyMTUzLmh0bWw=" title="https://www.cnblogs.com/caiyishuai/p/11372153.html">PAT 甲级 1026 Table Tennis (30 分)（坑点很多，逻辑较复杂，做了1天）<i class="fa fa-external-link"></i></span>其中的测试样例</p><p><strong>在<code>测试点8</code>错误了，原因为：在检查是否有VIP在排队的时候，忽略了此VIP用户可能在之前以及被处理（VIP有时候可以优先）</strong></p><p>代码实现还是有些细节的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrival;</span><br><span class="line">    <span class="keyword">int</span> served;</span><br><span class="line">    <span class="keyword">int</span> isvip;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Player&amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrival &lt; another.arrival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt; players; <span class="comment">// 存储玩家</span></span><br><span class="line">P tables[maxn]; <span class="comment">// 桌子 first：释放时间 second：是否VIP</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>, clock_21 = <span class="number">21</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">int</span> table_count[maxn];  <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">bool</span> is_served[<span class="number">10001</span>];  <span class="comment">// 玩家是否被服务 针对VIP优先处理</span></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = sec/<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (sec%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> s = sec%<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, h, m, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 以及更新对应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_serverd_player</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> table_pos, <span class="keyword">int</span> served_time)</span> </span>&#123;</span><br><span class="line">    print_time(players[index].arrival); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>; print_time(served_time); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">int</span> wait = (served_time - players[index].arrival + <span class="number">30</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, wait);</span><br><span class="line">    is_served[index] = <span class="literal">true</span>;</span><br><span class="line">    table_count[table_pos]++;</span><br><span class="line">    tables[table_pos].first = served_time + players[index].served;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回VIP和非VIP的最小下标</span></span><br><span class="line"><span class="function">P <span class="title">getMinTableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == <span class="number">-1</span> || tables[i].first &lt; tables[index2].first) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == <span class="number">-1</span> || tables[i].first &lt; tables[index1].first) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;index1, index2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有人等待的情况 VIP的话要先看是否有空闲的VIP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_wait</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取空闲VIP和普通的最小下标</span></span><br><span class="line">    <span class="keyword">int</span> index1 = INF, index2 = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">if</span>(players[index].isvip) &#123;</span><br><span class="line">        tar = index2 == INF ? index1 : index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tar = min(index1, index2);</span><br><span class="line">    &#125;</span><br><span class="line">    push_serverd_player(index, tar, players[index].arrival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(table_count, <span class="number">0</span>, <span class="keyword">sizeof</span>(table_count));</span><br><span class="line">    <span class="built_in">memset</span>(is_served, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_served));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> hh, mm, ss, p, tag;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d %d"</span>, &amp;hh, &amp;mm, &amp;ss, &amp;p, &amp;tag);</span><br><span class="line">        <span class="keyword">int</span> sec = hh*<span class="number">3600</span> + mm*<span class="number">60</span> + ss;</span><br><span class="line">        p = p &gt; <span class="number">120</span> ? <span class="number">120</span>*<span class="number">60</span> : p*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(sec &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        players.push_back(&#123;sec, p, tag&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(players.begin(), players.end());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        tables[i] = &#123;clock_8, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止全部都是普通或者VIP 导致获取下标函数返回没有意义的值</span></span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">0</span>&#125;;</span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> vip_pos; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vip_pos);</span><br><span class="line">        tables[vip_pos<span class="number">-1</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = players.size();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_served[index]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Player p = players[index];</span><br><span class="line">        P min_index = getMinTableIndex();</span><br><span class="line">        <span class="comment">// 后面的都不用处理了</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &gt;= clock_21 &amp;&amp; tables[min_index.second].first &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> table_empty_time;</span><br><span class="line">        <span class="comment">// 普通的先空 意味着没有VIP位置 那么直接给等待的下一个</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &lt; tables[min_index.second].first) &#123;</span><br><span class="line">            table_empty_time = tables[min_index.first].first;</span><br><span class="line">            <span class="comment">// 有人在等待</span></span><br><span class="line">            <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                push_serverd_player(index, min_index.first, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没人等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                no_wait(index);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在空的VIP 位置 注意VIP普通同时为空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table_empty_time = tables[min_index.second].first;</span><br><span class="line">            <span class="comment">// 寻找是否有等待的VIP 有则先给他位置 否则给下一个人</span></span><br><span class="line">            <span class="keyword">int</span> vip_pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; len;i++) &#123;</span><br><span class="line">                <span class="comment">// Error 8:最后一个测试点卡。。已经处理的VIP 跳过</span></span><br><span class="line">                <span class="keyword">if</span>(is_served[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(players[i].arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(players[i].isvip) &#123;</span><br><span class="line">                        vip_pos = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有VIP在等</span></span><br><span class="line">            <span class="keyword">if</span>(vip_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// printf("index:%d vip:%d\n", index, vip_pos);</span></span><br><span class="line">                push_serverd_player(vip_pos, min_index.second, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有VIP在等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 但有普通人等</span></span><br><span class="line">                <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="comment">// 普通人也可以选择VIP的位置 看哪个小选哪个</span></span><br><span class="line">                    <span class="keyword">int</span> tar_pos = tables[min_index.first].first == tables[min_index.second].first ? min(min_index.second, min_index.first) : min_index.second;</span><br><span class="line">                    push_serverd_player(index, tar_pos, table_empty_time);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没人等</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    no_wait(index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,table_count[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != k<span class="number">-3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个VIP球台空的时候，排队中的第一个VIP可以优先使用&lt;/li&gt;
&lt;li&gt;如果当前没有VIP用户等待，普通用户也可以使用VIP球台&lt;/li&gt;
&lt;li&gt;如果VIP用户没有VIP球台可以使用，就使用普通球台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>求解图的连通分量</title>
    <link href="https://joke-lin.top/2020/04/06/2020-04-06-connected-components/"/>
    <id>https://joke-lin.top/2020/04/06/2020-04-06-connected-components/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-04-06T14:42:33.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单定义">简单定义</h2><p>有向图中称为，强连通分量。连通图和连通分量都是针对无向图。</p><p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p><a id="more"></a><h2 id="无向图">无向图</h2><p>对于无向图而言，只要从一个点开始使用DFS或者BFS遍历所有可以遍历的边，这些遍历到的点集就构成了一个连通分量。然后寻找下一个之前没有遍历的点作为下一个连通分量的根结点，继续进行遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 连通分量的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num_nodes;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有向图">有向图</h2><p>下面两个算法都是<span class="math inline">\(O(N+E)\)</span>的复杂度</p><h3 id="tarjan算法">Tarjan算法</h3><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnl2b2lkLmNvbS96aHMvYmxvZy9zY2MtdGFyamFu" title="https://www.byvoid.com/zhs/blog/scc-tarjan">有向图强连通分量的Tarjan算法<i class="fa fa-external-link"></i></span></p><p>算法的基本思想如下：任选一节点开始进行深度优先搜索（<strong>若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行</strong>）。搜索过程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。</p><p>节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。</p><p>算法代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      <span class="comment">// 为节点u设定次序编号和Low初值</span></span><br><span class="line">    Stack.push(u)                              <span class="comment">// 将节点u压入栈中 其实就是保存拓扑序</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E                       <span class="comment">// 枚举每一条边</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)                   <span class="comment">// 如果节点v未被访问过</span></span><br><span class="line">            tarjan(v)                          <span class="comment">// 继续向下找</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)                       <span class="comment">// 如果节点v还在栈内</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])                      <span class="comment">// 如果节点u是强连通分量的根</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                          <span class="comment">// 将v退栈，为该强连通分量中一个顶点</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>DFN[u]：为结点u的搜索编号（时间次序）</li><li>Low[u]：为结点u和与结点u相连的子树的最小搜索序（最早出现时间）</li></ul><p>此算法其中判断强连通分量的思路就是，在以u为根节点进行DFS的过程中如果出现一个结点v指向了之前遍历过的点t，即<span class="math inline">\(u \rightarrow t \rightarrow v \rightarrow t\)</span>也就表明出现了一个环，其中<span class="math inline">\(t,v,t\)</span>就构成了环，即连通分量。</p><p>其中的DFN就保存每个结点的访问顺序，Low保存相关子树的最早访问时间，在算法回溯的时候更新，可保证一个强连通分量的Low都是一致的，栈保存的是拓扑序，即遍历的次序，不断出栈获取连通分量。</p><h3 id="kosaraju算法">Kosaraju算法</h3><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNjQzNzkyNi5odG1s" title="https://www.cnblogs.com/nullzx/p/6437926.html">Kosaraju算法解析: 求解图的强连通分量<i class="fa fa-external-link"></i></span></p><p>Kosaraju算法比Tarjan算法看似要简单一些，但效率没有Tarjan算法高，Kosaraju算法依靠DFS遍历获取极大连通子图。但存在一点问题。</p><p><img src="\assets\ArticleImg\2020\connected-components-1.png" /></p><p>对于上图，从A0开始遍历和B4开始遍历是不一样的结果。如果从B开始遍历，需要2次DFS便可以遍历完整个图，而A0只需要一次。<strong>所以Kosaraju算法的第一个DFS需要获取正确的遍历顺序，</strong>然后第二次DFS的次数便是连通分量的个数了。</p><p>上图的反图为：</p><p><img src="\assets\ArticleImg\2020\connected-components-2.jpg" /></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) dfs1(v);</span><br><span class="line">  s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      dfs2(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是两点：</p><ol type="1"><li>后序遍历获取拓扑序，保证BA的相对顺序不会改变</li><li>反向原图根据上面获取的遍历顺序，重新DFS</li></ol><h4 id="反图的作用">反图的作用</h4><p>其中的反图很有意思，对于强连通子图，反图和原图并无区别。但对于非强连通的则会有很大的影响。例如<span class="math inline">\(A \rightarrow B \rightarrow C\)</span>反图为<span class="math inline">\(A \leftarrow B \leftarrow C\)</span> 从A开始遍历一次便遍历完，但反图后从A开始便需要3次，也就是强连通分量的个数（单个结点也是强连通）。</p><p><strong>所以通过后续遍历获取遍历结点的顺序，然后通过反图获取强连通分量的个数。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单定义&quot;&gt;简单定义&lt;/h2&gt;
&lt;p&gt;有向图中称为，强连通分量。连通图和连通分量都是针对无向图。&lt;/p&gt;
&lt;p&gt;在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点&lt;strong&gt;强连通&lt;/strong&gt;(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个&lt;strong&gt;强连通图&lt;/strong&gt;。非强连通图有向图的极大强连通子图，称为&lt;strong&gt;强连通分量&lt;/strong&gt;(strongly connected components)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1021 Deepest Root （连通分量+树的直径）</title>
    <link href="https://joke-lin.top/2020/04/03/2020-04-03-PAT-Advanced-1021/"/>
    <id>https://joke-lin.top/2020/04/03/2020-04-03-PAT-Advanced-1021/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:12.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODI5MTk2NzM4NTY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856">题目地址<i class="fa fa-external-link"></i></span></p><p>一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。</p><a id="more"></a><h2 id="思路">思路</h2><p>掌握了基础的<a href="/2020/04/06/2020-04-06-connected-components/">连通分量的求法</a>以及<a href="/2020/04/02/2020-04-02-tree-diameter/">树的直径的算法</a>便很简单了</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"><span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDeepest</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;height_set, <span class="keyword">int</span> heights = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            getDeepest(G[root][i], height_set, heights+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_height == heights) &#123;</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_height &lt; heights) &#123;</span><br><span class="line">            height_set.clear();</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">            max_height = heights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            components++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(components &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>, components);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st_points, ed_points;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(<span class="number">1</span>, st_points);</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(*st_points.begin(), ed_points);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ed_points) &#123;</span><br><span class="line">            st_points.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : st_points) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>树的直径</title>
    <link href="https://joke-lin.top/2020/04/02/2020-04-02-tree-diameter/"/>
    <id>https://joke-lin.top/2020/04/02/2020-04-02-tree-diameter/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-04-07T02:33:17.439Z</updated>
    
    <content type="html"><![CDATA[<p>树的直径，即<strong>树中距离最远的两个节点的距离</strong>。</p><h2 id="求解方法">求解方法</h2><p>选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。</p><a id="more"></a><h2 id="简单证明">简单证明</h2><p>其实只要证明：<strong>以任意点为根节点，距离此根节点最远的节点必定是树的直径中的一个端点。</strong></p><p>证明了这个，那么上面提到的算法就很容易证明了，获取第一个端点，然后以此端点为根的最远端点就是另外一个端点。</p><p>首先规定从<em>r</em>开始的最远距离节点为<em>u</em>，证明<em>u</em>为树的直径的一个端点，可以使用反证法证明，假设存在另外两个节点<em>s,t</em>，构成了树的直径。</p><ol type="1"><li><p><strong><em>st</em>的路径和<em>ru</em>不相交</strong>：</p><p>在这种情况下，存在<span class="math inline">\(dis(u,s)+dis(s,t) &gt; dis(s,t)\)</span>，所以<em>st</em>并不是最长的，和假设相矛盾，<em>st</em>这种情况下不存在</p></li><li><p><strong><em>st</em>的路径和<em>ru</em>相交于点<em>v</em>：</strong></p><p>此时<em>s,u</em>都是以<em>a</em>为根的子树上的节点，因为u为距离a最远的结点所以可得： <span class="math display">\[ dis(a,y)+dis(y,u) &gt; dis(a,y)+dis(y,s) \\ 即：dis(u,y) &lt; dis(s,y) \]</span> 同样表示<em>s,t</em>并不是最长的，而是<em>u,t</em></p></li></ol><p>综上，<em>u</em>必定为树的直径的一个端点。</p><p>关于树的直径的更多性质可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2hhZGEtSmhpbi9wLzEwMTk1Mjg3Lmh0bWw=" title="https://www.cnblogs.com/Khada-Jhin/p/10195287.html">博客园 树的直径及其性质与证明<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树的直径，即&lt;strong&gt;树中距离最远的两个节点的距离&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;求解方法&quot;&gt;求解方法&lt;/h2&gt;
&lt;p&gt;选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1020 Tree Traversals （二叉树）</title>
    <link href="https://joke-lin.top/2020/04/01/2020-04-01-PAT-Advanced-1020/"/>
    <id>https://joke-lin.top/2020/04/01/2020-04-01-PAT-Advanced-1020/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:17.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODUwMzM2MDMwNzI=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072">题目地址<i class="fa fa-external-link"></i></span></p><p>给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了</p><a id="more"></a><h2 id="解决思路">解决思路</h2><p>这是一个很经典的重构二叉树的问题了，只要清楚每种遍历的规则和规律即可。</p><p>后序遍历：左子树，右子树，根节点</p><p>中序遍历：左子树，根节点，右子树</p><p>所以对后序遍历而言，后面的节点是前面节点构成的树的根节点，前面节点构成左子树和右子树，所以我们可以采取以下方案获取整棵树的结构。</p><p>从后序遍历数组<code>postorder</code>的末尾开始，从<code>inorder</code>数组中寻找和<code>postorder</code>相同值的，<strong>这样就可以分为两边，分别是左子树和右子树</strong>。然后将<code>postorder</code>末尾向前移动一步，对应的就是右子树的根节点。然后在<code>inorder</code>刚刚分开的右半边继续寻找即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> postorder[maxn];</span><br><span class="line"><span class="keyword">int</span> inorder[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left = <span class="literal">NULL</span>, *right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一棵树 根据根节点的值（这里提供postorder的下标），以及inorder的左右边界</span></span><br><span class="line"><span class="function">Node* <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> post_i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *t_root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 分开左右子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == postorder[post_i]) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_root-&gt;val = inorder[mid];</span><br><span class="line">    <span class="comment">// 递归左右子数</span></span><br><span class="line">    t_root-&gt;right = getTree(post_i<span class="number">-1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    t_root-&gt;left = getTree(post_i - (r - mid) - <span class="number">1</span>, l, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, postorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, inorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getTree(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">    que.push(root-&gt;left);</span><br><span class="line">    que.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        Node *t = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,t-&gt;val);</span><br><span class="line">        que.push(t-&gt;left);</span><br><span class="line">        que.push(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>画个简陋樱花树（简单递归）</title>
    <link href="https://joke-lin.top/2020/03/31/2020-03-31-Draw-CherryTree/"/>
    <id>https://joke-lin.top/2020/03/31/2020-03-31-Draw-CherryTree/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-03-31T13:22:36.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到网上很多代码绘制的樱花树，参见<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0Mzk3Ny9hcnRpY2xlL2RldGFpbHMvMTAyNjkxMzky" title="https://blog.csdn.net/weixin_43943977/article/details/102691392">CSDN<i class="fa fa-external-link"></i></span>，便想自己试试，但是画的有点丑</p></blockquote><a id="more"></a><h2 id="基本思路">基本思路</h2><p>其实就是一个“二叉树的遍历”的思路，使用递归不断的二叉，就可以了，这也算是分形图案了。但是简单的递归二叉，不掌握好长度、角度、粗细以及主干和枝干的变化就会很规整。所以慢慢调参吧。</p><p>这里采用的是给出每个参数的最大取值范围，然后设置一个缩小的函数，随着递归层数的提高，对应的参数越来越小，这个小的程度和范围就要自己把握了。</p><p>缩小函数可以参考：<span class="math inline">\(\frac{1}{n},\frac{1}{\sqrt{n}}\)</span></p><h2 id="依赖">依赖</h2><p>这里的樱花树使用的是一个简单的<span class="exturl" data-url="aHR0cHM6Ly9lYXN5eC5jbi8=" title="https://easyx.cn/">C++图形库 easyx<i class="fa fa-external-link"></i></span>，简单容易上手。</p><h2 id="演示">演示</h2><video src="/assets/ArticleVideo/2020/draw-cherrytree.mp4" preload="metadata" controls playsinline poster="">Sorry, your browser does not support the video tag.</video><h2 id="基础代码">基础代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED (RGB(240, 128, 128))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE (RGB(255, 255, 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROWN (RGB(160, 82, 45))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与主干角度的偏移角度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_min = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_max = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_min = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_max = <span class="number">90</span>;</span><br><span class="line"><span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> thick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区大小</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = <span class="number">800</span>, <span class="built_in">height</span> = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一条线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawline</span><span class="params">(Point st, Point ed)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">line</span>(st.first, st.second, ed.first, ed.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生范围内的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_range</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st + rand() % (ed - st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给点原点 相对于水平的角度 长度 返回处理后的节点</span></span><br><span class="line"><span class="function">Point <span class="title">getPointFromAngle</span><span class="params">(Point src, <span class="keyword">float</span> angle, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    angle = <span class="number">3.14</span>/<span class="number">180.0</span> * angle;</span><br><span class="line">    <span class="keyword">return</span> &#123; src.first+length*<span class="built_in">cos</span>(angle), src.second-length*<span class="built_in">sin</span>(angle) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归画叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_bifurcation</span><span class="params">(Point p, <span class="keyword">float</span> angle, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束层</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 偏移角</span></span><br><span class="line">    <span class="keyword">float</span> delta = rand_range(angle_min, angle_max);</span><br><span class="line">    <span class="comment">// 收缩 使用根号</span></span><br><span class="line">    <span class="keyword">float</span> shrink = <span class="built_in">pow</span>(layer, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 便宜的角度越来越小</span></span><br><span class="line">    <span class="keyword">float</span> left_angle = angle + delta/shrink;</span><br><span class="line">    <span class="comment">// 右分支的角度确定</span></span><br><span class="line">    <span class="keyword">float</span> right_angle = left_angle - <span class="number">2.4</span>*delta/shrink;</span><br><span class="line">    <span class="comment">// 随机长度</span></span><br><span class="line">    <span class="keyword">int</span> length_left = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="keyword">int</span> length_right = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="comment">// 获取下一个分支点</span></span><br><span class="line">    Point left = getPointFromAngle(p, left_angle, length_left);</span><br><span class="line">    Point right = getPointFromAngle(p, right_angle, length_right);</span><br><span class="line">    <span class="comment">// 末端绘制红白相间的花瓣</span></span><br><span class="line">    <span class="keyword">int</span> type = rand() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置厚度</span></span><br><span class="line">    setlinestyle(PS_SOLID , thick/layer);</span><br><span class="line">    drawline(p, left);</span><br><span class="line">    <span class="comment">// 递归左分支</span></span><br><span class="line">    draw_bifurcation(left, left_angle, layer + <span class="number">1</span>);</span><br><span class="line">    setlinestyle(PS_SOLID, thick / layer);</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态效果</span></span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    drawline(p, right);</span><br><span class="line">    <span class="comment">// 递归右分支</span></span><br><span class="line">    draw_bifurcation(right, right_angle, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机绘制地面的花瓣</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_ground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">width</span> * <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">width</span> * <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="built_in">height</span> - <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line">    setlinecolor(RED);</span><br><span class="line">    setlinestyle(PS_SOLID, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y, angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        x = rand_range(left, right);</span><br><span class="line">        y = rand_range(up, down);</span><br><span class="line">        angle = rand_range(<span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line">        Point ed = getPointFromAngle(&#123; x, y &#125;, angle, length);</span><br><span class="line">        Sleep(<span class="number">5</span>);</span><br><span class="line">        drawline(&#123; x, y &#125;, ed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initgraph(<span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    <span class="comment">// 设置背景色</span></span><br><span class="line">    setbkcolor(RGB(<span class="number">241</span>, <span class="number">215</span>, <span class="number">118</span>));</span><br><span class="line">    cleardevice();</span><br><span class="line">    <span class="comment">// 绘制主干</span></span><br><span class="line">    setlinecolor(BROWN);</span><br><span class="line">    setlinestyle(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">line</span>(<span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-110</span>, <span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-20</span>);</span><br><span class="line">    <span class="comment">// 递归绘制</span></span><br><span class="line">    draw_bifurcation(&#123; <span class="built_in">width</span>/<span class="number">2</span>, <span class="built_in">height</span><span class="number">-110</span> &#125;, <span class="number">90.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 绘制掉落花瓣的地面</span></span><br><span class="line">    draw_ground();</span><br><span class="line">    _getch();</span><br><span class="line">    closegraph();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看到网上很多代码绘制的樱花树，参见&lt;a href=&quot;https://blog.csdn.net/weixin_43943977/article/details/102691392&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;，便想自己试试，但是画的有点丑&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ELSE" scheme="https://joke-lin.top/categories/ELSE/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1018 Public Bike Management（Dijkstra + DFS）</title>
    <link href="https://joke-lin.top/2020/03/31/2020-03-31-PAT-Advanced-1018/"/>
    <id>https://joke-lin.top/2020/03/31/2020-03-31-PAT-Advanced-1018/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:23.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODkyODI0MzMwMjQ=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024">题目地址<i class="fa fa-external-link"></i></span></p><p>一眼看去便是最短路问题，和<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003<i class="fa fa-external-link"></i></span>，有点类似，但又不同。</p><p>题目就是求最短路，多条最短路取从基地携带数量最少了，如果有一样的携带数量，就取带回数量最少的，确保这样的路径唯一。</p><a id="more"></a><h2 id="解决思路">解决思路</h2><p>开始以为与<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003<i class="fa fa-external-link"></i></span>一样，但是还是不一样的，因为最短路的子路并不是最优子结构，也就是满足当前的最优条件不一定会满足整体的。这里就必须先将所有的最短路找出，然后计算每一条路的携带数量和带回数量，来选取最优的路径。</p><p>有一个一不注意就中招的坑：在计算携带数量和带回数量的时候需要考虑先后关系，即后面多余的车不能补充前面的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;    <span class="comment">// P.first 为 起始点到 P.second 的最短路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, cost;&#125;;<span class="comment">// 边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];       <span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn];           <span class="comment">// 每个站点的权值</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];                <span class="comment">// 对应点的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev_node[maxn];        <span class="comment">// 最短路的树结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; shortest_paths; <span class="comment">// 起始点到问题点的所有最短路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 获取路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    temp.push_back(root);</span><br><span class="line">    <span class="keyword">if</span>(prev_node[root].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        shortest_paths.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prev_node[root].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        dfs(prev_node[root][i], temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">int</span> c_max, n, problem, m; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;c_max, &amp;n, &amp;problem, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        weight[i] = c_max/<span class="number">2</span> - temp; <span class="comment">// 正 表示carry 负 表示 back</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st, ed, cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;st, &amp;ed, &amp;cost);</span><br><span class="line">        G[st].push_back(&#123;ed, cost&#125;);</span><br><span class="line">        G[ed].push_back(&#123;st, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt;&gt; que;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        P t = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(d[t.second] &lt; t.first) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[t.second].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            edge e = G[t.second][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to] = &#123;t.second&#125;;</span><br><span class="line">                d[e.to] = d[t.second] + e.cost;</span><br><span class="line">                que.push(make_pair(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[e.to] == d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to].push_back(t.second);    <span class="comment">// 添加前置节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(problem);</span><br><span class="line">    <span class="keyword">int</span> min_carry = INF, min_back = INF, min_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; shortest_paths.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, back = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = shortest_paths[i].<span class="built_in">size</span>() - <span class="number">2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="comment">// 坑点 必须按照路径的前进 方向改变对于数值，即后面节点的多余不能给前面节点使用</span></span><br><span class="line">            <span class="keyword">int</span> need = weight[shortest_paths[i][j]];</span><br><span class="line">            <span class="keyword">if</span>(need &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                carry += back - need &gt; <span class="number">0</span> ? <span class="number">0</span> : need - back;</span><br><span class="line">                back = back - need &gt; <span class="number">0</span> ? back - need : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                back += -need;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &lt; min_carry) &#123;</span><br><span class="line">            min_carry = carry;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(carry == min_carry &amp;&amp; back &lt; min_back) &#123;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, min_carry);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = shortest_paths[min_index].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, shortest_paths[min_index][i]);</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, min_back);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一眼看去便是最短路问题，和&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1003&lt;/a&gt;，有点类似，但又不同。&lt;/p&gt;
&lt;p&gt;题目就是求最短路，多条最短路取从基地携带数量最少了，如果有一样的携带数量，就取带回数量最少的，确保这样的路径唯一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1017 Queueing at Bank（优先队列）</title>
    <link href="https://joke-lin.top/2020/03/29/2020-03-29-PAT-Advanced-1017/"/>
    <id>https://joke-lin.top/2020/03/29/2020-03-29-PAT-Advanced-1017/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:42.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTE1MzA1Nzk5Njg=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968">题目地址<i class="fa fa-external-link"></i></span></p><p>和 1014 很相似的题目，同样使用优先队列解决，容易的一道题。</p><p>题目的意思是真的难懂，17：00之后不能被服务，17：00 是到达时间。。不是服务时间，服务时间不能超过1小时是指大于1小时的按一小时处理，而不是不处理</p><a id="more"></a><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrive;</span><br><span class="line">    <span class="keyword">int</span> leave;</span><br><span class="line">    <span class="keyword">int</span> serve_secs;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer &amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrive &lt; another.arrive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_17 = <span class="number">17</span>*<span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> whole_wait_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> legal_nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h, m, s, t; <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d"</span>, &amp;h, &amp;m, &amp;s, &amp;t);</span><br><span class="line">        <span class="keyword">int</span> arrive = h*<span class="number">60</span>*<span class="number">60</span> + m*<span class="number">60</span> + s;</span><br><span class="line">        <span class="keyword">if</span>(arrive &gt; clock_17) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        customers[legal_nums].arrive = arrive;</span><br><span class="line">        customers[legal_nums++].serve_secs = t &gt; <span class="number">60</span> ? <span class="number">3600</span> : t*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(customers, customers + legal_nums);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; leave_que;</span><br><span class="line">    <span class="comment">// 先push M 个 8：00 全在8点离开</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        leave_que.push(clock_8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; legal_nums;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> serve_time = <span class="built_in">max</span>(leave_que.top(), customers[i].arrive); leave_que.pop();</span><br><span class="line">        leave_que.push(serve_time + customers[i].serve_secs);</span><br><span class="line">        whole_wait_sec += serve_time - customers[i].arrive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, legal_nums == <span class="number">0</span> ? <span class="number">0.0</span> : whole_wait_sec/<span class="number">60.0</span>/legal_nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和 1014 很相似的题目，同样使用优先队列解决，容易的一道题。&lt;/p&gt;
&lt;p&gt;题目的意思是真的难懂，17：00之后不能被服务，17：00 是到达时间。。不是服务时间，服务时间不能超过1小时是指大于1小时的按一小时处理，而不是不处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1016 Phone Bills（排序）</title>
    <link href="https://joke-lin.top/2020/03/27/2020-03-27-PAT-Advanced-1016/"/>
    <id>https://joke-lin.top/2020/03/27/2020-03-27-PAT-Advanced-1016/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:55.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTM2NDg3MDM0ODg=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488">题目地址<i class="fa fa-external-link"></i></span></p><p>提交了整整一个下午。。。</p><p>再次吐槽PAT的题目描述，很多时候都是迷迷糊糊的，很多地方没有说清楚。</p><p>这道题一个巨大的坑：<strong>没有符合条件的时间对时，不输出该用户信息</strong></p><p>太坑了。。</p><a id="more"></a><h2 id="题目思路">题目思路</h2><p>题目还是比较简单的，简单的排序即可，可以全部存为一个数组，然后先按名字排序，在名字相同时按时间排序即可。此处采用 C++ Map 分类。对每一个顾客的时间进行排序。然后仅当 当前时间为 <code>on-line</code>紧跟着的下一个时间为<code>off-line</code> 为有效时间对。</p><p>仅当存在有效时间对时才有对应的输出。</p><p>对于一段时间的计费，可以分别计算单独时间到<code>00:00:00</code>的费用，然后相减即可，一个很好的思路。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, mon, day, hour, mins;</span><br><span class="line">    <span class="keyword">bool</span> type;  <span class="comment">// 1: on-line 0: off-line</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Record&amp; another) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; another.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;Record&gt;&gt; calls;</span><br><span class="line"><span class="keyword">int</span> price_table[<span class="number">24</span>], price_day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCost</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = tar.day, h = tar.hour, m = tar.mins;</span><br><span class="line">    ll cost = d * price_day;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++) &#123;</span><br><span class="line">        cost += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cost += price_table[h]*m;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, tar.day, tar.hour, tar.mins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">24</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, price_table+i);</span><br><span class="line">        price_day += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> customer, t, <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; customer;</span><br><span class="line">        Record temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d:%d"</span>, &amp;temp.mon, &amp;temp.day, &amp;temp.hour, &amp;temp.mins);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">line</span>;</span><br><span class="line">        temp.type = <span class="built_in">line</span> == <span class="string">"on-line"</span>;</span><br><span class="line">        temp.t = <span class="number">24</span>*<span class="number">60</span>*temp.day + <span class="number">60</span>*temp.hour + temp.mins; <span class="comment">// 获取从00:00:00到此的分钟数</span></span><br><span class="line">        calls[customer].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : calls) &#123;</span><br><span class="line">        sort(i.second.<span class="built_in">begin</span>(), i.second.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = i.second.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">float</span> cost_all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 判断是否存在有效时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">size</span> - <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second[j].type == <span class="literal">true</span> &amp;&amp; i.second[j+<span class="number">1</span>].type == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i.first &lt;&lt; <span class="string">" "</span>; <span class="built_in">printf</span>(<span class="string">"%02d\n"</span>, i.second[<span class="number">0</span>].mon);</span><br><span class="line">                &#125;</span><br><span class="line">                printTime(i.second[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                printTime(i.second[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> temp_cost = (getCost(i.second[j+<span class="number">1</span>]) - getCost(i.second[j]))/<span class="number">100.0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d $%.2f\n"</span>, i.second[j+<span class="number">1</span>].t - i.second[j].t, temp_cost);</span><br><span class="line">                cost_all += temp_cost;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Total amount: $%.2f\n"</span>, cost_all);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提交了整整一个下午。。。&lt;/p&gt;
&lt;p&gt;再次吐槽PAT的题目描述，很多时候都是迷迷糊糊的，很多地方没有说清楚。&lt;/p&gt;
&lt;p&gt;这道题一个巨大的坑：&lt;strong&gt;没有符合条件的时间对时，不输出该用户信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;太坑了。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>埃氏筛 &amp; 欧拉筛</title>
    <link href="https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/"/>
    <id>https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-26T15:14:03.571Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。</p></blockquote><a id="more"></a><h2 id="试除法">试除法</h2><p>直接使用定义解决的方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从2遍历到<span class="math inline">\(\sqrt n\)</span> 因为之后的就没有必要了，一个和数拆分成两个因子必定是在<span class="math inline">\(\sqrt n\)</span>的两侧，是对称的，所以只需要遍历一边就可以了。</p><h2 id="埃氏筛">埃氏筛</h2><p>上面的算法是判断一个数是否是素数，但是对获取某个范围的素数开销非常大。埃氏筛（素数筛）就是求某个范围素数的算法。</p><p>原理很简单，合数必定可以拆分为一系列素数的积，即<strong>某个素数的任意倍数都是合数</strong>。</p><p>代码也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxn 为范围的上届</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; maxn;j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度为：<span class="math inline">\(n\log \log n\)</span></p><h2 id="欧拉筛">欧拉筛</h2><p>埃氏筛很明显的一个缺点就是一个合数会被重复筛掉（被每一个素数因子筛一次），增加复杂度。欧拉筛就是在其上的改进，使每一个合数只被它的最小因子筛掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;i*prime_numbers[j] &lt; maxn;j++) &#123;</span><br><span class="line">        is_prime[i*prime_numbers[j]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime_numbers[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧拉筛复杂度为n（将空循环不视作开销），每个合数仅被筛一次。</p><p>核心就在于<code>i % prime_numbers[j] == 0</code>，当这个条件成立的时候跳出循环，不继续往下筛，下面的都是已经或者未来要被筛掉的。</p><p>条件成立时意味着 <span class="math inline">\(i = prime\_numbers[j] \times K\)</span>，而继续循环下去回得到<span class="math inline">\(i*prime\_numbers[j+1]\)</span>也就是,<span class="math inline">\(prime\_numbers[j]\times prime\_numbers[j+1] \times K = prime\_numbers[j] \times Q\)</span>，也就是说它会被<span class="math inline">\(prime\_numbers[j]\)</span>乘以另外一个数给筛掉，之后的循环也就没必要进行了。也保证了，每个合数都只被它的最小因子筛掉。</p><p>令<span class="math inline">\(N = K \times Q \times ...\)</span> K Q为两个素数且<span class="math inline">\(Q \gt K\)</span>，假设N可以被Q筛掉，也就是$N = Q M， M= K... $这里的M就是上面循环中的i，它是不可能使用QM筛掉的，因为<code>M%K == 0</code>，就跳出循环之外了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1014 Waiting in Line（优先队列）</title>
    <link href="https://joke-lin.top/2020/03/21/2020-03-24-PAT-Advanced-1014/"/>
    <id>https://joke-lin.top/2020/03/21/2020-03-24-PAT-Advanced-1014/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:35.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTgyMDc5MTE5MzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936">题目地址<i class="fa fa-external-link"></i></span></p><p>之前一直错还是题目看错，英文题目还是要注意啊。</p><p>17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>题目本身不难，理清楚过程即可。（他题目有些也迷）</p><p>给出了N个窗口以及最大等待区M，K个顾客。相当于本来就有K个人在排队，然后每个人依次选窗口当等待区有空位的适合。等待区总共可以容纳NM个人，所以最前面的NM个人依次排满等待区即可（按照题目定的规则），当等待区满的时候，只要有一个人结束服务，那在等待区外排队的人就马上可以塞进去一个。</p><p>所以我们需要知道的就是最早结束服务的人，这就可以用到优先队列了，维护结束服务的时间。时间越早优先级越高。每当他进入等待区，就push到优先队列中。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> win_index;</span><br><span class="line">    <span class="keyword">int</span> end_time;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer&amp; other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 同时离开 选择编号小的</span></span><br><span class="line">        <span class="keyword">return</span> end_time != other.end_time ? end_time &gt; other.end_time : win_index &gt; other.win_index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost_time[maxn];    <span class="comment">// 用户的花费时间</span></span><br><span class="line"><span class="keyword">int</span> end_time[maxn];     <span class="comment">// 每个用户的结束时间</span></span><br><span class="line"><span class="keyword">int</span> win_cur_time[<span class="number">21</span>];   <span class="comment">// 当前窗口等待区清空的最晚时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(win_cur_time, <span class="number">0</span>, <span class="keyword">sizeof</span>(win_cur_time));</span><br><span class="line">    <span class="built_in">memset</span>(end_time, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(end_time));</span><br><span class="line">    <span class="keyword">int</span> n, m, k, q; <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, cost_time+i);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;Customer&gt; que;</span><br><span class="line">    <span class="comment">// 前NM个直接加入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k &amp;&amp; i &lt; n*m;i++) &#123;</span><br><span class="line">        win_cur_time[i%n] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[i%n];</span><br><span class="line">        que.push(&#123;i%n, end_time[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n*m;i &lt; k;i++) &#123;</span><br><span class="line">        Customer temp = que.top(); que.pop();   <span class="comment">// 获取最早离开的</span></span><br><span class="line">        win_cur_time[temp.win_index] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[temp.win_index];</span><br><span class="line">        temp.end_time = end_time[i];</span><br><span class="line">        que.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tar);</span><br><span class="line">        <span class="keyword">int</span> mins = end_time[tar<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// 开始服务的时间不能晚于17:00</span></span><br><span class="line">        <span class="keyword">if</span>(mins - cost_time[tar<span class="number">-1</span>] &gt;= <span class="number">540</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorry\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:%02d\n"</span>, <span class="number">8</span>+mins/<span class="number">60</span>, mins%<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前一直错还是题目看错，英文题目还是要注意啊。&lt;/p&gt;
&lt;p&gt;17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1012 The Best Rank（排序）</title>
    <link href="https://joke-lin.top/2020/03/21/2020-03-21-PAT-Advanced-1012/"/>
    <id>https://joke-lin.top/2020/03/21/2020-03-21-PAT-Advanced-1012/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-21T08:35:50.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDI2NTgwNjg0ODA=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480">题目地址<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks -- that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 2 numbers <em>N</em> and <em>M</em> (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then <em>N</em> lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are <em>M</em> lines, each containing a student ID.</p><h3 id="output-specification">Output Specification:</h3><p>For each of the <em>M</em> students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output <code>N/A</code>.</p><h3 id="sample-input">Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure><h3 id="sample-output">Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N&#x2F;A</span><br></pre></td></tr></table></figure><h2 id="基本思路">基本思路</h2><p>题目本身没什么，就是PAT题目条件给的<strong>太隐晦</strong>了。。。很多条件都不明说</p><p>对于平均分是否四舍五入，并列的处理都不明说，全部藏在例子里面</p><p>是需要<strong>四舍五入</strong>的对于<strong>并列是 1 1 3 4 5</strong>这种（没有第二名了就）</p><p>所以只要把握这两点，这题目就很水了</p><p>首先按<em>ACME</em>的顺序对学生成绩排序，然后更新每个学生最好成绩就可以了，按<em>ACME</em>的顺序也是根据优先级安排的，在相同名次下，后排序更新的不做处理</p><p>这题目还可以使用<strong>空间换时间的思路</strong>，稍微加快一点处理，比如判断是否存在学生，因为学生的学号是个整数，所以直接开辟那么大的数组记录即可，对每个学生的分数排名都可以这么处理</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>]; <span class="comment">// A C M E 对应的分数</span></span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn_ = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_exist[maxn_];   <span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">int</span> best_rank[maxn_];   <span class="comment">// 记录对应的最好成绩</span></span><br><span class="line"><span class="keyword">int</span> best_rank_type[maxn_];  <span class="comment">// 记录最好成绩对应的学科</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(is_exist, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_exist));</span><br><span class="line">    <span class="built_in">memset</span>(best_rank, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(best_rank));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;stu[i].id, &amp;stu[i].score[<span class="number">1</span>], &amp;stu[i].score[<span class="number">2</span>], &amp;stu[i].score[<span class="number">3</span>]);</span><br><span class="line">        stu[i].score[<span class="number">0</span>] = (stu[i].score[<span class="number">1</span>]+stu[i].score[<span class="number">2</span>]+stu[i].score[<span class="number">3</span>])/<span class="number">3</span> + <span class="number">0.5</span>; <span class="comment">// 四舍五入</span></span><br><span class="line">        is_exist[stu[i].id] = <span class="literal">true</span>; <span class="comment">// 标记为存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四个分数排序 按 A C M E 的顺序</span></span><br><span class="line">    <span class="comment">// 相同的情况后不能覆盖前（优先级）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        sort(stu, stu+n, [i](Stu &amp;a, Stu &amp;b)&#123; <span class="keyword">return</span> a.score[i] &gt; b.score[i]; &#125;);</span><br><span class="line">        <span class="keyword">if</span>(best_rank[stu[<span class="number">0</span>].id] != <span class="number">0</span>) &#123;</span><br><span class="line">            best_rank[stu[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">            best_rank_type[stu[<span class="number">0</span>].id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last_rank = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意处理并列。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j<span class="number">-1</span>].score[i] != stu[j].score[i]) &#123;</span><br><span class="line">                last_rank = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(best_rank[stu[j].id] &gt; last_rank) &#123;</span><br><span class="line">                best_rank[stu[j].id] = last_rank;</span><br><span class="line">                best_rank_type[stu[j].id] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> type[] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span>(is_exist[id]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %c\n"</span>, best_rank[id] + <span class="number">1</span>, type[best_rank_type[id]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N/A\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1010 Radix（二分法）</title>
    <link href="https://joke-lin.top/2020/03/19/2020-03-19-PAT-Advanced-1010/"/>
    <id>https://joke-lin.top/2020/03/19/2020-03-19-PAT-Advanced-1010/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-04-21T09:07:13.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDcyMjU2NjU1MzY=" title="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536">题目地址<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p><p>Now for any pair of positive integers <em>N</em>1 and <em>N</em>2, your task is to find the radix of one number while that of the other is given.</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N1 N2 tag radix</span><br></pre></td></tr></table></figure><p>Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p><h3 id="output-specification">Output Specification:</h3><p>For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p><h3 id="sample-input-1">Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure><h3 id="sample-output-1">Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="sample-input-2">Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure><h3 id="sample-output-2">Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><h2 id="基本思路">基本思路</h2><p>PAT题目都很迷，很多地方都不说清楚输入范围。。。</p><p>这道题输入数据不会超过<code>long long</code>，所以可以放心的使用基本思路计算不同进制下的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每次都从进制2开始递增进制，直到一种不可能的情况出现，但这种方法对大小差距极大的两个数特别耗时，对于这种<strong>在一个序列中寻找一个正确解</strong>的过程，显然是用二分法解决。</p><p>但是二分法需要一个范围，那么这道题的进制范围是在哪一个范围。首先对于R进制的串，对于数串内的数必须小于R，所以获取此串的最小进制（下界）就显而易见了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">'0'</span> &amp;&amp; tar &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以使用C++的max_element函数</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">max</span>(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上界即为<code>max(minRadix,  num)</code> num为已知进制的数的值，因为题目中只涉及到0-35的值，所以num作为上届已经足够，因为个位是不可能达到num值的最高就是35，那么在2位数字的情况下最小也是10，此时10在num进制下就是num，所以num进制的最小值就是num，在往上就会大于num就没有必要了</p><p>所有在上下界进行二分法查找即可</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">'0'</span> &amp;&amp; tar &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">max</span>(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">if</span>(tag == <span class="number">2</span>) &#123;</span><br><span class="line">        swap(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// B 是 要计算的</span></span><br><span class="line">    ll tar = getRes(A, radix);</span><br><span class="line">    <span class="comment">//  二分</span></span><br><span class="line">    ll left = getMinRadix(B);</span><br><span class="line">    ll right = <span class="built_in">max</span>(left, tar);</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        ll mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll temp = getRes(B, mid);</span><br><span class="line">        <span class="keyword">if</span>(temp == tar) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, mid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; <span class="number">0</span> || temp &gt; tar) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/tags/PAT/"/>
    
      <category term="二分" scheme="https://joke-lin.top/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
</feed>
