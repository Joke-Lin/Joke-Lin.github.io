<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joke-Lin | BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joke-lin.top/"/>
  <updated>2020-05-22T08:41:31.364Z</updated>
  <id>https://joke-lin.top/</id>
  
  <author>
    <name>Joke-Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 正则替换 Markdown 图像路径前缀</title>
    <link href="https://joke-lin.top/2020/05/22/2020-05-22-blog-image-replace/"/>
    <id>https://joke-lin.top/2020/05/22/2020-05-22-blog-image-replace/</id>
    <published>2020-05-21T16:00:00.000Z</published>
    <updated>2020-05-22T08:41:31.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>在博客网站下直接写文章时,会涉及到图像的路径，但在本地下的路径和最终部署后的路径是不同。对于不是很长的文章，便直接写路径为<code>site.com/assert/.../</code>这样的了。但对于图片过多的情况，这样子渲染起来一堆无效图片，很难受。所以长篇文章就在站点文件夹之外新建一个文件夹写，将图片也存一份到此文件夹下，最后发布的时候，在将所有的图片的路径改成可以显示的。但手动改很麻烦，可以使用正则匹配解决。</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>这里采用的是Python的正则匹配方案。对于路径<code>![text](./img/sub_path)</code>，转换为网站可识别路径只需要将<code>./</code>替换为对应的前缀即可。</p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3.7.3</span></span><br><span class="line"><span class="comment"># 使用：python xx.py 输入文件 需要添加的前缀</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">"amount of parameters must be 3"</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑./img/path  img/path 两种种情况</span></span><br><span class="line">patter = <span class="string">'\!\[.*?\]\((?P&lt;tar&gt;(\./)?).*?\)'</span></span><br><span class="line">patter = re.compile((patter))</span><br><span class="line">file_path, prefix =sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">"r"</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file_in, open(<span class="string">"out-"</span>+file_path, <span class="string">"w"</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">    line = file_in.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        matched = patter.finditer(line) <span class="comment"># 获取所有匹配的Match对象</span></span><br><span class="line">        <span class="keyword">if</span> matched != <span class="literal">None</span>:</span><br><span class="line">            matched = list(matched)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> matched[::<span class="number">-1</span>]: <span class="comment"># 逆序遍历</span></span><br><span class="line">                st, ed = v.start(<span class="string">"tar"</span>), v.end(<span class="string">"tar"</span>)</span><br><span class="line">                <span class="comment"># 替换掉原来的</span></span><br><span class="line">                <span class="keyword">if</span> st == ed:</span><br><span class="line">                    line = line[:st] + prefix + line[st:]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line = line[:st] + prefix + line[ed<span class="number">-1</span>:]</span><br><span class="line">        file_out.write(line);</span><br><span class="line">        line = file_in.readline()</span><br></pre></td></tr></table></figure><p>其中一些函数的解释可以参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L3JlLmh0bWw=">正则表达式操作<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在博客网站下直接写文章时,会涉及到图像的路径，但在本地下的路径和最终部署后的路径是不同。对于不是很长的文章，便直接写路径为&lt;code&gt;site.com/assert/.../&lt;/code&gt;这样的了。但对于图片过多的情况，这样子渲染起来一堆无效图片，很难受。所以长篇文章就在站点文件夹之外新建一个文件夹写，将图片也存一份到此文件夹下，最后发布的时候，在将所有的图片的路径改成可以显示的。但手动改很麻烦，可以使用正则匹配解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://joke-lin.top/categories/Coding/"/>
    
      <category term="ELSE" scheme="https://joke-lin.top/categories/Coding/ELSE/"/>
    
    
      <category term="Python" scheme="https://joke-lin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>VERCEL（原名为ZEIT）DNS 记录的修改</title>
    <link href="https://joke-lin.top/2020/05/17/2020-05-17-VERCEL-DNS-EDIT/"/>
    <id>https://joke-lin.top/2020/05/17/2020-05-17-VERCEL-DNS-EDIT/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-05-17T09:14:03.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>VERCEL提供静态网站的部署和CDN的加速，十分优秀的工具（适合白嫖）</p></blockquote><h2 id="问题简述">问题简述</h2><p>在部署自己的静态网站后（从GITHUB），VERCEL提供了他们的子域名，当然可以使用自己的域名。可以用CNAME将域名导向VERCEL的子域名，也可以直接使用我们自己的域名（不通过CNAME）。具体配置参考：<span class="exturl" data-url="aHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvdjIvY3VzdG9tLWRvbWFpbnM=">Custom Domain<i class="fa fa-external-link-alt"></i></span></p><p>但直接使用自己的域名会出现一个问题，使用VERCEL提供的DNS服务器后，原来配置的DNS解析失效了。原来我使用的是阿里云的云解析，在更改为VERCEL的DNS服务后，子域名的A记录失效。</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>既然域名解析失效，因为DNS服务器改成了VERCEL的，所以我们想要改回来需要通过VERCEL修改DNS记录。这需要通过VERCEL的CLI工具实现。下载地址为：https://vercel.com/download</p><p>需要先登录，执行：<code>vercel login</code>，登录好之后，就可以修改DNS解析了。（这里我登录验证了好久……）</p><p>跟着vercel的官方教程即可：https://vercel.com/docs/cli#commands/domains</p><p><code>vercel dns add [domain] [subdomain] [A || AAAA || ALIAS || CNAME || TXT] [value]</code></p><p>便可以修改记录</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;VERCEL提供静态网站的部署和CDN的加速，十分优秀的工具（适合白嫖）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题简述&quot;&gt;问题简述&lt;/h2&gt;
&lt;p&gt;在部署自己的静态网站后（从GITHUB），VERCEL提供了他们的子域名，当然可以使用自己的域名。可以用CNAME将域名导向VERCEL的子域名，也可以直接使用我们自己的域名（不通过CNAME）。具体配置参考：&lt;a href=&quot;https://vercel.com/docs/v2/custom-domains&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Custom Domain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但直接使用自己的域名会出现一个问题，使用VERCEL提供的DNS服务器后，原来配置的DNS解析失效了。原来我使用的是阿里云的云解析，在更改为VERCEL的DNS服务后，子域名的A记录失效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://joke-lin.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Tutorial" scheme="https://joke-lin.top/categories/%E9%9A%8F%E7%AC%94/Tutorial/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1059 Prime Factors（素数）</title>
    <link href="https://joke-lin.top/2020/05/16/2020-05-16-PAT-Advanced-1059/"/>
    <id>https://joke-lin.top/2020/05/16/2020-05-16-PAT-Advanced-1059/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-17T08:50:18.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTUwMDU1MDM0ODg=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>将一个数分解为一系列素数相乘的结果，如<code>97532468=2^2*11*17*101*1291</code></p><a id="more"></a><h2 id="简单思路">简单思路</h2><p>网上很多建立素数表的（使用<a href="https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/">素数筛</a>)，但这道题应该是没有必要的。</p><p>从最简单的<a href="https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/#试除法">一个个除的方法求素数</a>可以解决这道题目。从2开始除，除到2不能除的时候用3除，之后用4，用5……，当然这里4是不能除的，即4不做如何处理跳转到用5除，因为前面2已经将2的倍数全部给除掉了，也就不可能被4除了，这里面也就隐含了<a href="https://joke-lin.top/2020/03/24/2020-03-24-prime-sieve/#埃氏筛">埃氏筛</a>的特点。</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld="</span>, n);</span><br><span class="line">    <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        m[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= sqr;) &#123;</span><br><span class="line">        <span class="comment">// 一个因子</span></span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            n = n/i;</span><br><span class="line">            sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">        m[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = m.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.second != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d^%d"</span>, v.first, v.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, v.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805415005503488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将一个数分解为一系列素数相乘的结果，如&lt;code&gt;97532468=2^2*11*17*101*1291&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1057 Stack （树状数组）</title>
    <link href="https://joke-lin.top/2020/05/14/2020-05-14-PAT-Advanced-1057/"/>
    <id>https://joke-lin.top/2020/05/14/2020-05-14-PAT-Advanced-1057/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-05-17T08:50:14.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTc5NDU3MTA1OTI=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定栈的一系列POP，PUSH操作，求执行这些操作后的栈中从小到大排序的中位数（询问中位数的操作是多次的）</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>栈的模拟并不难处理，主要是对中位数的判断。在不断的更改之中还需要寻找一组数的中位数（范围特征），并且修改每次修改一个具体的数（单点修改），这两个特征符合<a href="https://joke-lin.top/2020/05/13/2020-05-13-Binary-Index-Tree/">树状数组</a>的特征。但还是很难将题目与树状数组联系起来（是真的想不到）。</p><p>数组数组的最大特征就是<strong>区间和的计算（前缀和）和高效率的单点修改</strong>，这如何与题目的中位数联系起来，中位数即中间位置的数，也就说明从开始到该数的个数为总数的一半。所以我们使用树状数组维护X这个数的个数，求中位数也就是求目标X，满足1-X范围内的前缀和为总数的一半。这就与树状数组相联系了。</p><p>题目给定的条件N为正数，并且小于<span class="math inline">\(10^5\)</span>满足使用树状数组的条件。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOWBIT(x) ((x)&amp;(-(x)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示值x的数量加1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; maxn) &#123;</span><br><span class="line">        nums[x] += v;   </span><br><span class="line">        x += LOWBIT(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取&lt;x的所有个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        res += nums[x];</span><br><span class="line">        x -= LOWBIT(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span>(nums));</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">'o'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = s.top(); s.pop();</span><br><span class="line">                add(x, <span class="number">-1</span>); <span class="comment">// 减少一个了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">'e'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tar = (s.size() + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = maxn<span class="number">-1</span>, mid;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(getsum(mid) &lt; tar) &#123;</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">'u'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            s.push(x);</span><br><span class="line">            add(x, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805417945710592&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定栈的一系列POP，PUSH操作，求执行这些操作后的栈中从小到大排序的中位数（询问中位数的操作是多次的）&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Binary Index Tree 树状数组</title>
    <link href="https://joke-lin.top/2020/05/13/2020-05-13-Binary-Index-Tree/"/>
    <id>https://joke-lin.top/2020/05/13/2020-05-13-Binary-Index-Tree/</id>
    <published>2020-05-12T16:00:00.000Z</published>
    <updated>2020-05-17T08:50:11.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树状数组">树状数组</h2><p>树状数组是能够完成下述操作的数据结构：</p><p>给定一个初始值全为0的数列，<span class="math inline">\(a_1,a_2,\dots,a_n\)</span></p><ul><li>给定i，计算<span class="math inline">\(a_1+a_2+\dots+a_n\)</span></li><li>给定i和x，执行<span class="math inline">\(a_i+=x\)</span></li></ul><p>即单点修改和区间和计算</p><a id="more"></a><h2 id="原理介绍">原理介绍</h2><h3 id="树状数组结构">树状数组结构：</h3><p><img src="\assets\ArticleImg\2020\bit.png" /></p><p>使用大节点保存了多个子节点的信息（区间和信息），如图，<span class="math inline">\(a_8\)</span>为<span class="math inline">\(a_1 \sim a8\)</span>的和，<span class="math inline">\(a_6\)</span>则为<span class="math inline">\(a_5,a_6\)</span>，十分巧妙</p><p>其中每个节点的相关节点和其下标对应的二进制有关，与其二进制末尾0的个数有关。其中求<span class="math inline">\(a_1+a_2+\dots+a_n\)</span>，有以下规律：</p><ol type="1"><li><span class="math inline">\(SUM(2) = a[1]+a[2]\)</span></li><li><span class="math inline">\(SUM(3) = a[2] + a[3]\)</span></li><li><span class="math inline">\(SUM(4) = a[4]\)</span></li><li><span class="math inline">\(SUM(5) = a[4]+a[5]\)</span></li><li><span class="math inline">\(SUM(6) = a[4]+a[6]\)</span></li></ol><p>要获取<span class="math inline">\(SUM[n]\)</span>则必须知道<span class="math inline">\(SUM(n-(2^{0的个数}))\)</span>，这个0的个数通过以下函数获取:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用宏实现，x和-x按位相与便可以获得<span class="math inline">\(2^{num(0)}\)</span></p><p>所以获取<span class="math inline">\(SUM(n)\)</span>，可以由以下代码获取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        res += nums[n];</span><br><span class="line">        n -= lowbit(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单点更新，从以下结论可以得出方法：</p><p>更新点x，则所有包含点x结果的点均要更新，而包含点x的点即为x+lowbit(x)，所以代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v当然可以是负数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; maxn) &#123;</span><br><span class="line">        nums[x] += v;   </span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;树状数组&quot;&gt;树状数组&lt;/h2&gt;
&lt;p&gt;树状数组是能够完成下述操作的数据结构：&lt;/p&gt;
&lt;p&gt;给定一个初始值全为0的数列，&lt;span class=&quot;math inline&quot;&gt;\(a_1,a_2,\dots,a_n\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定i，计算&lt;span class=&quot;math inline&quot;&gt;\(a_1+a_2+\dots+a_n\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;给定i和x，执行&lt;span class=&quot;math inline&quot;&gt;\(a_i+=x\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即单点修改和区间和计算&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://joke-lin.top/categories/Coding/"/>
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/Coding/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1052 Linked List Sorting（排序）</title>
    <link href="https://joke-lin.top/2020/05/11/2020-05-11-PAT-Advanced-1052/"/>
    <id>https://joke-lin.top/2020/05/11/2020-05-11-PAT-Advanced-1052/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2020-05-17T08:50:03.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MjU3ODA2NzA0NjQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定内存中的链表，节点格式为（地址，值，指向下一个节点的地址），并给出开始地址，给出此链表从小到大排序后的链表。</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>这道题只需要排序即可，比较基础，但有几个坑，首先这类题一定要考虑不存在的情况（即给出的开始地址是无效的），再者不要使用stl，map会超时……能够使用数组哈希表代替map就不要使用map，开销大很多。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Node;</span><br><span class="line">Node G[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, v, addr, next, st;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;st);</span><br><span class="line">    <span class="keyword">bool</span> is_empty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;addr, &amp;v, &amp;next);</span><br><span class="line">        <span class="keyword">if</span>(addr == st) &#123;</span><br><span class="line">            is_empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G[addr] = &#123;v, next&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_empty) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 -1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>.push_back(st);</span><br><span class="line">        <span class="keyword">if</span>(G[st].second == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st = G[st].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end(), [](<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> G[a].first &lt; G[b].first;&#125;);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">list</span>.size();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %05d\n"</span>, len, <span class="built_in">list</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, <span class="built_in">list</span>[i], G[<span class="built_in">list</span>[i]].first, <span class="built_in">list</span>[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, <span class="built_in">list</span>[i], G[<span class="built_in">list</span>[i]].first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定内存中的链表，节点格式为（地址，值，指向下一个节点的地址），并给出开始地址，给出此链表从小到大排序后的链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1051 Pop Sequence（栈）</title>
    <link href="https://joke-lin.top/2020/05/06/2020-05-06-PAT-Advanced-1051/"/>
    <id>https://joke-lin.top/2020/05/06/2020-05-06-PAT-Advanced-1051/</id>
    <published>2020-05-05T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:59.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MjczMzI1NjI5NDQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定栈的最大容量，按照1~N的顺序入栈，但可以随时出栈，判断给出的pop序列是否是可能的情况</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>这里主要是运用栈这种数据结构先进后出的特点，假如当前pop出来的值为a，那么1~a之间的值，必定是被push过了，所以我们从左到右遍历pop序列并且维护一个栈，而且记录当前已pop的最大值maxn，如果当前pop值t大于他，说明有新的值push到栈中，这些值即为a+1~t，如果小于maxn，说明现在的值是已经被push到栈中了的，所以直接查看它与当前栈顶的值是否一致，是的话则将栈pop，否则说明非法序列，在push到栈的过程中要检查栈大小，不能超过限定值</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> m, n, k; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; maxn) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = maxn+<span class="number">1</span>;j &lt;= v;j++) &#123;</span><br><span class="line">                    s.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s.size() &gt; m) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxn = v;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(v != s.top()) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定栈的最大容量，按照1~N的顺序入栈，但可以随时出栈，判断给出的pop序列是否是可能的情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1049 Counting Ones（动态规划？数学问题）</title>
    <link href="https://joke-lin.top/2020/05/02/2020-05-02-PAT-Advanced-1049/"/>
    <id>https://joke-lin.top/2020/05/02/2020-05-02-PAT-Advanced-1049/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:43.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MzA1OTU3MzE0NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定n，给出[1,n]范围内所有数字含有的1的个数</p><a id="more"></a><h2 id="简单思路">简单思路</h2><h3 id="规律">规律</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGl1Y2h1by5uZXQvYXJjaGl2ZXMvMjMwNQ==">刘婼巨佬的方法<i class="fa fa-external-link-alt"></i></span>，网上很多都是如此的算法，这道题是《编程之美》中的一道例题，简单来说只需要按以下规律计算即可：</p><p><img src="/assets/ArticleImg/2020/pat1049.png" /></p><h3 id="动态规划有点那么意思">动态规划（有点那么意思）</h3><p>这道题还是想了好久，用了种类似动态规划的方法（或者说动归的思想）。题目求的是1的数目，那么就简单的想就需要知道包含1个1的数字有多少，包含2个1的数字有多少……</p><p>所以有什么非暴力的方法获取这些数据，是否可以根据带判断数字的前N位，推出N+1位的数据。比如求123以内的1的个数，如果知道12的相关数据，是否可以推导出123的。</p><p>例如，12有下表，纵为1的个数：（包含0）</p><table><thead><tr class="header"><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td>12</td><td>9</td><td>3（1，10，12）</td><td>1（11）</td><td>0</td></tr></tbody></table><p>根据上表便可以推导出123的相关数据：</p><p>比如，求123中只含有1个1的数字的数量。<strong>含有1个1可以从12中的（0，1）两列数据导出，因为含有1个1，可以是不包含1的情况后面添加一个1，如XX1的形式，或者是12中含有1个1的情况添加非1的数如1X[~1]</strong>，还需要注意的一点，<strong>在12中，12这个数是在1列中（表示含有1个1），所以给他添加第三个数的时候需要分类讨论了</strong>，比如10，它的第三位就有9种可能，0，2，3...9，但对于12就只有3种可能，0，2，3（因为目标是123，第三位是3）。还需要注意N+1位为0的情况。</p><p>所以获得123的数据表如下：</p><table><thead><tr class="header"><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td>12</td><td>9</td><td>3（1，10，12）</td><td>1（11）</td><td>0</td></tr><tr class="even"><td>123</td><td>81</td><td>9+2*9+1*3</td><td>3+1*9</td><td>1</td></tr></tbody></table><p>大致思路如上，总结来说，求N+1为的j个数1的数量需要N位j-1，j两列的数据，需要对N位数做单独讨论，因为对XXY，如果前两位是XX那么N+1位就只有Y+1中可能的选择，否则有10种。其次还需要注意对0的讨论。</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个数1个个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calOnes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getOnes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> num_str[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(num_str, <span class="string">"%d"</span>, num);</span><br><span class="line">    ll table[<span class="number">30</span>]; <span class="comment">// 存储信息表 位数-数量表</span></span><br><span class="line">    <span class="built_in">memset</span>(table, <span class="number">0</span>, <span class="keyword">sizeof</span>(table));</span><br><span class="line">    <span class="comment">// 初始化1位的情况</span></span><br><span class="line">    table[<span class="number">0</span>] = num_str[<span class="number">0</span>]-<span class="string">'0'</span>, table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lens = <span class="built_in">strlen</span>(num_str);</span><br><span class="line">    <span class="keyword">int</span> up_pos = calOnes(table[<span class="number">0</span>]); <span class="comment">// 记录N位的1的个数，以获取其在哪一列</span></span><br><span class="line">    <span class="keyword">int</span> temp_sum = table[<span class="number">0</span>];    <span class="comment">// N位对应的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= lens;i++) &#123;  <span class="comment">// 位数遍历</span></span><br><span class="line">        <span class="keyword">int</span> cur_num = num_str[i<span class="number">-1</span>] - <span class="string">'0'</span>;   <span class="comment">// 当前的对应位的值</span></span><br><span class="line">        temp_sum = temp_sum*<span class="number">10</span> + cur_num;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;   <span class="comment">// 保存含有1的数字总和</span></span><br><span class="line">        <span class="comment">// 从后往前压缩数组（滚动数组）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = i;cur &gt;= <span class="number">1</span>;cur--) &#123;   <span class="comment">// 获取对应1的个数的数量</span></span><br><span class="line">            <span class="keyword">int</span> prev = cur<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 对应prev，cur两列的数值</span></span><br><span class="line">            <span class="keyword">int</span> a = up_pos == prev ? table[prev] - (cur_num == <span class="number">0</span>) : table[prev];</span><br><span class="line">            <span class="keyword">int</span> b = up_pos == cur ? (table[cur] - <span class="number">1</span>)*<span class="number">9</span> + (cur_num == <span class="number">0</span> ? <span class="number">1</span> : cur_num) : table[cur]*<span class="number">9</span>;</span><br><span class="line">            table[cur] = a+b;</span><br><span class="line">            temp += table[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        table[<span class="number">0</span>] = temp_sum - temp + <span class="number">1</span>; <span class="comment">// 不包含1 的数量</span></span><br><span class="line">        up_pos = calOnes(temp_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= lens;i++) &#123;</span><br><span class="line">        res += i*table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getOnes(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805430595731456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定n，给出[1,n]范围内所有数字含有的1的个数&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1044 Shopping in Mars（二分）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-25-PAT-Advanced-1044/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-25-PAT-Advanced-1044/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:26.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MzkyMDI0NDMyNjQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>简单来说，即给定一串数字序列，以及目标值M，找出一段和为M的子串，若不存在找出大于M的最小子串</p><a id="more"></a><h2 id="简单思路">简单思路</h2><p>这是一道二分法的题目，开始很难看出来，因为二分意味着有序，这里并没有什么有序。唯一可能有序的就是和了，如果让一个数组sums保存从开始到此位置的和，那这个数组就是递增的了，也就可以使用二分法了。</p><p>从位置i开始（左界）寻找符合条件的右界，也就是找前缀和为sums[i-1]+M的下标，这就可以使用二分查找了</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> sums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ed = n, mid, tar = m+sums[st<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(st &lt; ed) &#123;</span><br><span class="line">        mid = (st + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sums[mid] &gt;= tar) &#123;</span><br><span class="line">            ed = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mid);</span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>] + mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min_m = sums[n];</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tar_pos = divide(i);</span><br><span class="line">        <span class="keyword">int</span> temp = sums[tar_pos]-sums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; min_m) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; min_m) &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                min_m = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(&#123;i, tar_pos&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : res) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-%d\n"</span>, v.first, v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说，即给定一串数字序列，以及目标值M，找出一段和为M的子串，若不存在找出大于M的最小子串&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="二分" scheme="https://joke-lin.top/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1045 Favorite Color Stripe（动态规划）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-27-PAT-Advanced-1045/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-27-PAT-Advanced-1045/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:29.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0Mzc0MTE0NzU0NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>和最长公共子序列很相似，不同的是这里是求串B中符合串A的数字顺序的最长串的大小（即可重复）。比如：</p><p>给定顺序A为：1、2、3，待匹配串B为：1、1、2、4、3、2</p><p>其中符合条件的串有：</p><ol type="1"><li>1、1、2、2</li><li>1、2、2</li><li>2、3</li><li>...</li></ol><a id="more"></a><h2 id="基本思路">基本思路</h2><p>题目和最长公共子序列几乎是一样的，都是动态规划的思路。既然是动态规划那么就涉及到状态转移方程了。类比最长公共子序列，这里使用<code>dp[i][j]</code>表示A串第i位和B串第j位可以构成满足条件的最长串大小。</p><p>构成的状态转移方程为： <span class="math display">\[dp[i][j] = \begin{cases}dp[i][j-1]&amp; \text{A[i-1]==B[j-1]} \\max(dp[i][j-1], dp[j-1][i]&amp; \text{else}\end{cases}\]</span> 可以看出和最长公共子序列仅仅在A[i-1] == B[j-1]（注意dp是从1开始的，表示第i位）时不一样，由<span class="math inline">\(dp[i-1][j-1] + 1\)</span>变成了<span class="math inline">\(dp[i][j-1]+1\)</span>，就是<strong>因为此题目允许相对顺序的重复</strong>。</p><p>这里还可以进行状态压缩，注意到此时位二维DP数组，观察其状态转移方程，可以将其压缩为一维数组（也叫做滚动数组）</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> nums[maxn];</span><br><span class="line"><span class="keyword">int</span> order[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nums+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] == order[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805437411475456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和最长公共子序列很相似，不同的是这里是求串B中符合串A的数字顺序的最长串的大小（即可重复）。比如：&lt;/p&gt;
&lt;p&gt;给定顺序A为：1、2、3，待匹配串B为：1、1、2、4、3、2&lt;/p&gt;
&lt;p&gt;其中符合条件的串有：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;1、1、2、2&lt;/li&gt;
&lt;li&gt;1、2、2&lt;/li&gt;
&lt;li&gt;2、3&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="动态规划" scheme="https://joke-lin.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1043 Is It a Binary Search Tree（树）</title>
    <link href="https://joke-lin.top/2020/04/21/2020-04-21-PAT-Advanced-1043/"/>
    <id>https://joke-lin.top/2020/04/21/2020-04-21-PAT-Advanced-1043/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:23.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDA5NzY2MzM4NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印树的后续遍历结果</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>前序遍历：<span class="math inline">\(根节点 \rightarrow 左子树 \rightarrow 右子树\)</span>，对于根结点root，只需要将其之后的结点分为两部分（左小于，右大于等于），分别为左子树和右子树，然后对两部分继续递归分解。递归的结构恰好实现了后序遍历<span class="math inline">\(左子树 \rightarrow 右子树 \rightarrow 根节点\)</span>，只要在递归返回的时候记录当前节点值，就可以了。</p><p>对于非法搜索树的判断，即在切分子树的阶段，从序列的首尾向中心查找，如果存在没有被归入左子树或者右子树的，则为非法搜索树。</p><p>代码如下（参考了<span class="exturl" data-url="aHR0cHM6Ly93d3cubGl1Y2h1by5uZXQvYXJjaGl2ZXMvMjE1Mw==">刘婼<i class="fa fa-external-link-alt"></i></span>的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre_order[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> is_mirror = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post_order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免只有一半的树 比如5 4 3，此时的ed是大于st的</span></span><br><span class="line">    <span class="keyword">if</span>(st &gt; ed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = st+<span class="number">1</span>, l = ed;</span><br><span class="line">    <span class="keyword">if</span>(!is_mirror) &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &lt; pre_order[st]) r++; <span class="comment">// 最后的r是大于l的 因为++，真正的位置是循环结束的r-1</span></span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &gt;= pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &gt;= pre_order[st]) r++;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &lt; pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r - l != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刚刚好为后续遍历</span></span><br><span class="line">    getTree(st+<span class="number">1</span>, l);   <span class="comment">//  左边</span></span><br><span class="line">    getTree(r, ed);     <span class="comment">// 右边</span></span><br><span class="line">    post_order.push_back(pre_order[st]);    <span class="comment">// 根结点 此处即为后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, pre_order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        post_order.clear();</span><br><span class="line">        is_mirror = <span class="literal">true</span>;</span><br><span class="line">        getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; post_order.size();i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, post_order[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != post_order.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印树的后续遍历结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1040 Longest Symmetric String（动态规划）</title>
    <link href="https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1040/"/>
    <id>https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1040/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:18.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDYxMDIwNzMzNDQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>求最长回文子串的长度</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>这里使用动态规划求解 <span class="math display">\[dp[i][j]=\begin{cases}true &amp; &amp; dp[i-1][j+1] == true \&amp;\&amp; str[i]==str[j] \\false &amp; &amp;\text{else}\end{cases}\]</span> dp[i][j] 表示substr(j, i) 是否是回文串</p><p>这里动态规划遍历的顺序可以有多种，我是以下标为遍历顺序，也可以以回文串长度作为遍历顺序。</p><p>还有一种算法为马拉车算法，实现了复杂度<span class="math inline">\(O(n)\)</span>。可参考<a href="https://joke-lin.top/2018/10/01/2018-10-01-manacher/">最长回文子串算法</a></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    fgets(s, maxn, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i][i<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            res = max(res, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求最长回文子串的长度&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="动态规划" scheme="https://joke-lin.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1038 Recover the Smallest Number （贪心）</title>
    <link href="https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1038/"/>
    <id>https://joke-lin.top/2020/04/16/2020-04-16-PAT-Advanced-1038/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:13.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDk2MjUyODg3MDQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定一系列数字串，使用他们组成一个最小的数字</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>似乎或者应该有那么点贪心的思路，重载一个排序函数，每次选取保证可以最小整个数字串的值。</p><p>重载<code>string</code>比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较的思路大概就是对于两个串，从开始遍历，优先选择数字小的，如果两个串前缀完全相同比如A：321，B：32，那么就比较，AB和BA的数字大小情况。</p><p>因为无论什么样的顺序，最终的数字位数是确定的，所以确定取那个串作为下一部分，只要选取前缀最小的就可以了。</p><p>注意00000的情况，需要打印一个0</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> num_str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; seq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num_str;</span><br><span class="line">        seq.push_back(num_str);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(seq.begin(), seq.end(), cmp);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : seq) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i[j] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805449625288704&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一系列数字串，使用他们组成一个最小的数字&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="贪心" scheme="https://joke-lin.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1033 To Fill or Not to Fill （贪心）</title>
    <link href="https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1033/"/>
    <id>https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1033/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:09.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NTg3MjI3MzQwODA=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。</p><a id="more"></a><h2 id="思路">思路</h2><p>思路清楚的话便十分简单了，大体思想就是贪心。贪心策略如下：</p><p>当到达一个加油站的时候，获取其满油状态下可以到达的最远距离，然后<strong>在当前和最远距离之间</strong>选取一个合适的加油站，作为下一次加油的站点。通过下面的方式获取合适站点：</p><ol type="1"><li>如果存在<strong>油价比当前所在加油站价格低</strong>的，则在当前加油站加油到恰好可以到达第一个油价低于它的</li><li>否则直接在当前加油站加满油，然后下一个加油站为满油状态下可到达的最远加油站</li></ol><p>如果到不了下一个油站则直接输出最大可到达距离即可。</p><p>需要特判一下开始位置没有加油站的情况，直接输出最大距离0.00。</p><p>此贪心策略画个图便很容易想到并证明了。如果在当前加油站可开到一个比他油价低的加油站则在低油价站点补充油一定比直接开要开销小。相反如果不能开到油价低的，则说明途径的油站价格都比原油站价格高，则在途中补充不如直接开到最后一个在补充。<strong>此正确性来自，每个加油站最多且保证可加到满油状态。</strong></p><p>注意在考虑的时候，要注意到此油站可能还剩余一些油。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">float</span> tank, dis, avg, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f %f %f %f"</span>, &amp;tank, &amp;dis, &amp;avg, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; &gt; gas_stations;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> v, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f %f"</span>, &amp;v, &amp;d);</span><br><span class="line">        gas_stations.push_back(&#123;d, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    gas_stations.push_back(&#123;dis, <span class="number">0</span>&#125;);   <span class="comment">// 将最后一个站设为免费加油站 便于后面处理</span></span><br><span class="line">    sort(gas_stations.begin(), gas_stations.end()); <span class="comment">// 按距离排序</span></span><br><span class="line">    <span class="comment">// 起始位置没有加油站</span></span><br><span class="line">    <span class="keyword">if</span>(gas_stations[<span class="number">0</span>].first != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> cost = <span class="number">0</span>, last_gas = <span class="number">0</span>;  <span class="comment">// 开销 &amp; 到此加油站剩余油</span></span><br><span class="line">    <span class="keyword">int</span> cur_pos = <span class="number">0</span>, stations_size = gas_stations.size();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> next_dis = gas_stations[cur_pos].first + tank*avg;  <span class="comment">// 在这个站满油情况下的可以开到的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> tar_pos = <span class="number">-1</span>;   <span class="comment">// 获取开销最小的下一个加油站</span></span><br><span class="line">        <span class="comment">// 从这段距离中获取合适的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_pos+<span class="number">1</span>;i &lt; stations_size;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].first &gt; next_dis) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tar_pos = i;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能到达到下一个站</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f"</span>, next_dis);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> gas_need; <span class="comment">// 需要购买的油</span></span><br><span class="line">        <span class="comment">// 有价格更小的站</span></span><br><span class="line">        <span class="keyword">if</span>(gas_stations[tar_pos].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">            gas_need = (gas_stations[tar_pos].first-gas_stations[cur_pos].first)/avg - last_gas;</span><br><span class="line">            last_gas = <span class="number">0</span>;   <span class="comment">// 直接买足够到下一个站的油即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 价格都比它大</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            gas_need = tank - last_gas;   <span class="comment">// 直接加满</span></span><br><span class="line">            last_gas = (next_dis - gas_stations[tar_pos].first)/avg; <span class="comment">// 更新到下一个站的油量</span></span><br><span class="line">        &#125;</span><br><span class="line">        cost += gas_need*gas_stations[cur_pos].second;</span><br><span class="line">        <span class="comment">// 到达目标地</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == stations_size<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_pos = tar_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="贪心" scheme="https://joke-lin.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1032 Sharing（链表）</title>
    <link href="https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1032/"/>
    <id>https://joke-lin.top/2020/04/11/2020-04-11-PAT-Advanced-1032/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:06.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NjA2NTIxMTM5MjA=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。</p><a id="more"></a><h2 id="思路">思路</h2><p>200ms的限制时间暴力是不可能暴力的，必须是线性时间的算法。</p><p>我的思路比较繁琐，首先获取两个字符串的完整路径，并分别记录他们的前置结点，和结尾结点位置。如果两个结尾不一样则输出-1，否则从末尾开始向前寻找第一个分支即可（两个字符串第一个路径前驱不同的位置）。</p><p>在生成路径的时候注意<strong>不要以是否为-1作为结束判断</strong>，有些字符串可能他只给出一部分，并没有-1结束标志。其次，采取这种思路在寻找前驱分支的时候，注意当两个字符串为同一个的情况（可能会出现）。可以实现将起始点的前驱结点赋值为不同的值，如-1，-2即可。</p><p>网上一种很简便的方法就是遍历字符串1，将遍历到的点记录，然后遍历字符串2，遇到的第一个字符串1中遍历过的，就是公共后缀的开始位置了。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; link;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> st_1, st_2, ed_1, ed_2, n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prev_1, prev_2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;st_1, &amp;st_2, &amp;n);</span><br><span class="line">    <span class="comment">// 防止有两个字符串完全一样的情况。。</span></span><br><span class="line">    prev_1[st_1] = <span class="number">-1</span>;</span><br><span class="line">    prev_2[st_2] = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur, next;</span><br><span class="line">        <span class="keyword">char</span> v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>, &amp;cur, &amp;v, &amp;next);</span><br><span class="line">        link[cur] = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = st_1;</span><br><span class="line">    <span class="comment">// 条件为link[cur].next != -1会TE 可能不会有-1结尾</span></span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_1[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_1 = cur;</span><br><span class="line">    cur = st_2;</span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_2[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_2 = cur;</span><br><span class="line">    <span class="keyword">if</span>(ed_1 != ed_2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev_1[cur] != prev_2[cur]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = prev_1[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1026 Table Tennis （模拟）</title>
    <link href="https://joke-lin.top/2020/04/09/2020-04-09-PAT-Advanced-1026/"/>
    <id>https://joke-lin.top/2020/04/09/2020-04-09-PAT-Advanced-1026/</id>
    <published>2020-04-08T16:00:00.000Z</published>
    <updated>2020-05-17T08:49:00.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NzIzMzMyNTA1NjA=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：</p><ul><li>当一个VIP球台空的时候，排队中的第一个VIP可以优先使用</li><li>如果当前没有VIP用户等待，普通用户也可以使用VIP球台</li><li>如果VIP用户没有VIP球台可以使用，就使用普通球台</li></ul><p>存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。</p><a id="more"></a><h2 id="基础思路">基础思路</h2><p>其实有很多种处理的方式，我采取的策略为：</p><ol type="1"><li>用户按时间排序，将每个球台开放时间保存为数组</li><li>分别获取球台的最早的普通球台和VIP球台开放时间</li><li>如果是普通先开放，意味着没有VIP球台多余，直接给下一个等待用户即可，另外处理没有任何等待用户的情况</li><li>如果是VIP球台先开放（包含和普通同时开放的情况），查找顾客数组是否有VIP在等待，有的话给此VIP用户，否则给等待的第一个普通用户，如果没有人等待，进入处理无人等待的情况</li><li>无人等待的情况处理：没人等意味着下一个来的可以马上处理，如果来的是VIP查看是否有VIP球台，有给他，没有则给普通，普通用户则直接给空闲的编号最小的球台（此时没VIP等待）</li></ol><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FpeWlzaHVhaS9wLzExMzcyMTUzLmh0bWw=">PAT 甲级 1026 Table Tennis (30 分)（坑点很多，逻辑较复杂，做了1天）<i class="fa fa-external-link-alt"></i></span>其中的测试样例</p><p><strong>在<code>测试点8</code>错误了，原因为：在检查是否有VIP在排队的时候，忽略了此VIP用户可能在之前以及被处理（VIP有时候可以优先）</strong></p><p>代码实现还是有些细节的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrival;</span><br><span class="line">    <span class="keyword">int</span> served;</span><br><span class="line">    <span class="keyword">int</span> isvip;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Player&amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrival &lt; another.arrival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt; players; <span class="comment">// 存储玩家</span></span><br><span class="line">P tables[maxn]; <span class="comment">// 桌子 first：释放时间 second：是否VIP</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>, clock_21 = <span class="number">21</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">int</span> table_count[maxn];  <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">bool</span> is_served[<span class="number">10001</span>];  <span class="comment">// 玩家是否被服务 针对VIP优先处理</span></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = sec/<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (sec%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> s = sec%<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, h, m, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 以及更新对应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_serverd_player</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> table_pos, <span class="keyword">int</span> served_time)</span> </span>&#123;</span><br><span class="line">    print_time(players[index].arrival); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>; print_time(served_time); <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">int</span> wait = (served_time - players[index].arrival + <span class="number">30</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, wait);</span><br><span class="line">    is_served[index] = <span class="literal">true</span>;</span><br><span class="line">    table_count[table_pos]++;</span><br><span class="line">    tables[table_pos].first = served_time + players[index].served;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回VIP和非VIP的最小下标</span></span><br><span class="line"><span class="function">P <span class="title">getMinTableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == <span class="number">-1</span> || tables[i].first &lt; tables[index2].first) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == <span class="number">-1</span> || tables[i].first &lt; tables[index1].first) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;index1, index2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有人等待的情况 VIP的话要先看是否有空闲的VIP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_wait</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取空闲VIP和普通的最小下标</span></span><br><span class="line">    <span class="keyword">int</span> index1 = INF, index2 = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">if</span>(players[index].isvip) &#123;</span><br><span class="line">        tar = index2 == INF ? index1 : index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tar = min(index1, index2);</span><br><span class="line">    &#125;</span><br><span class="line">    push_serverd_player(index, tar, players[index].arrival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(table_count, <span class="number">0</span>, <span class="keyword">sizeof</span>(table_count));</span><br><span class="line">    <span class="built_in">memset</span>(is_served, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_served));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> hh, mm, ss, p, tag;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d %d"</span>, &amp;hh, &amp;mm, &amp;ss, &amp;p, &amp;tag);</span><br><span class="line">        <span class="keyword">int</span> sec = hh*<span class="number">3600</span> + mm*<span class="number">60</span> + ss;</span><br><span class="line">        p = p &gt; <span class="number">120</span> ? <span class="number">120</span>*<span class="number">60</span> : p*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(sec &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        players.push_back(&#123;sec, p, tag&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(players.begin(), players.end());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        tables[i] = &#123;clock_8, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止全部都是普通或者VIP 导致获取下标函数返回没有意义的值</span></span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">0</span>&#125;;</span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> vip_pos; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vip_pos);</span><br><span class="line">        tables[vip_pos<span class="number">-1</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = players.size();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_served[index]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Player p = players[index];</span><br><span class="line">        P min_index = getMinTableIndex();</span><br><span class="line">        <span class="comment">// 后面的都不用处理了</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &gt;= clock_21 &amp;&amp; tables[min_index.second].first &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> table_empty_time;</span><br><span class="line">        <span class="comment">// 普通的先空 意味着没有VIP位置 那么直接给等待的下一个</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &lt; tables[min_index.second].first) &#123;</span><br><span class="line">            table_empty_time = tables[min_index.first].first;</span><br><span class="line">            <span class="comment">// 有人在等待</span></span><br><span class="line">            <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                push_serverd_player(index, min_index.first, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没人等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                no_wait(index);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在空的VIP 位置 注意VIP普通同时为空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table_empty_time = tables[min_index.second].first;</span><br><span class="line">            <span class="comment">// 寻找是否有等待的VIP 有则先给他位置 否则给下一个人</span></span><br><span class="line">            <span class="keyword">int</span> vip_pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; len;i++) &#123;</span><br><span class="line">                <span class="comment">// Error 8:最后一个测试点卡。。已经处理的VIP 跳过</span></span><br><span class="line">                <span class="keyword">if</span>(is_served[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(players[i].arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(players[i].isvip) &#123;</span><br><span class="line">                        vip_pos = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有VIP在等</span></span><br><span class="line">            <span class="keyword">if</span>(vip_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// printf("index:%d vip:%d\n", index, vip_pos);</span></span><br><span class="line">                push_serverd_player(vip_pos, min_index.second, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有VIP在等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 但有普通人等</span></span><br><span class="line">                <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="comment">// 普通人也可以选择VIP的位置 看哪个小选哪个</span></span><br><span class="line">                    <span class="keyword">int</span> tar_pos = tables[min_index.first].first == tables[min_index.second].first ? min(min_index.second, min_index.first) : min_index.second;</span><br><span class="line">                    push_serverd_player(index, tar_pos, table_empty_time);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没人等</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    no_wait(index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,table_count[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != k<span class="number">-3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个VIP球台空的时候，排队中的第一个VIP可以优先使用&lt;/li&gt;
&lt;li&gt;如果当前没有VIP用户等待，普通用户也可以使用VIP球台&lt;/li&gt;
&lt;li&gt;如果VIP用户没有VIP球台可以使用，就使用普通球台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>求解图的连通分量</title>
    <link href="https://joke-lin.top/2020/04/06/2020-04-06-connected-components/"/>
    <id>https://joke-lin.top/2020/04/06/2020-04-06-connected-components/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-05-17T08:48:57.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单定义">简单定义</h2><p>有向图中称为，强连通分量。连通图和连通分量都是针对无向图。</p><p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p><a id="more"></a><h2 id="无向图">无向图</h2><p>对于无向图而言，只要从一个点开始使用DFS或者BFS遍历所有可以遍历的边，这些遍历到的点集就构成了一个连通分量。然后寻找下一个之前没有遍历的点作为下一个连通分量的根结点，继续进行遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 连通分量的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num_nodes;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有向图">有向图</h2><p>下面两个算法都是<span class="math inline">\(O(N+E)\)</span>的复杂度</p><h3 id="tarjan算法">Tarjan算法</h3><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnl2b2lkLmNvbS96aHMvYmxvZy9zY2MtdGFyamFu">有向图强连通分量的Tarjan算法<i class="fa fa-external-link-alt"></i></span></p><p>算法的基本思想如下：任选一节点开始进行深度优先搜索（<strong>若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行</strong>）。搜索过程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。</p><p>节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。</p><p>算法代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      <span class="comment">// 为节点u设定次序编号和Low初值</span></span><br><span class="line">    Stack.push(u)                              <span class="comment">// 将节点u压入栈中 其实就是保存拓扑序</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E                       <span class="comment">// 枚举每一条边</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)                   <span class="comment">// 如果节点v未被访问过</span></span><br><span class="line">            tarjan(v)                          <span class="comment">// 继续向下找</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)                       <span class="comment">// 如果节点v还在栈内</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])                      <span class="comment">// 如果节点u是强连通分量的根</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                          <span class="comment">// 将v退栈，为该强连通分量中一个顶点</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>DFN[u]：为结点u的搜索编号（时间次序）</li><li>Low[u]：为结点u和与结点u相连的子树的最小搜索序（最早出现时间）</li></ul><p>此算法其中判断强连通分量的思路就是，在以u为根节点进行DFS的过程中如果出现一个结点v指向了之前遍历过的点t，即<span class="math inline">\(u \rightarrow t \rightarrow v \rightarrow t\)</span>也就表明出现了一个环，其中<span class="math inline">\(t,v,t\)</span>就构成了环，即连通分量。</p><p>其中的DFN就保存每个结点的访问顺序，Low保存相关子树的最早访问时间，在算法回溯的时候更新，可保证一个强连通分量的Low都是一致的，栈保存的是拓扑序，即遍历的次序，不断出栈获取连通分量。</p><h3 id="kosaraju算法">Kosaraju算法</h3><p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNjQzNzkyNi5odG1s">Kosaraju算法解析: 求解图的强连通分量<i class="fa fa-external-link-alt"></i></span></p><p>Kosaraju算法比Tarjan算法看似要简单一些，但效率没有Tarjan算法高，Kosaraju算法依靠DFS遍历获取极大连通子图。但存在一点问题。</p><p><img src="\assets\ArticleImg\2020\connected-components-1.png" /></p><p>对于上图，从A0开始遍历和B4开始遍历是不一样的结果。如果从B开始遍历，需要2次DFS便可以遍历完整个图，而A0只需要一次。<strong>所以Kosaraju算法的第一个DFS需要获取正确的遍历顺序，</strong>然后第二次DFS的次数便是连通分量的个数了。</p><p>上图的反图为：</p><p><img src="\assets\ArticleImg\2020\connected-components-2.jpg" /></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) dfs1(v);</span><br><span class="line">  s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      dfs2(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是两点：</p><ol type="1"><li>后序遍历获取拓扑序，保证BA的相对顺序不会改变</li><li>反向原图根据上面获取的遍历顺序，重新DFS</li></ol><h4 id="反图的作用">反图的作用</h4><p>其中的反图很有意思，对于强连通子图，反图和原图并无区别。但对于非强连通的则会有很大的影响。例如<span class="math inline">\(A \rightarrow B \rightarrow C\)</span>反图为<span class="math inline">\(A \leftarrow B \leftarrow C\)</span> 从A开始遍历一次便遍历完，但反图后从A开始便需要3次，也就是强连通分量的个数（单个结点也是强连通）。而且反图保证了图的收缩，可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2NTI2NjkyMy9hbnN3ZXIvOTEyMjM5MTky">Kosaraju算法为什么是用图G的反向图的逆后序，而不能是图G的后序？<i class="fa fa-external-link-alt"></i></span></p><p><strong>所以通过后续遍历获取遍历结点的顺序，然后通过反图获取强连通分量的个数。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单定义&quot;&gt;简单定义&lt;/h2&gt;
&lt;p&gt;有向图中称为，强连通分量。连通图和连通分量都是针对无向图。&lt;/p&gt;
&lt;p&gt;在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点&lt;strong&gt;强连通&lt;/strong&gt;(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个&lt;strong&gt;强连通图&lt;/strong&gt;。非强连通图有向图的极大强连通子图，称为&lt;strong&gt;强连通分量&lt;/strong&gt;(strongly connected components)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://joke-lin.top/categories/Coding/"/>
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/Coding/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1021 Deepest Root （连通分量+树的直径）</title>
    <link href="https://joke-lin.top/2020/04/03/2020-04-03-PAT-Advanced-1021/"/>
    <id>https://joke-lin.top/2020/04/03/2020-04-03-PAT-Advanced-1021/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-05-17T08:48:49.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODI5MTk2NzM4NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。</p><a id="more"></a><h2 id="思路">思路</h2><p>掌握了基础的<a href="/2020/04/06/2020-04-06-connected-components/">连通分量的求法</a>以及<a href="/2020/04/02/2020-04-02-tree-diameter/">树的直径的算法</a>便很简单了</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"><span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDeepest</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;height_set, <span class="keyword">int</span> heights = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            getDeepest(G[root][i], height_set, heights+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_height == heights) &#123;</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_height &lt; heights) &#123;</span><br><span class="line">            height_set.clear();</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">            max_height = heights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            components++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(components &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>, components);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st_points, ed_points;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(<span class="number">1</span>, st_points);</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(*st_points.begin(), ed_points);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ed_points) &#123;</span><br><span class="line">            st_points.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : st_points) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>树的直径</title>
    <link href="https://joke-lin.top/2020/04/02/2020-04-02-tree-diameter/"/>
    <id>https://joke-lin.top/2020/04/02/2020-04-02-tree-diameter/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-05-17T08:48:38.883Z</updated>
    
    <content type="html"><![CDATA[<p>树的直径，即<strong>树中距离最远的两个节点的距离</strong>。</p><h2 id="求解方法">求解方法</h2><p>选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。</p><a id="more"></a><h2 id="简单证明">简单证明</h2><p>其实只要证明：<strong>以任意点为根节点，距离此根节点最远的节点必定是树的直径中的一个端点。</strong></p><p>证明了这个，那么上面提到的算法就很容易证明了，获取第一个端点，然后以此端点为根的最远端点就是另外一个端点。</p><p>首先规定从<em>r</em>开始的最远距离节点为<em>u</em>，证明<em>u</em>为树的直径的一个端点，可以使用反证法证明，假设存在另外两个节点<em>s,t</em>，构成了树的直径。</p><ol type="1"><li><p><strong><em>st</em>的路径和<em>ru</em>不相交</strong>：</p><p>在这种情况下，存在<span class="math inline">\(dis(u,s)+dis(s,t) &gt; dis(s,t)\)</span>，所以<em>st</em>并不是最长的，和假设相矛盾，<em>st</em>这种情况下不存在</p></li><li><p><strong><em>st</em>的路径和<em>ru</em>相交于点<em>v</em>：</strong></p><p>此时<em>s,u</em>都是以<em>a</em>为根的子树上的节点，因为u为距离a最远的结点所以可得： <span class="math display">\[ dis(a,y)+dis(y,u) &gt; dis(a,y)+dis(y,s) \\ 即：dis(u,y) &lt; dis(s,y) \]</span> 同样表示<em>s,t</em>并不是最长的，而是<em>u,t</em></p></li></ol><p>综上，<em>u</em>必定为树的直径的一个端点。</p><p>关于树的直径的更多性质可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2hhZGEtSmhpbi9wLzEwMTk1Mjg3Lmh0bWw=">博客园 树的直径及其性质与证明<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树的直径，即&lt;strong&gt;树中距离最远的两个节点的距离&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;求解方法&quot;&gt;求解方法&lt;/h2&gt;
&lt;p&gt;选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://joke-lin.top/categories/Coding/"/>
    
      <category term="DSAA" scheme="https://joke-lin.top/categories/Coding/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
      <category term="Graph Theory" scheme="https://joke-lin.top/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1020 Tree Traversals （二叉树）</title>
    <link href="https://joke-lin.top/2020/04/01/2020-04-01-PAT-Advanced-1020/"/>
    <id>https://joke-lin.top/2020/04/01/2020-04-01-PAT-Advanced-1020/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-05-17T08:48:29.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODUwMzM2MDMwNzI=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了</p><a id="more"></a><h2 id="解决思路">解决思路</h2><p>这是一个很经典的重构二叉树的问题了，只要清楚每种遍历的规则和规律即可。</p><p>后序遍历：左子树，右子树，根节点</p><p>中序遍历：左子树，根节点，右子树</p><p>所以对后序遍历而言，后面的节点是前面节点构成的树的根节点，前面节点构成左子树和右子树，所以我们可以采取以下方案获取整棵树的结构。</p><p>从后序遍历数组<code>postorder</code>的末尾开始，从<code>inorder</code>数组中寻找和<code>postorder</code>相同值的，<strong>这样就可以分为两边，分别是左子树和右子树</strong>。然后将<code>postorder</code>末尾向前移动一步，对应的就是右子树的根节点。然后在<code>inorder</code>刚刚分开的右半边继续寻找即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> postorder[maxn];</span><br><span class="line"><span class="keyword">int</span> inorder[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left = <span class="literal">NULL</span>, *right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一棵树 根据根节点的值（这里提供postorder的下标），以及inorder的左右边界</span></span><br><span class="line"><span class="function">Node* <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> post_i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *t_root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 分开左右子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == postorder[post_i]) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_root-&gt;val = inorder[mid];</span><br><span class="line">    <span class="comment">// 递归左右子数</span></span><br><span class="line">    t_root-&gt;right = getTree(post_i<span class="number">-1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    t_root-&gt;left = getTree(post_i - (r - mid) - <span class="number">1</span>, l, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, postorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, inorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getTree(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">    que.push(root-&gt;left);</span><br><span class="line">    que.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        Node *t = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,t-&gt;val);</span><br><span class="line">        que.push(t-&gt;left);</span><br><span class="line">        que.push(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了&lt;/p&gt;
    
    </summary>
    
    
      <category term="OJ" scheme="https://joke-lin.top/categories/OJ/"/>
    
      <category term="PAT" scheme="https://joke-lin.top/categories/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://joke-lin.top/tags/C-C/"/>
    
  </entry>
  
</feed>
